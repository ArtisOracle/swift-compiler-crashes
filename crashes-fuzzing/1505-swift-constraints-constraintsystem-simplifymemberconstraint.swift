// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
}
map() {
}
struct D : a {
protocol A {
typealias F = b
return d, x in c : T)
}
protocol a {
map(2, self.c = { }
class b(s([unowned self.join(T>) -> {
struct e where T>(c = a: d = e: (self.b: b = {
protocol P {
}
typealias d.C<T) -> d<T
func f(i> ((Any) {
func a<l : AnyObject, Any) -> {
struct c(bytes: S) -> String {
}
}
b
}
}
enum B : Any, e = F>() {
class a {
}
}
}
a
println(A.init(f(z())
b((z: b.c = B<T>]
case b {
}
static let a
return m(h
}
typealias e = b: H) -> {
case s({
}
a)
}
var d<T where g> : B("
struct c
init() {
func e<f == h> : S<T.h)
class func b[T: T: Hashable> Int {
}
}
}
func e(g
class C: c() -> {
}
func e()
var b: [Any) -> (Any) -> A {
}
public var _ = compose<T, g : AnyObject)
init()
func b[$0
assert(x, Any)
private let x }
}
class B : (c(()
class A<T -> () -> String)
struct c : Int = a() -> a {
}
}
typealias F
}
}
return self.e
static let start = F>]
extension NSData {
d.g : b(g() {
b(B<d
enum b = a: c<T](A? {}
convenience init() {
}
func b(n: k.c<d>() -> {
func e> T>? = g<S {
return self.init(start, x = a()
get {
}
map(t: NSObject {}
return !)-> {
"
override func c<T: c = f: b>
