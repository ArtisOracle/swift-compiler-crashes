// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


func ts<edc>() -> (edc, edc -> edc) -> edc {
vu u vu.u = {
}
{
edc) {
qp  }
}
protocol ts {
class func u()
}
class vu: ts{  class func u {}
class yx {
r kj = kj
}
class c {
func kj((po, c))(yx: (po, fe)) {
kj(yx)
}
}
func w<e: SequenceType, v on lk<v> == e.l.c>(wv : e) -> v? {
rq (yx : v?) xw wv {
ml j vu = yx {
ji vu
}
}
ji s
}
j wv : [hg?] = [s, dcb, s]
sr(w(wv))
func ay(ih: qp) -> <v>(() -> v) -> qp {
ji { edc xw "\(ih): \(edc())" }
}
func yx(vu: po, po: po) -> (((po, po) -> po) -> po) {
ji {
(cb: (po, po) -> po) -> po xw
ji cb(vu, po)
}
}
func kj(p: (((po, po) -> po) -> po)) -> po {
ji p({
(ut: po, ji:po) -> po xw
ji ut
})
}
kj(yx(ba, yx(cb, dc)))
func yx<v>() {
ed kj {
kj c
}
}
protocol A v : nm>(kj: v) {
}
ts(ts x nm)
protocol yx {
r vu
r e = vu
r ts = vu
}
class kj<qp : c, u : c on qp.edc == u> : yx {
}
class kj<qp, u> {
}
protocol c {
r edc
}
class A<v : A> {
}
func c<vu {
ed c {
func e
var _ = e
}
}
ed e<v> {
kj C(v, () -> ())
}
protocol A {
func c() -> qp
}
class cb {
func vu() -> qp {
ji ""
}
}
class C: cb, A {
o func vu() -> qp {
ji ""
}
func c() -> qp {
ji ""
}
}
func e<v on v: A, v: cb>(wv: v) {
wv.c()
}
yx=ba x yx=ba
struct c<vu : SequenceType> {
var kj: vu
}
func yx<vu>() -> [c<vu>] {
ji []
}
protocol A {
}
struct cb : A {
}
struct C<gf, edc: A on gf.C == edc> {
}
protocol yx {
}
protocol kj : yx {
}
protocol c : yx {
}
protocol vu {
r ts = yx
}
struct e : vu {
r ts = kj
}
func u<u : kj, ut : vu on ut.ts == u> (hg: ut) {
}
func kj {
r vu
r e
}
struct c<qp : kj> : kj

