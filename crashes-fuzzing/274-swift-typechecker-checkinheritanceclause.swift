// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

f b<g f:
func f<g {
  enum f {
    func f
var _ = f
protocol A {
    typealias E
}
struct B<T : A> {
    let h: T
    let i: T.E
}
protocol C {
    typealias F
    func g<T where T.E == F>(f: B<T>)
}
struct D : C {
    typealias F = Int
    func g<T where T.E == F>(f: B<T>) {
    }
}
a)
func a<b:a
protocol A {
    typealias B
}
class C<D> {
    init <A: A where A.B == D>(e: A.B) {
    }
}
func a() as a).dynamicType.c()
func prefix(with: String) -> <T>(() -> T) -> String {
  return { g in "\(with): \(g())" }
}
struct d<f : e, g: e where g.h == f.h> {
}
protocol e {
    typealias h
}
protocol a : a {
}
func a<T>() -> (T, T -> T) -> T)!c : b { func b
struct c<d : SequenceType> {
    var b: d
}
func a<d>() -> [c{
    enum b {
        case c
    }
}
func String {\(with): \(g())" } i {}
protocol f {
    k g d {
    k d 
    k k
}
j j<l : d> : d {
    k , d>
}
class f: f {
}
class B : l {
}
k l = B
class f<i : f
protocol A {
    func c() -> String
}
class B {
    func d() -> String {
        return ""
    }
}
class C: B, A {
    override func d() -> String {
        return ""
    }
    func c() -> String {
        return ""
    }
}
func e<T where T: A, T: B>(t: T) {
    t.c()
}
func f() {
    ({})
}
func f<T : BooleanType>(b: T) {
}
f(true as BooleanType)
func a<T>() -> (T, T -> T) -> T {
    var4, nil]
println(some(xs))
protocol A {
    t   class func i()
}
class d: f{  class func i {}
var x1 = 1
var f1: Int -> Int tInt -> Int) -> Int in
    return f>] {
    return []
}
func i(c: () -> ()) {
}
class a {
    var _ = i() {
    }
}
struct A<T> {
    let a: [(T, () -> ())] = [namicType.c()
func ^(a: BooleanType, Bool) -> Bool {
    return !(a)
}
protocol a {
    class func c()
class b: a {
    class func c() { }
}
(b() as a).dynamicType.c()
b
protocol c : b { func b
func some<S: SequenceType, T where Optional<T> == S.Generator.Element>(xs : S) -> T? {
    for (mx :       if let x = mx {
     d: f{  ceanTy b {
    clasi() {
    }
}
func e<k>() -> (k, k -> k) -> k {
   f j f.i = {
}
 {
   k) {
       n  }
}
m e {
   class func i()
}
class f: e{  class func i {}
func n<i>() {
    k k {
        f j
    }
}
func n(k: Int = l) {
}
let j = n
class k {
    func l((Any, k))(m }
}
func j<f: l: e -> e = {
   
 {
   l) {
      m  }
}
protocol k {
   class func j()
}
class e: k{  class func j 
a=1 as a=1
class f<d : d, j : d k d.l == j> {
}
protocol d {
    i l 
    i i
}
struct l<l : d> : d {
    i j i() {
        l.i()
    }
}
protocol f {
}
protocol d : f {
struct A<T> {
    let a: [(T, () -> ())] = []
}
var x1 =I Bool !(a)
}
func prefix(with: Strin) -> <T>(() -> T) in
// Distributed under the terms of the MIT license
class i<h>: c {
    var g: h
    init(g: h) {
        self.g = g
        e{
    j d>
}
class f {
    typealias e = e
class a {
    typealias b = b
}
i)
import Foundation
class q<k>: NSObject {
    var j: k
    e ^(l: m, h) -> h {
    f !(l)
}
protocol l {
 d g n()
}
class h: l {
    class g n() { }
}
(h() o l).p.n()
class l<n : h,
-func b<d>(a : d) -> c {  {}a
class c {
    func b((Any, c))(a: (Any, AnyObject)) {
        b(a)
    }
}
class a<f : b, g : b where f.d == g> {
}
protocol b {
    typealias d 
    typealias e
}
struct c<h : b> : b {
    typealias d = h
    typealias e = a<c<h>, d>
}
var f = 1
var e: Int -> Int = {
    return $0
}
let d: Int =  { c, b in
    }(f, e)
q
var m: Int -> Int = {
    n $0
 o: Int = { d, l f
    n l(d)
}(k, m)
protocol j {
  typealias d
  typealias n = d
  typealias l = d}
class g<q : l, m : l p q.g == m> : j {
}
class g<q, m> {
}
protocol l {
    typealias g
func q(v: h) -> <r>(() -> r) -> h {
  n { u o "\(v): \(u())" }
}
struct e<r> {
    j p: , () -> ())] = []
}
protocol p {
}
protocol m : p {
}
protocol v : p {
}
protocol m {
 v = m
}
func s<s : m, v : m u v.v == s> (m: v) {
}
func s<v : m u v.v == v> (m: v) {
}
s( {
    ({})
}
t 
func a<T>() -> (T, T -> T) -> T {
    var b: ((T, T -> T) -> T)!
    return b
}
struct c<d : SequenceType> {
    var b:  [c<d>] {
    return []
}
protocol a {
    class func c()
}
class b: a {
    class func c() { }
}
(b() as a).dynamicType.c()
func f<T : BooleanType>(b: T) {
}
f(true as BooleanType)
func a(x: Any, y: Any) -> (((Any, Any) -> Any) -> A  var d: b.Type
    func e() {
        d.e()
    }
}
b
protocol c : b { func b
otocol A {
  E == F>(f: B<T>)
}
struct  }
}
struct j<l : o> {
    k b: l
}
func a<l>() -> [j<l>] {
    return []
}
f
k)
func f<l>() -> (l, l -> l) -> l {
   l j l.n = {
}
 {
   l) {
        n  }
}
protocol f {
   class func n()
}
class l: f{  class func n {}
func a<i>() {
    b b {
        l j
    }
}
class a<f : b, l : b m f.l == l> {
}
protocol b {
    typealias l 
    typealias k
}
struct j<n : b> : b {
    typealias l = n
    typealias k = a<j<n>, l>
}
func b(c) -> <d>(() -> d)
func a(x: Any, y: Any) -> (((Any, Any) -> Any) -> Any) {
    return {
        (m: (Any, Any) -> Any) -> Any in
        return m(x, y)
    }
}
 
func b(z: (((Any, Any) -> Any) -> Any)) -> Any {
    return z({
        (p: Any, q:Any) -> Any in
        return p
    })
}
b(a(1, a(2, 3)))
func m(c: b) -> <h>(() -> h) -> b {
  f) -> j) -> > j {
    l i !(k)
}
d
l)
func d<m>-> (m, m -
protocol b {
    class func e()
}
struct c {
    var d: b.Type
    func e() {
        d.e()
    }
}
f g
}
struct d<i : b> : b {
    typealias b = i
    typealias g = a<d<i>i) {
}
let d = a
d()
a=d g a=d
protocol a : a {
}
class a {
    typealias b = b
func a<T>() {
    enum b {
        case c
    }
}
)
var d = b
=b as c=b
func b((Any, e))(e: (Any) -> <d>(()-> d) -> f
func f<T : BooleanType>(b: T) {
}
f(true as BooleanType)
func a<T>() {
    enum b {
        case c
    }
}
func prefix(with: String) -> <T>(() -> T)> Int  {
    return []
}
protocol A
w
class x<u>: d {
    l i: u
    init(i: u) {
        o.i = j {
  r { w s "\(f): \(w())" }
}
protocol h {
    q k {
    t w
}
w
protocol k : w { func v <h: h m h.p == k>(l: h.p) {
    }
}
protocol h {
    n  func w(w: 
}
class h<u : h> {
import Foundation
class m<j>k i<g : g, e : f k(f: l) {
}
i(())
class h {
    typealias g = g
protocol A {
    typealias B
    func b(B)
}
struct X<Y> : A {
    func b(b: X.Type) {
    }
}
protocol a {
}
protocol b : a {
}
protocol c : a {
}
protocol d {
  typealias f = a
}
struct e : d {
  typealias f = b
}
func i<j : b, k : d where k.f == j> (n: k) {
}
func i<l : d where l.f == c> (n: l) {
}
i(e())
struct A<T> {
    let a: [(T, () -> ())] = []
}
f
e)
func f<g>() -> (g, g -> g) -> g {
   d j d.i 1, a(2, 3)))
class a {
    typealias b = b
}
func i(c: () -> ()) {
}
class a {
    var _ = i() {
    }
}
struct A<T> {
    let a: alias g
}
func prefix(with: String) -> <T>(() -> T}
 a
}
struct e : f {
  i f = g
}
func i<g : g, e : f where e.f == g> (c: e) {
}
func i<h : f where h.f == c> (c: h) {
}
i(e())
class a<f : g, g : g where f.f == g> {
}
protocol g {
    typealias f 
    typealias e
}
struct c<h : g> : g {
    typealias f = h
    typealias e = a<c<h>, f>
enum S<T> {
    case C(T, () -> ())
}
struct A<T> {
    let a: [(T, () -> ())d : SequenceTy
    return []
}
func prefix(with: String) -> <T>(() -> T) -  t.c()
}
import Foundation
class Foo<T>: NSObject {
    var foo: T
 = 1
var f1: Int -> Int = return $0
}
let succeeds: Intr _ = i() {
    }
}
func c<d {
    enum c {
        func e
        var _ = e
    }
}
f> {
 c(d ())
}
func b(e)-> <d>(() -> d)
protocol A {
    typealias E
}
struct B<T : As a {
    typealias b = b
}
func a<T>() {f {
   class func i()
}
class d: f{  class func i {}
func f() {
    ({})
}
func prefix(with: String) -> <T>(() -> T) -> String {
  return { g in "\(with): \(g())" }
}
protocol a : a {
}
}
func a<g>() -> (g, g -> g) -> g {
    var b: ((g, g -> g) -> g)!
    return b
}
func f<g : d {
    return !(a)
  enum g {
        func g
        var _ = g
struct A<T> {
    let a: [(  th
}
func prefix(with: String) -> <T>(() -> T) -> Sting{))" }}
func a<T>() -> (T -> T) -> T {
 T, T -> T) ->)func pre{
}
func i(c: () -> ()) {
}
class a {
    var _ = i() {
    }
}
f
e)
func f<g>() -> (g, g -> g) -> g {
   d j d.i = {
}
 {
   g) {
        h  }
}
pss d: f{  class func i {}
func f<e>() -> (e, e -> e) -> e {
   e b e.c = {
}
 {
   e) {
        f  }
}
protocol f {
   class func c()
}
class e: f{  class func c
({})
func prefix(with: String) -> <T>(() -> T) -> String { func b
clanType, Bool) -> Bool {
)
}
strs d 
    typealias b> : b {
    typealias d = h
    typealias e = a<c<h>, d>
}
func m<u>() -> (u, u -> u) -> u {
   p o p.s = {
}
 {
   u) {
        o  }
}
s m {
   class func s()
}
class p: m{  class func s {}
s p {
    func m() -> String
}
class n {
    func p() -> String {
        q ""
    }
}
class e: n, p {
    v func> String {
        q ""
    }
 {
  r m = m
}
func s<o : m, o : p o o.m == o> (m: o) {
}
func s<v : p o v.m == m> (u: String) -> <t>(() -> t) -
protocol a {
  typealias d
  typealias e = d
  typealias f = d
}
class b<h : c, i : c where h.g == i> : a {
}
class b<h, i> {
}
protocol c {
    typealias g
}
f
e)
func f<g>() -> (g, g -> g) -> g {
   d j d.i = {
}
 {
   g) {
        c
    }
}
imporsuper.init()
ny, Any) -> Any) -> Any)) -> Any {
    return z({
        (p: Any, q:Any) -> Any in
        return p
    })
}
b(a(1, a(2, 3)))
func prefix(with: String) -> <T>(() -> T return "\(with): \(g())" }
}
func d<b: SequenceType, e where Optional<e> == b.Generator.Element>(c : b) -> e? {
    for (mx : e?) in c {
func c<g>() -> (g, g -> g) -> g {
   d b d.f = {
}
 {
   g) {
        i  }
}
i c {
   class func f()
}
class d: c{  class func f {}
struct d<c : f,f where g.i == c.i>
struct l<e : SequenceType> {
    l g: e
}
func h<e>() -> [l<e>] {
    f []
}
func i(e: g) -> <j>(() -> j) -> k
func b<d {
    enum b {    func c
 var _ = c
proto   func b(B X<Y> : A {
    func b(b: X.Type) {
    }
}
class A<T : A> d: f{ func i {}
col C {
 : C {
verride func d() ->  }
}
func e<T where T: A, T: B> -> T)!
    r b
protocol a : a {
}
func c<d {
    enum c {
        func e
        var _ = e
    }
}
protocol b {
    class func e()
}
struct c {
    var d: b.Type
    func e() {
        d.e()
    }
}
protocol a {
  typealurn []
}
func a<T>() -> (T, T -> T) -> T {
    var b: ((T, T -> T) -> T)!
    return b
}
import Foundation
class d<c>: NSObject {
    var b: c
    init(b: c) {
        self.b = b
     ()
   }
}
protocol A {
    typeal= D>(e: A.B) {
    }
}
var x1 = 1
var f1: Int -> Int = {
    return $0
}
let succee""
    }
}
class C: B, A {
    override func d() -> String {
        return ""
    }
    func}
class c {
    func b((Any, c))(Any, AnyObject
    typealias b = b
}
struct A<T> {
    let a: [(T, () -> ())] = []
}
protocol A {
    typealias B
    func b(B)
}
struct X<Y> : A {
    func b(b: X.Type) {
    }
}
func f() {
    ({})
}
f
e)
func f<g>() -> (g, g -> g) -> g {
   d j d.i = {
}
 {
   g) {
        h  }
}
protoco 0) {
}
let c = a
c()
class c {
    func b((Any, c))(a: (Any, AnyObject)) {
        b(a)
    }
}
func c<d {
    enum c {
        func e
        var _ = e
    }
}
class A<T : A> {
}
func some<C -> b = b
}
class A: A {
}
class B : C {
}
typealias C = B
}
class f<p : k, p : k n p.d> : o {
}
class f<p, p> {
}
protocol k {
    e o
}
protocol o {
    class func k(dynamicType.k()
f j = i
f l: k -> k = {
    m
}(j, l)
f
protocol k : f { func f
func i(c: () -> ()) {
}
c1, f1)
func prefix(with: String) -> <T>(() -> T) -> String {
  return { h):g())" }
}
struct c<S: SequenceType, T where Optional<T> == S.Generator.Element>(xs : S) -> T? {
    for (: T?) xs{
>
protocol a {
}
protocol b : a {
}
protocol c : a {
}
protocol d {
  typealias f = a
}
struct e : d {
  typealias f = b
}
func i<j : b, k : d where k.f == j> (n: k) {
}
func i<l : d where l.f = 0) {
}
let c = a
c()
b
protocol c : b { func b
protocol a {
 ss b<h : c, i : c where }
}
func f() {
    ({})
}
protocol a : a {
}
protocol a {
  typealias d
  typealias e = d
  typealias f = d
}
class b<h : c, i : c where h.g == i> : a {
}
class b<h, i> {
}
protocol c {
    typealias g
}
f: A where D.C == E> {s func c() { }
}
(b() as a).dynamicType.c()
func c<d {
    enum c {
        func e
        var _ = e
    }
}
b
protocol c : b { func b
({})
func ^(a: BooleanType, Bool) -> Bool {
    return !(a)
}
>)
}
struct n : C {
 class p {
    typealias n = n
}
l
l)
func l<u>() -> (u, u -> u) -> u {
   n j n.q = {
}
 {
   u) {
        h  }
}
protocol l {
   class {
    func n() -> q {
        return ""
    }
}
class C: s, l {
  t) {
    return {
        (s: (t, t) -> t) -> t o
        return s(c, u)
    }
}
 
func n(r: (((t, t) -> t) -> t)) -> t {
    return r({
         return k
    })
o
class w<r>: c {
    
    init(g: r) {
        n.g = g
        s.init()
(t: o
struct t : o {
  p v = t
}
q t<where n.v ==  t<v : o u m : v {
}
struct h<t, j: v where t.h == j
func prefi(with: String-> <T>() -> T)t
protocol a {
    class func c()
}
class b: a {
    class func c() { }
}
(b() as a).dynamicType.c()
protocol a : a {
}
fu> Bool {
    return !(a)
}
class c {
    func b((a: (Any, AnyObject)) {
        b(a)
    }
}
f
e)
func f<g>() -> (g, g -> g) -> g {
   d j d.i = {
}
 {
   g) {
        h  }
}
protocol f {
   class func i()
}
class d: f{  class func i {}
protocol A {
    fu]
}
func a
func f<T : BooleanType>(b: T) {
}
f(trstruct X<Y> : A {
    func b(b: X.Type) {
    }
}
func prefix(with: String) -> <T>(() -> T) -> String {
  retus F = Int
    func g<T where T.E == F>(f: B<T>) {
    }
}
func some<S: SequenceType, T where Optt>(xs : S) -> T? {
    : T?) in xs typealias h
}
enum S<T> {
    case C(T, () -> ())
}
class A<T : A> {
}
func c<d {
    enum c {
        func e
        var _ = e
    }
}
protocol a {
    class func c()
}
class b: a {
    class func c() { }
}
(b() as a).dynamicl A {
    {
    typealias b = b
 d.i = {
}
 {
   g) {
        h  }
}
protocol f {
   class func i()
}}
