// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


> {
protocol b = .R
}
class C
}
return nil
[T>>()
func b
let c
}
class B == {
}
func b() {
let a {
func g.h> : B(e: T> Int -> ()
}
func b
class B<Q<(e: Array) -> {
init(t: T>(x)
typealias F = 1, AnyObject.e == Int
convenience init() {
let a {
import Foundation
struct d: T> : NSManagedObject {
init <T> String {
struct e == nil
class A : T -> [B<C<T.c = nil
println(T] {
class A : A? {
import CoreData
}
let d.c: d = b: T> Void>("
let d
e == a
protocol A : d = 0)
0)
class d
import Foundation
func f: P {
struct c == nil
struct B<T, f<T where H) -> [B<T! {
}
override init()
}
enum A : T>Bool)-> [unowned self.E == nil
}
let d: P> (false))
struct d.E == D>()-> : c) {
self.init()
}
func g.h
}
func b<T! {
extension NSSet {
let h == """\(f: U)(self.B) {
class A {
}
}
self.init("
func compose<T] {
typealias F = {
}
}
}
struct B<T where A.B : P {
let g = {
}
println(x: Int = {
let c>(e, object1
self.b in
var b: B<T.d
let h == b.init(f: Array<T.c = e, V, AnyObject) {
}
self)
typealias e = nil
protocol a {
func f, g<T
}
class A {
func compose(f: P {
let d: Array) {
class C> (f: C {
e == nil
}
class func b
var f : c: c: NSObject {
import Foundation
}
return b: Int = nil
}
var e)
struct S {
}
b: U : Int = nil
var d where I.h == D> T where T> {
if c : A> T -> Int {
}
var b: (v: A>(e)"
S<C
var f = 0

