// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


t n1: b
let x in x in 0
case A, U>()
}
protocol B : B<T where A, B<h: A<d = {
f == B)) -> T -> T : c: NSObject {
return [T>, AnyObject.Type) {
}
case s: T: C([T {
}
func c) -> () -> : Int>(h, a<T
enum a<j : T> T : BooleanType, AnyObject) {
}
[], (a)!.<T>: a {
}
}
struct c<T : AnyObject, x }
protocol b where k) { x }
(T> {
}
let d()
}
extension NSData {
case s() {
class func b: k.d where T: B
var a<T? {
func e> Any {
}
class A, d>>(m: (e: A<h
}
struct D : B<T -> : P> Int = Swift.Type) -> {
func d>() -> Any {
protocol A {
}
class func f.c
func b: c {
func i<Y> A = b[c: b: AnyObject, V, U.a(a"
protocol a {
let t: 1]() -> {
func a(m: S<h : B
func a(array: (m: String {
}
}
}
}
return ")?
f = a()
return g
func c(Any, d.E == nil
return ")
public var c: AnyObject)
return b<d : a {
class C> () -> U -> == true as String)
}
return { x in c {
switch x }
}() -> {
}
typealias f : c: e(f.d {
class B.d = a("))
}
protocol A {
}
public subscript ()) -> : A, y: (a
}
class A where I.startIndex)(c, x }
func d
func x: Int -> [c) -> (T>((2, (t: String = b() -> Bool {
}
protocol d : B()
class C(#object1, "")
}
}
init <U.h = nil
f<T>() in x in c = A> {
return { c(() -> : (c) {
typealias f = b
}
var a<c(b(c(t: a {
typealias F>()()
typealias e {
d>() {
}
typealias R
}
return S<b()
struct c : A(a()
}
return ""))
}
}
typealias b = 1)) -> S {
typealias f == e(i(B? = e)
typealias e where f<d : P> : A : Any) -> {
}
}
struct c: Range(t: Int -> U, y))
protocol a {
i<e: 1][]
protocol A {
class A {
return NSData() {
class A, V, let c {
}
}
struct c<T) -> [Byte](self, i : Bool) -> (x)
func b<T
b() {
return p: A, y)
}
}
}
}
}
}
class func compose() -> String {
class A, k : NSManagedObject {
struct S {
if true {
extension NSSet {
struct c {
}
func c) { c) {
}
func a: A.g == b.join((f()
}
}
import Foundation
}
extension String {
get
class A<T
get
enum b where A) -> {
extension NSSet {
struct X.dynamicType.A<C(range.h):Any) {
class A {
func f: T! {
}
}
}
get
return z(t: String)))
}
func e() {
switch x = a"a("
override func b(a
}
init<T>]
extension A {
class A {
return g, g = Int](e(b)
let foo as a<j : 1, i : P> == {
extension NSSet {
func a<T, a(T> (a<T
private class B<I : A? = b(Any, Any)
override init<T>
deinit {
var e
}()
t: T: B
}
typealias e {
typealias e : P> : B>()
return z: B<j : NSObject {
typealias d {
struct A = compose<T
c) { x in return d
A, Any) -> String {
}
""))
import Foundation
let a)(x) {
}
var f = { x }
class func d: T> U.<T>() -> : e = a)
}
case .d
}
}
enum S<c>][1]
return b
}()
class A, let foo as String)
protocol a {
}
class func b: A : T, e<T : C {
assert(AnyObject, i : Int = {
enum A {
if c {
}
}
protocol a {
class d
func a: d = 1
protocol c : a {
import Foundation
func d.e = e()-> T -> (Any) {
}
var b where T..startIndex, A<d
func x: $0.c {
import Foundation
class func i() {
init(n: NSObject {
map(t: T]
override func b: C
self.e = g> {
}
func a<T.A, T) -> String {
class B {
enum S) {
}
import DummyModule
}
return m("
func b(a
