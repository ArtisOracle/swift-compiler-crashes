// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


te class a: A"]
}
})
}
func d: a {
typealias f = c
public var f(self.h : AnyObject) -> {
}
super.b {
}
protocol b in
typealias f = c(#object1: [1)(start, A.dynamicType)
}
typealias R
return { c
}
class func b<T
class B : b in x in x }
func b: P> <c()
enum A {
}))
}
case s(true }
}
class A<T! {
}
}
typealias e!() -> {
self.C) -> {
}
struct Q<T.init()
protocol C = { }
}
func i(")
struct c {
A> T -> : T> == j> {
func i(()
super.dynamicType).C
}
}
get {
func b: b
}
}
protocol a {
import Foundation
typealias d : a {
struct e = D> () -> Int -> {
override init()(() -> {
}
protocol a {
}
}
import DummyModule
func f<T>: T>((c
}
}
}
}
import DummyModule
return p
}
}
d(n: Int
convenience init()?
return p
func d>? {
}
}
}
}
}
typealias B() -> : U {
typealias d = [T>(A, range.endIndex - range.h : 1, k : SequenceType> U.startIndex))
}
}
}
import Foundation
self)
func f<T : e where T : P {
func g<f = b<T, A, f.endIndex - range.f : l) {
}
protocol A : T>(.A, U, T where d: [self[c<S {
println(a))
self)
}
func x, Any) { c<l : Array<T ->() -> Any, x = B, Any) -> T, y)
}
}
let h
func b: Int) -> {
typealias C {
extension NSSet {
case s(n: A) {
var b(object1: Int) -> {
b())-> {
}
d
protocol a {
b: d>) -> [T> V>() {
class c {
}
}
}
var b, g == {
enum S) -> {
return "
enum a: d {
var b
