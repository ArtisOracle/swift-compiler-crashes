// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

protocol c : a<T where T>
func c,
{
func b
protocol c {
protocol e : ([Void{
func b
0.C([[[Void{
struct A {
let f = [Void{
let start = B<T where S<T: c { func b
(object1: d = [Void{
struct A {
[]
"\("
Void{
let end = [Void{
let end = compose(false).C
func a<T where T>
struct A {
"
[]
class B<T where T>: ("
func b
func b<T: b { func a
0.e = T.C([[[Void{
0.C(false).e = []
[Void{
case c
class B<e>(e = T.e : (e : b { e) -> c : Any).C
{
let end = T>
class
let end = [Void{
protocol c : Any).e : a<T where S<T.e = [Void{
class d
let f = B<T>
let start = []
[Void{
let f = [[Void{
(([Void{
protocol c {
class B<T where T: B<T>
let start = [Void{
(object1: (false)?
{
class
class
let start = T.e = T: b { func c,
class d<Int>
let start = B<e
Void{
[Void{
let f = [Void{
class
class B<T where T>
Void{
{
"
protocol e : b { func c,
case c
i> Void{
class B<U : b { func b
protocol e = B<T where T>(e : ([Void{
let f = T>
func c,
{
class
class B<T where S<U : S<e) -> Void{
protocol e : S<T : b { e>
class B<T where T>: S
[[[Void{
i> c {
let start = B<T : a<T>: d = compose((((e : a<Int>
{
func a<Int>
protocol c : d = compose(object1: a
class B<U : a
let end = T>(f: Any).C
struct A {
case c,
func a<T where T>
protocol c { e>: a<Int>
case c
class d<T where T>: b { func b
Void{
class B<T where T>: c {
protocol e = [Void{
[Void{
"
func b<T where S<T where T>: Any)?
func b
func b
protocol c {
struct S<T where S<T where T: b { func a
class B<U : d = [Void{
0.e : b { e
let f = compose(e : S<T>
{
{
{
func b
func b<T where S<T>((f: a<T>(false)?
[Void{
[[[[Void{
case c,
let end = [Void{
i> Void{
((false).C
protocol e : e
let end = B<T>: a
class B<Int>(object1: d<T>(object1: S
("\("
let f = [Void{
class B<T where T: b { func a
func c
{
let f = []
Void{
let end = [Void{
func b
{
class d<U : a
class d
class
case c,
func c,
let start = T>
Void{
let start = []
let start = T>
class B<T where T: B<T>
class B<T where T: Any).e : S<Int>: (f: Any)?
struct S<T: b { e) -> Void{
class d
func c,
struct A {
let start = T>: B<T where T>("
case c,
func c,
protocol e = compose(e : d = []
func b
((f: B<T where S<T
