// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

t) -> d
class B : NSObject {
func g<l : a {
return """
import Foundation
}
typealias e = b: SequenceType, x }
struct S<T : T, q:
}
class b.b : NSManagedObject {
}
}
struct B
return { self.dynamicType)(seq: Array<C() -> ()
class func b() {
protocol P {
}
}
typealias f = {
}
}
}
struct A<e
}
protocol A {
}
}
}
}
func f: d = i(2, e, e(T>) -> String
protocol b {
}
}
println((() {
}
}
class A {
typealias e: AnyObject.d.c = nil
return m: Int) -> {
case s: B<S {
return ")
}
func e({
}
b> {
protocol a {
}
struct c(b: e: a {
return self.init(.R
convenience init() -> {
let v: b: T.count]
class C<h
init() as [1])
import Foundation
return !(b.E == [[Byte]
}
enum A = h: T) { c: AnyObject.C() {
func g<j : e(A<T
return NSData(h)
f: c) {
let t: d {
typealias B == [T {
}
func f: Bool]
typealias C {
struct c where S) -> T : A {
import Foundation
protocol P {
typealias e {
assert() -> {
class A, T -> d
")
typealias A where d>)
protocol A {}
deinit {
return [$0
func a(f: SequenceType, e: B)
typealias f == B<j : b<d, V, Any, b = {
struct D : e = [0x31] = nil
}
}
class A {
protocol b {
class A where T! {
private let a {
var a!(f(a<T : T? = e? = b[0
case ..a: b(A, end: Array) -> String {
class C() {
class b<A<T>((a"ab"A, object2))
println(f: A<T -> String {
}
println(".startIndex)
var b.count]()
typealias B : B, A
