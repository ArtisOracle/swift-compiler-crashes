// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


init(t: P {
func x)
return ")
extension Array {
}
}
protocol b {
struct e = e> () {
protocol d where A, range.b in
class C) {
}
let b = 0.e : c()
}
class A<T -> {
func x(seq: Int = Swift.Generator.d(b<f == A<S {
println(1
convenience init({
}
init <B : [T>() -> : d where S().E == B
struct A<T : P> {
func a: b[1)() -> : $0.A, e> {
class c : (start: String)
}
S<h = g<T {
}
protocol b {
func d) {
func a(A: P {
}
for b : C(array: d {
}
return NSData() in 0
}
self.init(f)
}
override func i> {
class a : b
}
}
class A<f == B, (a(c in 0] == true as String)
}
}
d(2, Any, ()
}
class func a(x) -> A {
struct c)
class A {}
func b() {
class A {
}
}
}
func a: b: [T where l) -> {
typealias e: d where g<T where l.e {
protocol a {
}
typealias C {
}
b(()
}
}
t.endIndex - range.<T: B<l : ((b(h
class A(c() -> String {
}
protocol a {
println()
protocol c {
}
for b = c, A {
}
assert() {
import DummyModule
super.E == c) -> {
for c = .Type) in return d() {
a
var b
}
case A.init(A<T>, AnyObject) {
}
func a<1 {
struct e = B
}
return x in c in 0.R
}
func i<(n: BooleanType>(bytes: ()
let h> String {
protocol c {}
struct e : C = A<H : A {
self.e(""foobar"")
case c: c, self, T where k) -> (a() {
}
}
}
}
func a: T.f = """""""]()
convenience init(x: k.Generator.startIndex)
}
}
func g: C(#object1: (Range<T where T: e)
return "
protocol d where A
protocol a {
public subscript (a()
func b> {
}
typealias d>(() -> String {
}
}
func c, """
func f.a
protocol A {
})
class func a
protocol a {
assert()
}
typealias e : d = F>)
func compose<c: CollectionType where H) -> ["""
typealias B))).Element>(AnyObject)
typealias e : a {
}
}
}
var e?
}
}
}
var e(b
fu
