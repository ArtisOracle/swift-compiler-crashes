// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


subscript (g> [0] = D> {}
}
protocol B {
extension Array {
}
}
func c, y)
struct Q<Int>())
import DummyModule
class a: d = c], AnyObject) -> String {
func b: A, Any) -> S.g == B
}
class A<D>() -> Any) {
protocol A {
}
enum b {
class A {
f(n: B)
}
return NSData(b: $0.e = Int>()
import Foundation
return [B, b = i<T : NSObject {
}
protocol b {
func a)
let f : Array) {
typealias g: Array) {
let h == 0
return !
extension String {
case A? {
init({
println(T.f = b: Array<S : AnyObject) -> () -> Bool {
}
typealias C {
class B : AnyObject, U) -> {
d(#object1: A<T) { c: a {
case .B : c(T>(bytes: b: Hashable> : T>() -> Any in
}
class a((1
protocol a {
}
return g
assert(")?
b()
protocol d = h>)
}
class B = f)-> : Array) {
func a<T : b : b
class func c, let n1: Range<T) {
let d: String {
protocol b {
class A>) -> {
class a {
class B<T -> == b: B
}
}
protocol A {
func f, U) {
}
}
}
func i: S<T : (A? {
func i((g<D> : B<T {
class A {
var a(T] {
}
init(start, T : d.b> T>(A? {
}
(t: () {
}
func f(B<S : P {
import Foundation
}
let g = {
init("
extension NSSet {
public var e<c(e: B<T>>: d where h.a()
map() -> String {
let foo as BooleanType, i(true {
}
}
typealias h
init()
}
typealias d = [0x31] = Swift.b = B
extension String {
func b((x: I.C> String {
}
import CoreData
}
}
}
}
func b<U {
typealias A {
if true as String)
self.dynamicType.E == B<T : AnyObject> T
}
class A.count]
func b()
var b(")
}
}
}
}
}
case c<f == a"[1]
}
func e?) {
var d {
typealias B<C(x, c<T
}
self.b("foo""""foo""
protocol P {
enum b = c].c in return b: b()-> {
}
}
class func b: Array<T -> : X<T where g> d(c) {
}
let f : (1).<e
func ^(c<T> Any, U) -> {
}
override init<T : T: start: T> String {
protocol P {
func g: b> {
class A {
func b
typealias C {
class A.h : C = {
}
var c()
let t: Range(self.a
class a : c<d
}
}
func a<T>][T, y)).init()
func g() -> Any) {
}
import Foundation
let n1: b
var b[0) {
import Foundation
}
}
}
}
}
let h: A = b> String {
import Foundation
convenience init<T {
var d : c(a(f<Y> {
init() {
func a)
switch x {
self.c : (() -> {
}
[T) -> {
class a<d():
t: a!.Element>) {
class a<C(f.c, self.e(t: A<T : A? = b: A<T) {
override init() -> (a() -> Any in
e where f, 3)((mx : Int) {
class b: B<T -> Void>(#object1: () ->
}
func b, range.b {
import Foundation
}
struct Q<T>] == .f == { _, e?
var b, (Any, g = 1)?
var b
}
protocol a {
f: b {
}
}
}
}
private let x in x in return b()
}
println(Any) -> (c] = b
func f<T
switch x }
map(c) {
class A {
typealias F>({
}
extension NSData {
}
}
struct Q<S : Int
() {
struct c : ()
func d>(h: Bool]](([0
var d
protocol c : BooleanType>() {
typealias f == B) -> () as String) -> {
}
}
func g<T>() -> Any, f()
}
protocol b = g()() -> String) as String):
}
enum b = T? = B
}
}
case A.h: A: () {
var b<Q<h : [0x31] as a<U)
import Foundation
}
}
return "\() {
}
}
assert()) {
}
}
var b("".Element>(([c> [$0
}
protocol P {
typealias f = ["
func b> Bool {
enum B : b(x, V>(object1: BooleanType, T : A<Y> Int = nil
import Foundation
let g == c: BooleanType>() -> T : Range<T: B, U) -> {
}
}
typealias e where H) {
func compose<Int) {
struct e = F>() -> A {
switch x = ""
}
() {
func i: b> T: A.init<Y> {
}
class func d<T, object2)
}
}
typealias f = compose(a<h : d, A {
}
a(T)
return x in a {
}
}
super.E == D>(")
func a(Range<f = {
func f, (n: k) {
import Foundation
typealias b where Optional<T : d = a: SequenceType, a
}
}
class A, T: a {
typealias E
map(a: start: $0)
case .c
}
class A where S) {
case b {
return g<U : P> : d where I.c) {
}
protocol d where h: T>()
protocol b = b> {
class c {
protocol a {
println(")))
typealias h: b {
