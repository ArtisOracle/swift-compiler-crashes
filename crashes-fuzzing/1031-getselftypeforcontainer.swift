// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
}
}
return [0x31] == [unowned self] as [])
typealias R
return self..c {
}
}
deinit {
}
enum a<B : d : b(true as BooleanType>())
protocol b : C {
}
S..c : B<H : Array) -> {
}
}
class C
}
protocol b : b> d
").R
let i<T) -> {
protocol b = {
}
}
println(bytes: a {
return nil
}
}
typealias g(T, Any) {
}
}
protocol d where g.init(f(c in x in x }
struct c, a(c, i(h: A<Int
func i> Bool {
}
typealias d<A? {
class b(self.c : (t: k.d = nil
}
self] {
}
public subscript (x)
protocol a {
public var a("ab"foo"foobar""")
}
}
}
}
protocol c in 0
}
struct A> T>("
self.dynamicType.dynamicType)
typealias b = {
println((2, d.init(""]("a"
}
}
let end = [self.C()
convenience init() {
}
class func a
typealias F>: C() -> Any, self] {
protocol A : T> : d: Any) {
}
convenience init<S : [c<H : A = Int])
var _ c: AnyObject) {
protocol B {
}
}
class C() {
}
typealias B, A {
class func g<S : U) -> Any) in c {
struct S<B {
func c<h>((n: Int = T.c(T> : String {
typealias A {
public var b
func f("foo""foo""
}
class A>
func c()
func b<T) -> V {
init(.B {
typealias F>, V>Bool)
case c: d : a {
}
class func g<c: e: A: B
class A {
class A {
func b.init(range: B<D> String {
}
class A {
var f = {
func d>)
class func f: l) {
}
b: (true {
let g = c<Q<l : ()
let c = Swift.a
d
var e?
}
import Foundation
}
return p
case C: Array) in return [](a: ExtensibleCollectionType>) -> T] = d<C({
return p: B(bytes: (self] = {
}
func d(T, f: A, U.substringWithRange(self.E == nil
}
}
struct c<S : (c<T>((T.f == B)
extension Array {
typealias d where h)).b : l.c<T.B<T)
protocol A = T
func a: start, self.count](f: BooleanType)
typealias f : b.b {
}
struct c<T : Any)
protocol a {
func b: Int) -> String {
class A {
t.a() -> {
}
private let b {
}
}
typealias E
super.a<T) -> {
let a : A<T> T, a"[]))
return {
class a<b.a(seq
import Foundation
}
}
}
}
}
protocol C {
func b
class func a: (a: BooleanType>() -> <T : T>)
return S<h>(b(start: a {
}
class c<d, Any, range.C(g<H : SequenceType> {
func d: (self.<T, V>, object2: NSManagedObject {
}
}
protocol A {
}
}
typealias f == 1)()
let h == b<D>? = B) -> {
convenience init(x, e, Any) -> Any) {
get {
class A {
class b> Any in
}
d<T, Any] == 1)() -> V, object2)
}
}
})
}
class a()
import DummyModule
struct A {
}
func b.advance(A"a<I : I.b = b: C) -> {
}
class A {
var d(bytes: T>()
func f<h: AnyObject, (start, let foo as [[self] == A, range.join(z: NSObject {
return g.init(A>>(x))(c<d where T -> : b {
}
protocol d where f() {
}
return NSData(x) {
struct S : A, y)
protocol a {
func g, A<T : k.Type
import DummyModule
}
}
typealias e : T, e {
class b: d {
}
let d) -> T {
import Foundation
}
}
}
}
var a)
self.substringWithRange(x(g<T {
protocol c {
}
protocol C = g, x {
func b: A<T>()
}
}
let h == {
}
func b<T>] = A.d
class A = f<D> T : S<T>) -> {
}
}
convenience init<S {
static let d.f = c(T>(Any) {
func f: BooleanType>(_ = B<T? {
}
import Foundation
}
func a: d where I.advance(c: A<S : T, k : U -> {
return !("cd"")
}
var b(Any) + seq: ("
protocol P {
var d = "cd"A> Int = B)
}
var b = i: T>(b
}
protocol b {
func i: S<c> Any) -> String {
class func c> {
typealias R = b, T>(T> T>()
}
return nil
}
}
}
func b: () + seq: P> {
b: [1
case s: Any) {
}
}
protocol d = nil
println(b(1](range.c(array: ()
}
func f: B, b {
protocol b {
e where B : (A<B = c) { self.f = b<Q<d.g == "".d.d<d = a("""")
class A<T -> {
extension NSSet {
public class B {
}
func i() -> S {
public class A {
}
}
})
}
class c {
let a([self.dynamicType.e = 1
case s()
}
}
}
}
return self.e == a
let f = B..B {
return m() -> {
convenience init() -> {
}
}
}
var b = T>()
return d: b, U, U) {
return "a(c([unowned self.c : AnyObject, d.b {
var _ = {
struct c in a {
}
class b> T>?) {
var a<h = b: b<D> {
d.A, (x(a: T, Any] = g: A"
protocol C {
func a: Range(()
}
init(.advance()
var e(""foo"
return d
}
init <j : BooleanType, object2)
import Foundation
func x) {
func f, Any, B(b() -> (b[Any, k : ("").h
}
func f, d: d {
a()
}
map(self.Generator.Generator.startIndex, e(p: [Any)
struct c where f<T -> String {
protocol B : SequenceType where B {
import Foundation
}
}
return b("
}
}
}
}
for c = a()] {
println()
}
import Foundation
return [].init({
}
func g.Element == i<T>(start: H..startIndex)
class a: e = {
}
}
}
struct A {
}
}
public subscript () -> Void>(T> ()
return [c: NSObject {
let h: [c<T {
}
typealias d
class B : S) in x in x }
func a(x) {
func i: d where g(Any)() {
let foo as [c((({
}
}
}
protocol A : T] = A<(.e = A<B : AnyObject.e = i> S(T.advance() -> A {
(.c == g: A<T> {
protocol P {
}
import Foundation
S..b : d = {
}
struct A> Any) {
protocol d {
}
return ".g = a
}
case .init(T) {
class C
}
}
init(self.Element == [Int) {
return m: B<T>>() -> Any, Any) -> V {
let b {
static let x }
import DummyModule
f: Int -> (object1, x }
protocol a {
class A {
if c = Swift.A> (a(b()
init <T) -> : C: T : BooleanType>(c(c, U)
}
}
protocol b = B
class func f: [Int) -> {
d
}
}
}(seq
})
}
0.startIndex)
}
}
}
protocol a {
}
protocol A {
println(n: SequenceType where I) -> A {
func e? = c: b.endIndex - range.<l : Bool)(bytes: () -> T {
convenience init()
0) {
func d, d: Any)
}
return {
}
(.c {
public class A = true as [c) {
return S.b : AnyObject, let n1: [0x31] = 0.B
}
typealias R
return self.c : k.join(m: $0.init<T>] = b.c<h, g : P {
return "))
}
typealias R = g<T>
}
func f<T: String {
import CoreData
protocol A {
var c) -> Bool {}
}
}
}
}
struct S.startIndex)
typealias e = f: b> [self[T>(T, B, range.d.startIndex)
var f = [T where h)
}
protocol b : U) -> {
get {
protocol P {
}
}
import Foundation
b
extension NSSet {
import Foundation
}
b()
deinit {
d: a {
get
}
class C(h: NSObject {
func f<f = .g = a<T] in
return x in x in x in return "cd"
var e: Array<3] = a(bytes: Int>() {
}
typealias F = b(n: B) {
}
typealias e()
public class c> S {
}
}
let x }
}
struct D : Int>(Any] == j> U -> T>)(.Generator.c : T>() {
class a {
println(h
}(self, T where k.c : X<1 {}
f: b
self.e == 1))
func g, "\(c) -> {
return b: String {
import Foundation
b> (i<T) -> Int = Int]()
init<Int) {
}
return z(bytes: b(b: l.init()
return true
return m({
init(Any) -> {
class a {
var b : b([c])))
}
}
class A {
class A) -> String {
init <h : C()
}
class func g<d("ab"".startIndex)
typealias e = D> (n: d {
}
public class A<d
convenience init(A<d) -> {
static let h : BooleanType>(""""[1, U>()
case C()
func a: b(A>Bool)
t: X.E == {
var e? = b<d
}
}
}
typealias F = {
func e: l.A.b> A {
let d() -> Any, U) -> String {
}
self.init(a<T : b {
typealias e {
}
println("ab"]()
println(("ab".dynamicType.c {
get
case c<T : Range(array: String = B>
}
return x in x }
}
class A {
func a().c == .init(b.init([Byte]
}
func a<T) -> Any))
return p
func a)
protocol a {
enum S) {
let x }
}
}
self.e = {
})
func b: Any) -> Any) -> Self {
convenience init() {
struct D : A<T where A<T] = 0
self)
func b: AnyObject)
extension A {
typealias e {
d(_ = T]
(start: P {
return true
i<l : d where f(T>, b = Int>(b(A, y: String {
}
"cd"foobar""
}
}
class b("
class a {
}
return p
}
init(b(h: S(a: A = e(c, e, U.dynamicType)
class a {
}
var b {
struct S {
class c: A, g = A.advance(h: a {
func a: a {
super.A"foo")
}
func b: 1)
typealias d == c(array: (a!)
class A {
}
}
}
return b(t: T> () -> U.f = {
public subscript (a(e: Range<T) {
return nil
var e()
S) {
func d.E == nil
import Foundation
var f = b) -> Any {
}
func a: b {
}
import Foundation
protocol P {
func c, range.init():Any] in
class B
class A where d: end))
func e
protocol A {
}
import Foundation
return nil
protocol b {
}
var b[Any) -> U.h
func g<T -> {
}
""))] in
}
case A, g<e> Any) {
let h == a() -> T>>() {}
}
protocol C {
}
}
var a<Int
}
}
public var b: a {
public var e> Int = f.B : A {
t: a = [(T)
}
}
}
d) {
return m(T? = 0.Element == g: Range<h : SequenceType where f<(b: A = [0x31] {
}
func a
}
}
protocol A where f() -> U {
b
}
let c = c(_ = f<Int) -> {
f : a {
return x in c == nil
}
protocol c = b
typealias b where h
}
func g: A<c: c] {
return "foobar","
}
}
init(false).dynamicType.A, g == 0
func c> T, a
let start = b, let t.c {
typealias F
println(false)!)
typealias d>(n: b {
assert(T>() {
}
}
}
}
}
return "")
func g<T> {
func e? {
}
class d
public var f.Element>((A> T.h = 1
}
}
}
}
case C: String {
struct A = nil
let end = a(b, g : b
}
}
}
return b: U -> : Any) -> : A? {
func b()) -> ("):
struct X<Q<3] = { self.d {
}
var d {
static let h == nil
return z(object1, ()
class b()
}
enum b = {
c(Any, A = 1)
class A = Swift.c where T>(self.d = i(()
}
init<b()
func f<(")
}
return self.a() {
convenience init()
}
protocol P {
(Any) {
}
extension Array {
convenience init() -> {
extension NSData {
default:
}
}
}
let d>() {
protocol P {
println(1, i: b)
convenience init(f() {
}
var b) {
let h == f: a {
}
var e)(["")
}
}
protocol c {
}
import Foundation
func a"A, AnyObject> () -> () -> {
init()
import Foundation
func c<h.endIndex - range.dynamicType)
func g()
}
}
protocol b in a {
class func b
}
}
}
return $0] == Swift..C<T -> (self[$0] as a!
return d, x }
case c
}
typealias F = Swift.init<T : SequenceType, length: d where I) -> T))
b
}
typealias B == {
typealias e = Swift...b {
extension NSSet {
class C
protocol C = b: P {
var f((false)
}
func d>, let end = c] = ")")) -> V, Any) -> String {
typealias d.c) {
}
}
func d
let d<T, self.<U>(b(seq
super.R
import DummyModule
}
}
let c<T -> T>("[c) {
}
}
}
struct X<T -> {
get {
func call(t: SequenceType> U) {
return { _, let end = i(b
t: Int
public var b
}
case b {
}
return self.A.b {
protocol d where l) {
assert(()
}
})
protocol a : B) {
typealias f : d : T -> T>(s(T>?) -> {
class c {
}
protocol b : ((g: d where l.d
import DummyModule
}
}
}
}
println(Range())
}
let h: String {
let x }
}
class A {
func a<A) -> Any) -> Int = g<Y> Any {
class A : C()
}
}
""
}
}
return nil
class a)
import DummyModule
}
import DummyModule
}
convenience init() {
}
}
println():
}
}
}
struct d
return """")
}
}
self.C(self] = [T>) {}
init <d(c<l : Bool]
}
let h
protocol C = 0] = """\())] = c: e? = T) -> A {
}
t: S<T.startIndex)
protocol A : a {
}
protocol a {
init(range.startIndex)
func e: b {
}
class a)
func c(() -> Any) {
}
protocol A {
}
typealias d : e: C {
}
t: A""")
return { }
func d..Generator.d<f == [c<T -> [].c) { self.endIndex - range.h.startIndex)
}
}
case A, let h> A {
(x() {
}
}
}
class A : c: Int) {
}(b(Any) -> (array: S<c
return ""
typealias A : a: (m: d : T>(g, A, range.init(A> T) -> S {
}
func ^(g(start, T : b
let f == A<l : Any] = {
}
func a)) {
}
func g<f = A<T : Hashable> [c: b) -> (T: Range()] = ".advance() -> T {
class a<C()
init(A? = {
func b: d where I.substringWithRange(i: Array<T>
}
}
func d: T where g<()
convenience init() -> V>() -> Self {
}
f = [0x31] {
}
let t: NSObject {
}
extension NSSet {
}
class d>(a)
func call(i(b(1][()
}
enum A {
func g: b[())!
static let f == A>: BooleanType).c<Int>("""foobar")
}
protocol P {
}
}
func f.c<I : SequenceType where T: A, a() -> U)
typealias e = 1)
protocol a {
typealias A {
}
}
}
protocol A where l) -> Bool {
}
}
case c) -> {
class a {
}
class c {
}
}
extension NSData {
struct e == [0
}
}
return !.Type
}
}
func f<Y> Any in
convenience init(false)(([T : B<T : AnyObject)
func f.a: C {
struct S {
struct e = i<b<S : l.d: Bool)
}
}
b(t: AnyObject) {
return z()
class A = b
protocol a {
return [c
import Foundation
}
}
}
self))
}
}
f()
public class c {
"")
}
import Foundation
}
if c = g<T where Optional<T, Any) -> U.B == b
}
func b<f : ExtensibleCollectionType>
(x()))) -> () -> String)
import DummyModule
}
extension NSSet {
typealias e : B
}
func b) -> V, U) -> String {
}
func b(self.init() -> {
class A, e<T>?) -> Self {
return [T> Any) {
}
case c(b.e: e : B<T>)
}
let g = 1
public var b(((a(g<S : d = b()) -> (Any) {
d
}
typealias C {
class B : Any) -> T
struct A, object2)) -> (p
}
}
var f = g(n: T>() {
return nil
let i("
return ")
func d: A? = b(A<U -> {
enum S) {
}
((T>() -> == A? = b<U) as a<T, e)):
func c(b(()
import CoreData
let i: P {
protocol P {
protocol a {
class b(self, a()()
return ",""""""
protocol b in 0) -> T where A>: B
let a(T! {
protocol a {
struct A {
let start = A>) -> : a {
protocol d where A? = Swift.c {
[self.startIndex, b in
println(a(#object1: () -> Void>?
public subscript ()
let n1: A>() {
println(1)
}
class b
}
func f(T>(mx : a<T>>Bool)
for (a
func compose<T : T>() {
func a""[c], U, A {
var b in
var d : S() -> (b> Self {
var c(mx : U.advance() {
typealias E
}
}
self)
struct e : B<(m: ()
typealias B<Y> {
}
class B<Y> Any) {
var d = j> (x() -> : a {
}
}
}
}
private class a)?
var e? {
protocol B {
class A, T : c {
})
}
return x }
func f<Y> String {
class c: Any, e where f.B, U, length: T, A {
case C: T) -> S {
protocol b {
func g<S {
}
static let h == j> Int {
protocol a {
var e: I) -> T where A> Any, A {
}
let h: A {
return {
func g(self[T) -> {
class B<T) {
class B : () {
var f = nil
class A {
protocol b = B<D> Any in
}
}
return true
}
protocol a {
return """a(")
case c(b: ["
}
return true
var b: C {
}
for b = {
}
}
}
func a""[$0
class b<l : T)
}
typealias E
}
}
}
func a: Int -> V {
b(_ = { c) {
func b<h == nil
var c) {
var _ = {
public subscript ()
}
}
class A {
}
protocol e = [Byte](b<T: [")
return self.init(c(Range(t: P> (() -> U) {
}
let t: [$0
}
class A {
let a {
}
}
}
protocol b {
func b()!
}
return [T! {
func b: c: b: c {
return "")
}
}
case .dynamicType)
func b<T> A {
var e? {
typealias B
}
}
var a([T) {
}
protocol A : T where T>() {
struct S {
return NSData() -> {
}
typealias b {
}
}
func b<b()
func b) {
f.advance(A<T where k) -> () -> : b {
}
var d == c<d where g.join(A<T> Bool {
}
println("[")
}
}
func call(m()(A.Generator.b where S) {
}
(() -> {
func b[0x31] {
func a: b<d = f: String {
func b[c
let foo as [c
}
default:
}
func f.substringWithRange(""
}
}
class A where d>() {
}
func a(range.e where B : Array<d) -> Void>(Any) -> String {
var c) -> A {
}
class c == {
}
}
var d where f, y: [self.Type) {
}
let c = nil
}
}
}
func f: NSObject {
func g()
}
return z(Any) -> V>(t: T : []
() -> Any] {
}
}
}
}
}
import Foundation
}
import Foundation
var b("A>>? = a
}
class A..e: c in return !)
var d: T: b(""""\(x, A {
if c = g.A<T -> Any {
}
init() -> {
t: b {
}
class c {
convenience init()
}
assert()
struct A {
class C(z()?) + seq: c
b<d, x in return { _, let h: d = {
protocol B {
}
f: a = B.c {
func i: Any, object2)
protocol b = h, i : b in 0):
func c: $0.b = compose<h = d>(b: Int) {
}
var f.startIndex)
func e> () {
}
let c in x in return self.join(c, object2: SequenceType where g<D> Any, b {
}
func c([self.e> String {
func b.join(Any) -> T>((T, length: AnyObject.f = j> Int {
}
let h
}
import Foundation
}
}
}
}
}
}
case .<T
b[]() -> T where H.init(start, a: (x(T> [(m(")
case s()
protocol c : e?
}
}
}
protocol A = {
protocol A {
func c(b> {
case s: NSObject {
}
class b()
println(c<U) {
typealias e where d
convenience init((Any) {
class b: A {
}
"foo"
}
func f.endIndex - range.B)
}
}
typealias f = i(() in 0] = d.A? = i> A {
protocol b = T> a {
return [T>))
}
return {
}
return $0)
public class b: A, V>: C {
self.init() {
var c: c>?
var a<T, A, a: A, i> U -> T>(c> S : 1)
}
}
}
var b.endIndex - range: a {
typealias B {
func a)] == b
}
}
struct c
[1
return NSData(a(h: B
func b(f<T>(c() {
if c = b
enum A {
self.init(e(T? = b) -> Self {
}
return x in 0.dynamicType.Type) -> : String {
return NSData((x)) { }
}
}
}
}
deinit {
extension NSData {
})
let h == g<U) {
d() -> [1
convenience init(mx : T
func a((.e = c(false))
for c = b(()
return self.d : X.init(g(x: b, d<I : b(array: d {
func e?) {
var e? {
public subscript (i() {
}
}
func a<(_ = nil
enum S) -> Any {
class A : Array<T>) -> Any in
let c = 0)
}
}
}
}
}
func b: b(AnyObject.c {
extension NSSet {
}
class c {
"cd""""""A, f(true as String) -> {
}
}
b
enum A {
S) -> [T) -> {
}
}
typealias B.E == F>(A, Any, A = d<h
return m(start, g == b(self.Type) {
}
convenience init() {
public var e<I : String {
}
}
var a()
return m: BooleanType, e?
}
return "",

