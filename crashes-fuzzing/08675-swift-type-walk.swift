// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
protocol A {
var d {
enum S() { func f() -> d = c()
func g: C {
struct c<b: S<l : c(v: b class d-> {
}
struct c
func a<l : a {
protocol l : a {
enum S<b
let end = c() -> d where I.d: T>
}
var d where f: a {
protocol A {
}
enum S<T where T : a {
struct S(")
func a<b: T>Bool])
func b: T>: e() { class c : A {
protocol l : T>: S(v: T>Bool])
struct Q<d = g: A? = c<T where I.e = b: B>: T, U, g = b
protocol B {
struct S<b
enum S<d { class b: e
struct S<T where I.e = b: B>Bool])
func b<l : b: a {
}
func b: S<T where f
let end = b: S("\() -> d = b<b: A {
func a<l : a {
enum S<T, U, U, U, U, U, g = F
struct c<d { }
}
protocol B {
struct Q<T where I.e = 0
extension
func b
func b
class c : f { func a<T>: c<l : T>
class b: S<d:b class c : S<l : e
protocol B {
struct S() -> {
typealias e = g: S() { class b: B>Bool])
var d = b: A? = F
enum S<d { class c : S<T where I.d:b class c : b<T where I.d:b class c : S<d where T : f { class b: A {
var e(f: a {
extension
prefix
var d = b
var d = F
l(v: A? = c<b: S<d-> {
"\()
if c : f { class c : S<T where I.e = 0
struct c<T : a {
extension A"\() -> d where f
if c : A")
func b
var d = b<T, U, U, U, U, g = c
let end = c("\(f: B>: c() -> {
var d { }
func a<T where f
func a<b
var d {
protocol A {
let end = g: e() { func a<d = F
if c {
protocol l : B>Bool])
func b<T where I.e = b<T where I.d:b {
let end = b: B>
class b
var d { func a<d:b class c : a {
typealias e = c
let end = F
func b: T, U, U, U, g = F
}
protocol B {
var d = c<Int>Bool])
protocol l : A? = b: e
l() -> d { func a<T where I.d:b {
if c {
var d = b
func f
l() -> {
prefix
func a<T where f() -> {
enum S<d: b
class c {
protocol B {
var e
var d {
}
protocol l : b: c() { class d: A? = b<b<d where g<Int>Bool])
protocol B {
func a<l : B>
}
}
extension
struct c<b: T>Bool])
extension A
protocol l : S() -> {
"\() -> {
func b<T where T where f
func g<T where T where I.e = 0
var e
if c : C {
func g<d where I.d: S<T, U, U, g = b<d = b
struct c<T where T where f
struct c
var d = b: A? = b: b class d:b class b
var d {
func g<T : T, g = F
struct
