// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


in
}
class A : Int = nil
var d where I) {
}
protocol d {
}
class A {
struct c = a()
var e)
protocol a {
struct S {
typealias e == nil
}
typealias E
convenience init()
let c {
class d<T where T) -> {
var d = {
}
typealias e = 0
let d
func b(e, g<T
self.B == {
}
func a
typealias F = 1: e = c, V, object1: String {
convenience init(array: AnyObject) {
}
}
init() -> Void>) ->(n: B<U -> {
protocol d = {
}
protocol A : U)
typealias R = b<T>()
}
struct B<(false)
return nil
}
func call() -> Void>]()-> [unowned self.R
enum S(f.h> Int = nil
b
let d<C<T -> Self {
func g, e: T>() -> : A()
super.B : NSObject {
struct d
var b : $0
}
return $0
struct S {
}
var c>: NSObject {
}
}
}
}
struct S() -> T {
var d = c(self.B<D> ()
let t: B? = nil
return { x }
}
}
}
println(t: AnyObject.d.B) {
self.dynamicType)
var b = c) {
let h> ("
struct B(x: d {
}
}
private let t: T) {
}
let a {
}
struct c = c) -> Int {
class A : T>()
}
var b : B(")
var f = ")
enum S<U -> T where H) -> U)
struct d<T>(T>() -> {
class A : e: T: AnyObject.h = f: T {
}
class func f: C
protocol A {
typealias R
}(#object2: c: T
}
func g(")
}
import Foundation
class A : Int {
}
class func call(array: B? {
func a
let h
f = a()-> S<T.dynamicType)
}
f : A.b = b: C {
protocol C {
}
}(AnyObject, b in x }
}
}
init() {
if c = F>)
var b
}
typealias R = F>()
}
func g<T where T> Int = c
}
return nil
struct e where A"
import Foundation
return self.h> T : d where A> ()
private class A where T) -> {
func b: P> {
}
protocol C {
let d: B? {
}
assert()
func f)
}
typealias R
}
struct c {
protocol c = F
static let f = a()
}(b:

