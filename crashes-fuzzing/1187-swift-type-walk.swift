// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


func a<T>() -> (T, T -> T) -> T {
var b: ((T, T -> T) -> T)!
return b
}
class k<g>: d {
var f: g
init(f: g) {
self.f = f
l. d {
typealias i = l
typealias j = j<i<l>, i>
}
class j {
typealias d = d
func b<d-> d { class d:b class b
b
protocol d : b { func b
func d(e:  = { (g: h, f: h -> h) -> h in
return f(g)
}
d = i
}
class d<j : i, f : i where j.i == f> : e {
}
class d<j, f> {
}
protocol i {
typealias i
}
protocol e {
class func i()
}
i
(d() as e).j.i()
d
protocol i : d { func d
func f(c: i, l: i) -> (((i, i) -> i) -> i) {
b {
(h -> i)   d $k
}
let e: Int = 1, 1)
class g<j :g
class m: f {
j h) {
}
j(n k i)
func j() {
({})
}
m l
class o<h>:     g)
func j<d {
enum j {
func m
var _ = m
}
}
struct j<d : Sequencpe> {
var m: d
}
func f<d>() -> [j<d>] {
f g
}
struct d<i : b> : b {
typealias b = i
typealias g = a<d<i>i) {
}
let d = a
d()
a=d g a=d
protocol a : a {
}
class a {
typealias b = b
func r<t>() {
f f {
i i
}
}
struct i<o : u> {
o f: o
}
func r<o>() -> [i<o>] {
p []
}
class g<t : g> {
}
class g: g {
}
class n : h {
}
typealias h = n
protocol g {
func i() -> l  func o() -> m {
q""
}
}
func j<t k t: g, t: n>(s: t) {
s.i()
}
protocol r {
}
protocol f : r {
}
protocol i : r {
}
j
func a<d>() -> [c{    enum b {
case c
func d(b: String-> <c>() -> c)
protocol f {
k g d {
k d
k k
}
j j<l : d> : d {
k , d>
}
class f: f {
}
class B : l {
}
k l = B
class f<i : f
protocol A {
func c()l k {
func l() -> g {
m ""
}
}
class C: k, A {
j func l()q c() -> g {
m ""
}
}
func e<r where r: A, r: k>(n: r) {
n.c()
}
protocol A {
typealias h
}
c k<r : A> {
p f: r
p p: r.h
}
protocol C      l.e()
}
}
class o {
typealias l = l
protocol a {
}
protocol b : a {
}
protocol c : a {
}
protocol d {
typealias f = a
}
struct e : d {
typealias f = b
}
func i<j : b, k : d where k.f == j> (n: k) {
}
func i<l : d where l.f == c> (n: l) {
}
i(e())
d> Bool {
e !(f)
}
b
protocol f : b { func b
class k {
func l((Any, k))(m }
}
func j<f: l: e -> e = {
{
l) {
m  }
}
protocol k {
class func j()
}
class e: k{  class func j
func m<u>() -> (u, u -> u) -> u {
p o p.s = {
}
{
u) {
o  }
}
s m {
class func s()
}
class p: m{  class func s {}
s p {
func m() -> String
}
class n {
func p() -> String {
q ""
}
}
class e: n, p {
v func> String {
q ""
}
{
r m = m
}
func s<o : m, o : p o o.m == o> (m: o) {
}
func s<v : p o v.m == m> (u: String) -> <t>(() -> t) -
import Foundation
class Foo<T>: NSObject {
var foo: T
init(foo: T) {
B>(t: T) {
t.c()
} x
x) {
}
class a {
var _ = i() {
}
}
a=1 as a=1
enum S<T> {
case C(T, () -> ())
}
func b<d {
enum b {
func c
var _ = c
}
}
func f<e>() -> (e, e -> e) -> e {
e b e.c = {}
{
e)
{
f
}
}
protocol f {
class func c()
}
class e: f {
class func c
}
}
n)
func f<o>() -> (o, o -> o) -> o {
o m o.j = {
}
{
o) {
r  }
}
p q) {
}
o m = j
m()
class m {
func r((Any, m))(j: (Any, AnyObject)) {
r(j)
}
}
func m<o {
r m {
func n
n _ = n
}
}
class k<l : k
import Foundation
class k<f>: NSObject {
d e: f
g(e: f) {
j        h.g()
}
}
d
protocol i : d { func d
i
func m(c: b) -> <h>((       case c
}
}
({})
protocol a {
class func c()
}
class b: a {
class func c() { }
}
(b() as a).dynamicType.c()
}
func ^(r: l, k) -> k {
? {
h (s : t?) q u {
g let d = s {
p d
}
}
e}
let u : [Int?] = [n{
c v: j t.v == m>(n: o<t>) {
}
}
class r {
typealias n = n
func f() {
({})
}
h
}
func e<l {
enum e {
func e
j {
class func n()
}
class l: j{  k() -> ())
}
({})
func j<o : BooleanType>(l: o) {
}
j(j q BooleanType)
func p(l: Any, g: Any) -> (((Any, Any) -> Any) -> Any) {
return {
(p: (Any, Any) -> Any) -> Any in
func n<n : l,) {
}
n(e())
e
struct c<d : SequenceType> {
var b:  [c<d>] {
return []
}
protocol a {
class func c()
}
class b: a {
class func c() { }
}
(b() as a).dynamicType.c()
func f<T : BooleanType>(b: T) {
}
f(true as BooleanType)
func a(x: Any, y: Any) -> (((Any, Any) -> Any) -> A  var d: b.Type
func e() {
d.e()
}
}
b
protocol c : b { func b
otocol A {
E == F>(f: B<T>)
}
struct  }
}
import Foundation
class d<c>: NSObject {
var b: c
init(b: c) {
self.b = b
}
}
struct A<T> {
let a: [(T, () -> ())] = []
}
o
}
class f<p : k, p : k where p.n == p> : n {
}
class f<p, p> {
}
protocol k {
typealias n
}
o: i where k.j == f> {l func k() { }
}
(f() as n).m.k()
func k<o {
enum k {
func o
var _ = o
class A<T : A> {
}
func c<d {
enum c {
func e
var _ = e
}
}
protocol a {
class func c()
}
class b: a {
class func c() { }
}
(b() as a).dynamicl A {
{
typealias b = b
d.i = {
}
{
g) {
h  }
}
protocol f {
class func i()
}}
func d<b: SequenceType, e where Optional<e> == b.Generator.Element>(c : b) -> e? {
for (mx : e?) in c {
}
}
struct c<e> {
let d: [(  h
}
func b(g: f) -> <e>(()-> e) -> i
struct d<f : e, g: e where g.h == f.h> {
}
protocol e {
typealias h
}
func b((Any, e))(e: (Any) -> <d>(()-> d) -> f
func k<q {
enum k {
func j
var _ = j
}
}
class x  {
s m
func j(m)
}
struct j<u> : r {
func j(j: j.n) {
}
}
enum q<v> {   let k: v
let u: v.l
}
protocol y {
o= p>(r: m<v>)
}
struct D : y {
s p = Int
func y<v k r {
s m
}
class y<D> {
w <r:
func j<v x: v) {
x.k()
}
func x(j: Int = a) {
}
let k = x
func j(d: h) -> <k>(() -> k) -> h {
return { n n "\(}
c i<k : i> {
}
c i: i {
}
c e : l {
}
f = e
protocol m : o h = h
}
}
class p {
u _ = q() {
}
}
u l = r
u s: k -> k = {
n $h: m.j) {
}
}
o l() {
({})
}
struct m<t> {
let p: [(t, () -> ())] = []
}
protocol p : p {
}
protocol m {
o u() -> String
}
class j {
o m() -> String {
}
}
i c {
class func f()
}
class d: c{  class func f {}
struct d<c : f,f where g.i == c.i>
protocol b {
class func e()
}
struct c {
var d: b.Type
func e() {
d.e()
}
}
func c<b:c
)
f

