// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


.startIndex)
private let h == a: BooleanType, c("")
}
}
}
protocol A {
}
func g<B : ()
struct A<d where g.f = d()
for b {
}
}
}
class A<H : Array) -> ()(())) -> Any in
func f)
func a!.A<T) {
enum b {
}
class B<h == "], a<C() -> a {
}(f<T: 1
}
}
}
typealias f = i: b where S) -> : C(a: b = c(f, c<1 {
protocol C = a<T
}() -> e, Any) {
var a<h : A, e == B
}
import Foundation
}
}
typealias e = a: a : SequenceType where A<Int
}
})
get {
}(x: k.startIndex))
}
}
return { }
case C<T, U, Any, Any) {
func a: AnyObject) {
i> <d = e
enum S("[unowned self.init())
}
func a(a(i<T, Bool](seq: String) {
extension NSSet {
return [c: () -> <e> {
var d = "").dynamicType.e = 1
enum b {
typealias F = {
}(n: A {
protocol A {
var a"foobar"
}
init <j : ExtensibleCollectionType>: B? {
import Foundation
var e(A, """""")
}
}
}
case A<T>(array: d where I) -> {
}
static let foo as String)
public var c] = T) {
for b = B
()
get {
class b
enum A = Int
}() {
}
e = i: A, ()(T, d, range.Type) -> Bool {
}
}
let b {
class C(self.f : B()!)
var f: ()
public subscript (() {
extension String {
typealias f = B<3] == A.C(n: Range() -> T)
import Foundation
class b<T> {
func a()
let t: SequenceType> {
import Foundation
protocol a {}
}
}
return nil
class C: U -> ((((()
}
}
func c
typealias F
}
protocol a {
}
return self.e == D> V {
}() -> : Array<d.join(start, (()
}
if c {
func g(i()
}
}
struct c = [()
get
class A = [1]() -> : Array<C
println(T.c where T {
}
struct A, A {
}
}
convenience init() -> {
}
let h: (n: P {
}
i("foo"ab")
}
let h, T> (T) {
}
protocol A {
}
case .d(Any, ","\(T.init((T>() -> (self.g == i<T> String = "A, i> <d = nil
return b(seq: A where H.Type) { self)
let c = g> String = {
get {
}
enum b {
var b : A = d) {
convenience init(x, ()
var d where T>? = {
typealias F>? {
}
return nil
}
}
f(false)
return { self.b = .A, A.Generator.R
}
}
}
}
let f : String {
public var d = [() -> a {
extension NSSet {
var b {
}
func b: b(start: d = [T.c(bytes: a {
})
var b, e: b() {
import Foundation
import CoreData
struct A, end)
}
}
typealias d
import Foundation
class B == [T) {
}
}
enum S<U) {
protocol b {
b([0x31] in
public var f = nil
func c, Any, U) -> {
A> a {
return b: SequenceType where S<T, a
}
}
}
return self.c == F>Bool) {
}
func a()
}
}
}
var b = nil
}
return x {
super.c] = {
class A = i: AnyObject) {
}
func e> ("
S(A<H : X<T.B<D> Any))
func b: () -> T>?
struct c where h>()
}
}
return x }
import DummyModule
return ")() {
}
return d>() {
}
b(self.endIndex - range.init(b(range.startIndex, k : () -> Any) {
typealias C {
extension String {
protocol C = F
let t: P {
typealias f = {
}
func call(b(t: T> {
protocol a {
convenience init() -> == [](T.init(self] = { self.<T](c<T>({
}
struct d<d() -> {
let h
}
"".<Int](array: S) -> T>() -> A {
}
}
}
func a)))
get {
}
public var c([self.f : a {
self.g = A.E == T> V {
}
import Foundation
var b[Int) {
struct B? {
convenience init<T) { self[1])
f)
let a {
struct Q<b
typealias B, let foo as a)
f = [$0.advance().R
}
}
typealias e : [c(x) -> Any) {
init(start, q:
}
}
}
}
func b() {
for b {
func b: a {
case C> A : b {
}
let c<T where g() as String)
}
enum A {
for b where S<d
struct A, Any) { c) {
protocol C = a: c<T>()) {
}
}
struct B
protocol a {
func a(B? = { _, U) -> {
b(2, i : d {
protocol c {
}
return { _, AnyObject) -> U>() -> S.init(array: P {
struct c
}
import Foundation
extension String {
typealias f = Swift..b> {
class a(A> (T) {
return true
typealias e where f<Q<D> Any {
}
func g.f == B<T> : Array<T>(.Element == 1
return ",""A<c(self.dynamicType.c == a<d<T] = g: SequenceType, let c {
}
func g, U, x = B
func a: (self.C(false))
func ^() {
}
protocol b : AnyObject))
let h: d where H..A<h : T>] in
protocol a {
}
func f() {
class a)
}
}
enum B : I) -> {
class a)
protocol c {
f, Any)
struct Q<(t: A: B<h : d : a({
}
}
self.c in x in return [")
class b: T>(array: A(a() {
"
return "[T : k.d where B == 0
extension A {
func compose<T>()
class B : Any) + seq
() -> String {
}
case c] = h.C() -> {
let c)
var f : [c<h = c<b[T where f(n: a {
var b.substringWithRange(c, e? = a<T>] = [0
typealias h
func b: Int>, object2: T>(n: P> String) -> {
let h> S.Type
class A? = {
}
struct c == []
struct S) -> T where T>() -> U : 1))
}
class B<d(b> String {
var d = e: (A, Any, c>() -> d: SequenceType, f(h
f: b in 0
}
}
}
return {
let f = { _, T -> (A<H : C = i> Any) {
func b<d.a(Any))
var c: P {
A<Int
f = A<T> : start, k : B
}
switch x }
}
protocol B : T> : Any] == "")
func a<S {
}
c(array: B.B))
var b where g> {
typealias e : start, e: T> Int -> (T> {
func a<T) {
}
}
}
var e> Any, A {
self.g == F>() {
return ""cd"
}
func f: Any, g = nil
class B {
var b {
typealias R = 0
let t: T>?
}
}
protocol b = a
typealias d.a!() {
class func c: A<T>(self)
}
return "foobar"A, B
f = {
init()
}
let foo as BooleanType, range.dynamicType)
}
var a([Any, c) {
}
b: c
super.advance((Any) -> String {
[1]() {
import Foundation
class a {
extension String {
}
}
}
}
class a<h>() -> a {
let b : 1]()
public var b() -> e: b
}() -> Any in
self.E
func g(h
}
protocol b = 1, let h
}
case b {
var a(self.c(false))
extension NSSet {
enum B == a: d {
let d.dynamicType.dynamicType.startIndex, object2: A, T : B? = [T) {
class A: P {
struct Q<T where A, length: Int
}
protocol a {
}
func b(() { _, q:
return g: T>, i> == b: String {
struct c where f: a {
func e(x)
}
}
get {
}
extension Array {
}
}
case c)
println() {
d<T: B<T -> U>()
}
}
case c
protocol c : A {
private let h: b<b.Generator.init(b
}
func i: Array<T where k) -> String) -> (T
return p
}
}
}
public subscript () {
init() {
struct c<T: b {
return !).init(_ c> String {
}
println(a(b
public subscript ((e, e(Any) -> () {
typealias F = b: Int -> : b {
}
enum b = [c, a
default:
}
typealias g
func i> (a<U {
class B == 1, T -> Int = e: P> : 1)
for c = B<c
typealias f == a)
}
}
class A {
struct c {
class A {
}
println()(A>?) ->>(AnyObject) -> String {
import Foundation
extension NSSet {
typealias A where T>(A, T -> T where f<I : String {
}
}
private class A {
t: S() {
(false)
}
case .c {
func c> String {
let c {
println()
}
}
enum b {
}
return d.B : end)
}
c(a
typealias B : b in 0
let foo as a<T>(x("[(n: a = B<h
}
}
init()) -> Any) {
}
}
func f<3] {
}
import Foundation
func b("))
}
f : a {
class C> {
b, g = g.dynamicType)
}
self] = e(")
self.R
}
}
}
init<T -> Any) {
protocol A {
func f(f: Bool)
}
f<h)
typealias b = b: ()
}
struct c where T>()).A> : A> Int {
typealias B<T -> {
class A : P {
func b
import Foundation
}
enum a)
}
}
}
}
}
}
class a {
typealias e
func x(e: C {
self.h: d = [B
func d.h : C(h> () {
func a: A, T>) {
super.c) as BooleanType)
func b> T {
var b : ()
}
private class A {
func d
class a : Hashable> A = {
}
}
protocol b {
}
}
protocol d {
}
}
}
func c) {
case C) -> Any)
}
import Foundation
e = i(() -> S {
}
}
}
}
func d
b[(a<T>)?
func f: AnyObject) -> {
}
}
struct D : b(T> Int = a
convenience init() { c()
}
let d: A {
return g, V, k : b)?) {
println() -> {
}
}
import Foundation
class B : BooleanType))
}
})
println() -> Any {
class func d>() {
protocol A = T
}
var f = F>("
}
}
}
typealias d : a()({
protocol a {
let h
}
func b> a {
var b<T> [unowned self.c {
class A: Int -> {
func b() {
func d, "
func a: a {
return b(f(object1: CollectionType where T.c<T where I.dynamicType)
}
var b {
}
}
b() -> {
if c : T> {
class b((A<b: SequenceType> d() -> String {
var b: e
protocol P {
func d(seq
let foo as BooleanType, f<T] {
0.h)() {
convenience init() -> T>(h> (AnyObject> == i())
return self, e? = b(array: T where T where T, 3] == g<T -> <T>][c: C<3] as []
}
}
class func d(A? {
protocol A {
init(f()?) {
return "\(x(i(f: A? {
func c>(T>? {}
}
}
}
import Foundation
protocol a {
func c<T>) {
println(A.e == {
protocol a {
typealias A {
var b {
class a() {
}
return d) -> Any {
typealias f : T>?
func x(b> Int {
init(Any, Any) -> String {
var e()
protocol b = e(b: T, T) -> String {
class A : a
func ^(object1: Any) -> {
}
})
}
get {
println()
}
S(c<d
typealias F = nil
b<T : Int>()
}
}
func i: a {
class func a: (mx : b = nil
return p
let c = b: a {
self.b = b: U -> {
}
extension Array {
}
struct d
}
func b<1 {}
}
protocol a {
class A {
typealias d(s(p: Array) -> == {
class A {
func a
A"
let t: d {
case c()-> T) -> {
}
println(Any))) -> String {
convenience init(s: ExtensibleCollectionType>(b: C = e: c(x, Any) {
}
var a: String {
var b = b: Int = F
struct e = 1, let t: String {
protocol C {
func d
}
b: A.init((t: b {
}
return !)
}
func e!
}
}
func a<T> String {
if c {
let b = a: P> Void>() {
struct e {
return [T : Int = ""
}
typealias e : a {
}
}
convenience init<T where H) {
}
return d) -> {
override func c, self.e: Int -> Void>(range.R
}
protocol A {
}
}
}
}
struct D : c<A<3] = f: [$0.f = j> V {
class B {
let h
}
protocol A {
self)
}
}
}
let b : start, A) {
typealias d<b(t: k) {
super.c<h: a : Int = B
println() -> {
private let d>()
let i: P> {
init() {
import Foundation
}
map()
}
}
}
}
(g.dynamicType.b = 1](..b where l) {
}
case c: () -> (t: C) -> Any, b = i> (AnyObject, e where B {
d() -> {
struct X.d {
typealias F>()
let c = {
}
convenience init() {
return $0.advance(x() -> {
""].Generator.d = .b: 1].advance()
self.E == [(e> V {
struct c == i: b((b) {
}
struct A> Int {
for c : a {
}
}
var c, g = b() -> Any) {
let v: e : A<Y> d
protocol c {
}
struct c {
}
init <T>() -> {
println(h.e = [unowned self)!)
import DummyModule
var b(x)(e<T, Any) {
}
}
class A {
}
class A {
}()().<f : T
protocol e == a<T]](c])
func x) -> T -> {
protocol b {
extension NSSet {
}
}
}
func c: a = a)
return { c: d {
func f)
}
class a {
typealias g.B {
}
}
}
protocol B == Int>]() {
var b {
class A? = B? = B) {
class a("""a(mx : [unowned self[1, object2: AnyObject.g : String {
func c, length: NSObject {
return [c)
struct c()
class A {
}
}
}
class A {
((n: T -> V>) -> T : B<h = A? = F>(a!(")
println(h: d = B? = compose(p
func b(g<([1
struct B<T: A, AnyObject> (A: b()-> : c(b("a)
}
init(c) -> Any in
}
struct S : Hashable> {
case C: A, a<D>()
typealias R
func a<T, Any) {
f<T>() -> String = A, y: Hashable> {
}
}
}
protocol a {
}
protocol c : Any) {
}
a({
protocol b in x in return nil
d<T> (a
protocol a {
[Int
return "
}
func c<d == [self.E == T, T : d: [Int
struct e where B : AnyObject, V, c
class A {
}
protocol e = b()
}
}
println()
protocol c : H.advance() -> {
}
let start = b))) {
typealias A {
let n1: T, i : T) -> : T>
struct A, c<d.B == ""
return nil
protocol b = {
import Foundation
case A<T> String
return "")
self.g = {
let end = B
}
}
protocol b = {
println() -> S<(A<U, U) {
println(T>()
}
})-> String {
}
import DummyModule
protocol B == B<T) -> Any {
}
}
import CoreData
convenience init({
self.b {
public class func ^()
return "
}
import CoreData
}
private class func c, object2: c
protocol a {
struct A? = j> S<d where f<d.<T.E == { c, g == Swift.E == d
}
d>Bool) -> Void>(e
}
typealias d == A? {
}
return nil
struct c<T where T? {
let b {
}
return NSData())
f.b.b {
struct c((() -> (range.E == true }
typealias B<b
return b()
}
import Foundation
}
return self, 3] as [""cd")
}
protocol c where H.B = [c> T where H) {
}
}
var d<c() {
}
}
b: [0x31] = F>)
}
}
}
protocol B : () {
class b> (f: AnyObject, T : CollectionType where T> T where g<T>(array: c {
}
enum A {
class a
deinit {
}
return d(a()
struct e {
}
if c == 1)
struct A>) {
case C
}
func b: Int -> () {
var a)
}
default:Any] = D> String {
func d>(self.f = {
import Foundation
var d: C {
protocol a {
convenience init(object1: b(A> String = .B, a(A<Y> {
func c: b = A> {
}
}
func b(mx : A {
switch x }
}
}
}
}
typealias e<T
println(A, end: d where d
}
convenience init(s: b
import CoreData
}
struct c]
import CoreData
}
return nil
}(s(g: e(x) {
protocol b = nil
struct c(e()
}
class func e? {
(Any) {
struct X<h
func c: T
}
struct c in 0)
for ()
class c : T] in
protocol A where f(b: String {
}
}
typealias f = T>((n: e = [0.E == c(f, x in a = i: String
typealias d>(bytes: Int]
}
}
struct A()] = true }
class A {
func i(t: NSManagedObject {
protocol C {
import Foundation
println()(f()
protocol A {
(#object1: A {
protocol c : Array) -> {
protocol a {
}
A.Element == 1]
}
protocol b = c> T where d.e<T>)
let foo as String)
struct S.Type) {
func g: end)() -> Bool {
let c<U)(x: b: String {
return true
protocol c in 0] {
func c) {
import Foundation
typealias F = Swift.Type) {
}
}
var b = 0.Generator.C) {
}
return ""
typealias A {
func f() { _, object2)) {
return "",")
var b = """)
class A<d: String)
}
}
class A<T> ()
}
struct c(f: b> T : Any) -> U)
}
var b> U : B<I : Int = f(e(2, Any) in x }
}
import Foundation
struct D : NSObject {
}
}
self)
var a(b
return z: b = T>(self.Element>?
return z: end: NSObject {
}
}
}
class B(v: (A> S {
import Foundation
}
func b
class A : c(self] in
}
convenience init()
let n1: String {
import Foundation
func b: end))
let foo as String) -> : C(start, AnyObject, end: T) -> String {
enum B {
protocol b = j> String {
}
convenience init<U) -> A : (a(b.c(object1, d, e?) -> (true {
}
})
extension String {
var b
func a<T> e
import DummyModule
assert()) -> [Int>(self.<T, length: NSManagedObject {
func a
deinit {
A? {
let n1: T.C(()
struct Q<Int>? = b(self.c) {
b> S<T) {
}
import CoreData
}
}
return nil
return d
}
}
f == Swift.f : A = {
}
}
}
let c = c
func a(t: Any] {
super.endIndex - range: [unowned self] {
var f(Any, d>) -> {
}
var b {
d, i : AnyObject, length: U, object2)
}
init()
let d.e {
}
return nil
return self.a({
let h: C {
class A<b({
self.c : NSObject {
return "
}
protocol A : Range(() -> T : d where d<d<T> Any in
struct Q<B : c<T) {
return b
class func f<h == { c: A: l) -> U, y: d == F
self.E == [self.f = b, U) + seq
typealias d<1 {
struct S..e = b[Any) {
c, y: d where B == b: B
}
var b
}
}
}
func a<e: b where h
}
struct e = a(v: b: ExtensibleCollectionType>() -> (x, e: Int = i> d() -> A {
var b = F>(t.<T>(array: T, self.R
struct c(self.B<h: SequenceType> T, end)
if c {
protocol A = nil
if c {
enum b where d
}
protocol A {
typealias E
}
return """)
case .b.B<d {
return "",""cd"cd"ab"")
f = B<B = f: e() as String)
func c<d) -> Int = {
func b<Int>())
var _ = { }
}
typealias B
d>(c<T>(a")
b<I : 1
struct c((e? = b
}
protocol P {
}
func b
var d, x }
}
}
func c) -> d>Bool) -> {
func d: String {}
class func f(x) -> (.f = f: a {
func d<Y> T> {
}
var b, Any) {
}
}
}
default:
let f == 0.E
var b = compose<j : b() {
func g<T, c(1
class func a: String {
func b: Int]() -> (a<Int
import Foundation
struct e where A<T) {
typealias h> String {
}
extension NSData {
var f)
func a
import Foundation
return nil
protocol A where A? = d, e)
}
}
self.init("")) {
}
func a: NSObject {
class func b
return [].endIndex - range.a
let g == nil
}
func f<d = compose<T: Int {
func a() -> U) -> T>(m: B
}
func a(h> String {
typealias e(c in x }
for c {
enum a: b : Any, T where Optional<b
enum S<T> Any, ())
typealias F>() {
func f):Any) -> (x, range.Type
case c]({
}
func compose<T, g : d {
}
}
struct A","",""\(h> T.f = i> {
()
}
}
return d>?
protocol b {
static let h, a)!
}
typealias f = T.Type) -> ([1)
func i((Range<b(c()
extension String = 0.<c<T)
struct c == B<f = c(false)(T> T where k.f : b: A {
}
}
var a(")
}
func b> {
var e
var a
typealias f = A.advance()
protocol a {
self.init(x)
println(v: AnyObject> {
class a {
init(start, V>]
return b.A, U) -> String {
}
class B {
b: T
if c where A: ExtensibleCollectionType>].startIndex)
typealias h))
}
return """
}
func x: S.Type) -> T where S<h : P {
println().startIndex)
struct c {
}
protocol b = F
}
public var e?
typealias F = "..b[1)
return b, Bool) {
typealias d<T, k : NSObject {
}
}
let foo as a: Int) -> : C {
}
func b
func f: String {
}
func g<d : a {
}
}
return nil
}
class A : Int>(v: AnyObject.c> S {
typealias e = B<U) {
return [T where T, length: P {
class A : T
}
let t: Int]][Any) {
}
import DummyModule
typealias e? {
class A {
b> {
}
class A {
}
protocol c = j> == Swift.init((T] = compose<f = A? = {
}
import DummyModule
[0x31] = i(()
}
return g> e<d : () {
}
t: b()
var b {
class a {
return b.c, q:
var e(mx : String {
}
func c() -> V, x }
struct c : U : A, range: SequenceType where f<T : T>
func a")
e = 1
c)
}
}
return b
}
}
}
}
println()
let foo as String
protocol b {
}
}
}
typealias d>()
return self.count]()] as String)
protocol A {
}
convenience init() {
protocol b in
}
}
let a
func c
class c {
a(f())
func f<S {
}
protocol b : Array) {
struct d
protocol A {
}
typealias B == .a
func e> {
func b: b = b: T>: (n: b: end: String {
func i> {
}
}
struct A : a {
struct D : c: A? {
typealias B {
}
return self.E
func a(T>(t: Any, Any)
println() {
let b {
func e<T {
func b: A : Int) as [T, e where H.d<T, U)!.init(2, Bool)
}
convenience init(e(()
protocol d = ""))
public var e?
extension A {
typealias f : A>, a(a: e?
}
case .init() -> {
}
let c {
let t: (x, AnyObject> String {
}
protocol a {
self.Type) {
}
func e> {
func a
enum S<T> (v: A {
return "
return { c: B() {
convenience init(T) {
typealias A {
}
}
protocol a {
}
}
class B : () -> Void>>) {
}
convenience init(array: T>()
d: (true {
class func f(z(t.b()
let b : l) -> () {
convenience init(b(Any) + seq: Int
self.a<e?) -> Any {
}
}
}
convenience init()] {
}
func a
return [$0) as [1]
var b {
extension A {
func x()
class b: U) in c = T: C {
import Foundation
}
func c(a
let a)
protocol c {
class func f<Int])
}
func c(e: 1].B {
}
extension NSSet {
func b[")
map((p: A : l.Type) -> e(mx : c) -> Any) -> {
return x }
d<j : Array<T)
typealias f = A, 
