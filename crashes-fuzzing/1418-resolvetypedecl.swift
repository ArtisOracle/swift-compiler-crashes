// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
}
struct c<T where T : A<T>)
}
typealias B == "[$0
if true {
}).startIndex):Any) {
}
protocol A {
}
class C(start: d where I) -> Int = a: ExtensibleCollectionType>("A<f = {
enum a()
}
}
class A"cd")) {
}
protocol a {
func d(""""
func a<I : A<c> String = j> Any in
assert(x() -> String {
}()
case c, U, i: [T, x in a {
class c {
protocol a {
class a {
typealias e {
}
}
enum a(Any] = c(a() {
var e: a: Any, let i> ((t: b {
}
func i> : B)
extension NSSet {
}
}
}
extension NSSet {
}
}
}
}
}
}
}
())() -> Void>, let v: [0x31] in
class b
class B = A, T where l) {
[1)()
struct e : T? = A> : a {
func c)(x) {
}
func a(b.Type) -> T -> T
typealias d.B : I.Generator.d>
func f<B : A(2, ()) {
class a {
}
func b() {
func d<d : S<U : A<d, let f = j> String {
typealias d {
init(A, Any)
}
func a: Array) {
}
import Foundation
}
protocol b {
}
func b.init(s(bytes: T, Any, Any, b : A: S.count]("ab"
typealias B == B>) {
let c {
}
}
}
typealias R = { c())(2, k : BooleanType, e: ()
func b> String {
return $0
extension NSData {
protocol A {
func b<h = F>()) {
}
self)
}
convenience init() -> Int = Int>(Any) {
import Foundation
}
return self.init(2, "")
typealias F>) {
struct e = Int>)
protocol a {
var b = B([0x31] = a<j : H) {
case c> A {
extension A {
}
b.init(a(T
var b(i<T> () {
typealias d : T] as a(s(true }
}
protocol a {
0.g == e, range.B == g<T>(x() -> {
class A<T> T> () -> {
enum S(h.init(a
}
var b: B<j : T>() as String)
}
}
struct c {
}
}
return [].Type
}
}
class a<I : U : 1
var d where T) {
protocol b {
return NSData(h> {
init<T
}
f = a<T : P {
return nil
typealias b : [self.d where k.init(i: a {
}
}
let c()
return b> Void>) -> {
for c = b> String {
func f(g<d()
struct A<T: start: $0.A> {
return x }
struct D : d = {
func a()) {
typealias A {
func a(self, AnyObject, length: b(f() {
}
extension NSSet {
var b in a {
}
}
import Foundation
func a
for () -> U, A<Q<e: e() -> S : T: l) {
func a
}
}
}
var d where d>(AnyObject.Type) {
}
func b()
}
override init<Int
}
}
typealias e = i> {
return {
f<f = [$0)
}
protocol c == F>() ->(f<Y> ("ab"")
class A<T! 
