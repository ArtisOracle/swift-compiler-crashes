// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


as
protocol c {
typealias b
:c.b
__COLUMN__
b
protocol d : b { func b
func d(e:  = { (g: h, f: h -> h) -> h in
return f(g)
}
in
func d<l>() -> l -> l {
return { e in o {
q>)
}
i c : m {
j f = h
func o<l p l.r == f>(d: k
}
enum n : String {
case b(
return
struct d<f : e, g: e where g.h == f.h> {
}
protocol e {
typealias h
}
is
func f<g>() -> (g, g -> g) -> g {
e e: ((g, g -> g) -> g)!
j e
}
protocol e {
d func j()
protocol d : b { func b
none
func b<e>(e : e) -> c { e
default
var x1 = 1
var f1: Int -> Int = {
return $0
}
let suc where T.E == F>(f: B<T>)
}
snit(foo: T) {
self.foo = foo
super.init()
}
}
pro
func b((Any,a: (Any) -> <T>(() -> T) -> Sunc b(las
func a(x
}
set
}
func a<g>() -> (g, g -> g) -> g {
var b: ((g, g -> g) -> g)!
return b
}
func f<g : d {
return !(a)
enum g {
func g
var _ = g
in
protocol A {
typealias E
}
struct B<T : A> {
let h: T
let i: T.E
}
protocol C {
typealias F
func g<T where T.E == F>(f: B<T>)
}
struct D : C {
typealias F = Int
func g<T where T.E == F>(f: B<T>) {
}
}
in
class j {
func y((Any, j))(v: (Any, AnyObject)) {
y(v)
}
}
func w(j: () -> ()) {
}
class v {
l _ = w() {
}
}
({})
func v<x>() -> (x, x -> x) -> x {
l y j s<q : l, y: l m y.n == q.n> {
}
o l {
u n
}
y q<x> {
s w(x, () -> ())
}
o n {
func j()  p
}
class r {
func s() -> p {
t ""
}
}
class w: r, n {
k v: ))] = []
}
class n<x : n>
static
struct j<l : o> {
k b: l
}
func a<l>() -> [j<l>] {
return []
}
f
k)
func f<l>() -> (l, l -> l) -> l {
l j l.n = {
}
{
l) {
n  }
}
protocol f {
class func n()
}
class l: f{  class func n {}
func a<i>() {
b b {
l j
}
}
class a<f : b, l : b m f.l == l> {
}
protocol b {
typealias l
typealias k
}
struct j<n : b> : b {
typealias l = n
typealias k = a<j<n>, l>
}
public
func j<s>() -> (s, s -> s) -> s {
d h d.n = {
}
{
s) j>: NSObject {
var h: j
g -> k = l $n
}
b f:  _ = j() {
}
}
func k<g {
enum k {
func l
var _ = l
in
func d<e>() -> (e, e -> e) -> e {
e b e.c = {}
{
e)
{
}
}
protocol d {
class func c()
}
class e: d {
class func c
fallthrough
func c<d>() -> [c{    enum b {
case
else
func C<D, E: A where D.C == E> {
}
func prefix(with: String) -> <T>(() -> T) -> String {
{ g in "\(withing
}
clasnintln(some(xs))
nonmutating
class k {
func l((Any, k))(m }
}
func j<f: l: e -> e = {
{
l) {
m  }
}
protocol k {
class func j()
}
class e: k{  class func j
let
import Foundation
class A {
class func a() -> String {
return ""
}
class func b() {
struct c {
static let d: String = {
return self.a()
}()
}
}
}
precedence
let d{

protocol c
