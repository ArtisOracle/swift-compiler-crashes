// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


func a()
import Foundation
}
convenience init()
}
}
func compose<T -> T where H.Type) {
let c {
var f: String = c()
}
func g<T where A? = nil
protocol a {
import Foundation
typealias R = b(g: U : Int = {
struct S {
struct B? = T! {
}
let f = f: e where T>(f: P {
func a
protocol P {
func a(f, e: e)
func f, AnyObject, g<T> Int = f))
return b(b> V, f<T) {
return self.B<T -> ()
init<T>() {
return d
struct e == e: T) {
}
protocol c = nil
}
}
init<T) {
}
class B? = c, AnyObject) {
init <T.c = T.init(f(n: d = {
}
}
let a {
let i: AnyObject, AnyObject) -> [T! {
}
}
let h = b> {
c(self.E == {
}
}
let h> T -> U)
self.h
func g, AnyObject, object2)
case b = D> {
var b : d = F>()
}
func f)
extension NSSet {
var d {
class A {
}
var c(b.E
}
}
super.d.b = f.E == .E == 0) ->() {
func call(array: Int {
enum S(T>: P {
}
return { x }
e == T) -> S()
let g = a
func g.c: B<T>)
func f: C> Int = a(T>() {
self.e where H.E == {
struct c = c: T>(c: B) -> [B) -> T
}
}
func a() -> V {
struct c = b.dynamicType)
var e: T>]() -> T where A(self)"
init() {
}
}
protocol e == T>("")
typealias F = {
return self.b in
init <T>(x)(self.e where H) ->(false)
func b: B(g<D> T {
struct e {
}
}
}
struct c ==
