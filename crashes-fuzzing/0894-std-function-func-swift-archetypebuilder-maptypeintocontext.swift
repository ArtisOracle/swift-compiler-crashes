// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


{
func d: 1, Any, b = nil
}
func d<T.B() {
class A : b: AnyObject, k : c {
}
func g<B : C = [c)
}
f = b((T) {
}
}
func g: AnyObject) {
func c) {
func i(t.b {
self.f : b() -> Any).B<T>()
class A {
typealias e: NSManagedObject {
var f<Q<D> T where S(self.R
func c] in
c: b(self.f == { x }
override init(i> {
init() {
}
class a : a {
class C(.Type
}
}
let foo as String
}
println(h: a {
convenience init(bytes: 1], q:
protocol a {
init<f = .startIndex)
d) {
return d.d) -> {
}
protocol a {
println(g<T) -> ((n: c : end)
func call((b<T>(self.d : Array<T, i<T where f<U : String = c<b)-> U.c where S<T.e == j> : 1)
case s: A, "
println(2, a<Q<T : a {
func g.b = B
protocol c = i: $0] == F
0.e = 1]((bytes: b())
extension String = a: a {
protocol C {
}
}
}
let d: c
return m(()
f(start, end)
A, AnyObject> {
func i> Any, x {
return nil
enum a<T][1, Any)
}
}
}
for () -> (t: P {
}
func a: SequenceType, 3] == 0.d where g
return [1
}
}
protocol b = 0.E == nil
class func i(a: (x) -> {
var c: b: $0.Type
}
}
class C(n: BooleanType>) as String)
import Foundation
}
}
func a() -> {
self))] = g
func a<I : P> {
class func e() {
var e(Any, d.Type) {
let h
private class func g<T> (start, 3] = {
A> T>() -> {
return nil
func f(A, T where S<S {
case s: AnyObject) -> (2, a(self.Type) -> {
enum S<T, U, Any, A<T: d = A.A, d
}
default:
class d>)
}
func b: (a<d {
typealias E
let c
}
struct c: T, let foo as String) -> U) {
}
typealias A {
}
struct c {
typealias B.startIndex)
public subscript () -> <T -> Any) {
}
func d>(c {
}
func f: C(b, g.count]() -> [1
}
protocol A {
let f = compose(c()
typealias h)
protocol a {
println()
protocol A {
}
struct d(self.c: S) {
return { self.c {
private let a({
i(g<C()
}
return x in 0.Element == {
protocol a : A<T>) {
return NSData(v: SequenceType> a {
}
S<T where l.init() -> : CollectionType where Optional<T> ())
extension A {
}
}
enum A : Int = {
enum a: A, U.a<h = B<T, A {
protocol a {
private let c) + seq
}
}
S) -> {
self.Element == [T>(v: A<T -> {
""")!)
return ")
func i<T) {
class b: A {
return { self.Element == []
protocol b {
var b[T>([c: ()
protocol P {
}
case A>(h>>>]
protocol B == b: b: T -> {
class a<T>?) -> : b where B {
protocol d = compose()
}
convenience init(f.count])
func b> Any, e(")
}
self] = {
class func b: 1])) {
func f<C> T where T where S<T, c
}
}
protocol d where h):Any, V, g : B<T> String {
}
var d
func f<A<b)
}
d>() {
return m(m(Any) -> Any) -> U)
f: Array) -> Any)
self.init<d: A, a<T, e, e == c<T {
}
b
struct c {
typealias d: A, g, b = .init(c):
import Foundation
protocol c == D> {
}
}
func b<c(n: Array) {
}
"\() -> {
func d<T where k.e = e?
}
extension NSSet {
}
return d
}
