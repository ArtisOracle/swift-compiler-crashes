// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


c = a()
class A : NSObject {
}
init()?
class A {
}
class A {
}
}
return [T>()
}
}
}
let g = compose<T>("
}
typealias e where g: A: T](f: T) -> T
}
}
func compose(c, object2: $0
}
case b = {
}
}
func g: AnyObject) {
println(f, e)?
let d: T>()(x: NSObject {
self] in
}
}
class A {
}
var d where T.e : e where A"
d
func b
convenience init()
}
func a(g: d = compose<()
d
if true {
func g.e == e: d = 0) -> [B<I : $0
struct Q<(self.c = { x }
class func compose<U -> T : T>(x)
}
}
func g: Int
self)"A> T](t: A.c {
}
class A {
struct e {
func f.E == [B(self.c(f)
func a()
}
func b
}
let i: U -> Self {
class A {
return nil
protocol A : (T>]() ->(g<T>(array: d = b.c == a
}
struct c {
struct d<C) {
let t: AnyObject, V, object2: String = {
}
println(b(#object1, object2: B<T>()
0))")
class A where A? {
0) -> T : C) -> Self {
typealias e = nil
}
}
var e!.a(x)(AnyObject, b in a = A"")(f()
}
super.B<T](false)(f)
typealias R = {
f = A> String {
}
protocol A : c: c) {
class func g<T: Int -> T.B<T>](v: NSManagedObject {
func call(x)
}
convenience init(#object1, f: C<T>(x)
let g = {
extension NSSet {
protocol P {
let g = b> (x: A>() -> T : T>(#object1, e!.dynamicType)
var d where T
typealias R = {
protocol d where T>()
let g = {
func b: U.d.e = F>) {
e == [B
}
}
func a(object1: String = f.e = b: T>? {
protocol e == {
}
let d<T
typealias R = T>: T) -> [T.Type) {
}
let v: e where A.a
}
protocol b = 1
}
assert(object1, g: U : e where T>()
func a(b: A> Int = Int
assert(false)
typealias E
class d.init() {
var e: C {
typealias R = nil
}
protocol P {
}
deinit {
deinit {
import Foundation
}
var d = ")?
func a(array: U ->()
enum S<T where g: I) {
enum S<U : C<T>(e, g(
