// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

class A : NSManagedObject {
t.C
class func b<T: b = g() -> {
func a(object1: $0
assert(array: a : a {
}
}
protocol A {
import DummyModule
}
}
}
var f = c<c) {
var b> T.h..Type) -> : String = 0
return x }
import Foundation
struct B<T! {
class B : A {
enum S) {
struct A, e> : (s(s(a() {
assert().d: a {
class a {
class a {
func a()
}
}
}
class A {
typealias e(Any, 3] = B, let c(A: end)
var d = [c: 1, Any) {
}
return x }
enum B {
case b {
}
}
let b = A, let i: Int](c: A {
func g
func f: A {
}
extension NSData {
}
protocol A {
return S) {
func g<T : String = true {
(c : U -> () -> {
struct e {
func x: (i: X.advance(t: AnyObject, Any) {
let v: String {
}
import Foundation
return ")
func i: ExtensibleCollectionType>]
}
private class B : d where T! {
func c>>]..Generator.init() {
class a(f(mx : l) {
class d>())
}
enum A {
return {
let f = true }
super.h : A : (start: X.count]
}
}
case b {
}
import Foundation
override init() {
var d = B<T>(g<T) -> T where H) ->(b<h: A<B : AnyObject, T
let foo as String
f: c<T
}
import Foundation
return x in 0
}
self] in
return !.c {
}
return S<f == b()
extension A {
}
A<B : T) in x {
(x) {
func d.startIndex)
struct D : [c: d = d
func e() -> Any, range.<T>) {
class func f<c: $0
}
}
func f() -> {
extension NSData {
struct Q<T) -> (a<b))
if true {
}
}
struct Q<T where T, c)
return ""foobar"[])
class A, Bool]() {
struct c<1 {
return [1)
}
import Foundation
case c() {
")
case .b: SequenceType> ((p
class A = 0)
protocol A where Optional<T>(t: I) {
}
private class A, V, T>((()) {
var b
}
}
}
import DummyModule
}
return { }
}
let foo as a)] = {
return NSData()] {
static let h)
func g> {
}
f = {
}
import Foundation
}
get {
protocol P {
enum b where l.R
import Foundation
init(a() -> T, d.endIndex - range.B)
return b: b(array: e : NSObject {
}
}
if true {
typealias A {
}()
}
func b> Int {
}
a(.Generator.B
}
}
}
func g<c]
}
struct c : Array) -> {
}
struct D : A) -> {
}
enum a
}
}
}
self.init((v: AnyObject) {
let f = b
println(B, T : d : T>>()
}
class A {
enum a("], g = [unowned self.d
}
let a {
}
func g
class B : l.c {
struct Q<T, g: e = a(T> d
override init(c) -> : ()
f: $0)
protocol b {
var _ = {
return {
class A {
typealias f == b)
