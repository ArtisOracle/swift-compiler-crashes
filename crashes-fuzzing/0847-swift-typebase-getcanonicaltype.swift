// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
protocol P {
import Foundation
let t: c) {
return self] in
typealias E
}
protocol A : NSObject {
return nil
}
println((g<T : B<T.d<A.B == a
}
func compose<T.init(b<T) {
protocol c {
}
let h = { c: AnyObject, V>()
func b<Q<T
func a() -> T
}
return { x in x in x in x }
typealias E
typealias F>>()
protocol d {
println("""A: (t: e = [T) -> (self.B : String = {
protocol P {
class d
extension NSSet {
protocol b in x in a {
}
func b<C<U -> {
}
return self.B : Array) -> String {
S()
func g: A>>(self] in
}
func f: NSObject {
}
}
}
}
}
var b in
}
}
protocol e {
func compose()
struct Q<T
}() -> V, U)
}
}
typealias e : e, e, U.E
if true {
}
var f : d = f: d {
var e!.e : C<D>? = "
func a()
func a
class A : C {
return { c: P {
}
class func compose(f: NSObject {
let a {
}
}
struct B<H : B<T) {
let g = A? = F>(false)
func call()
self.B : Int = a(g<f = { c(n: e == "\() -> {
if c = { c
}
protocol b {
func f<T.d
}
struct c {
init <I : A> {
class func g<c
}
class func f: T) {
}
typealias e {
println(self.init<T]() -> Self {
}
return { c: T](array: A> : U : Int -> Int = B<T -> {
protocol P {
}
typealias e = f: AnyObject.B == 0
class A : A: P {
}
class A : d where g.B : H) -> : AnyObject.a(")
var c: A.c = a(g: P {
}
}
class func f: A.dynamicType)
0)
}
}
}
struct d
}
struct c = nil
import Foundation
return true
class func b: a {
protocol P {
}
}
class C
struct S<T>) {
b
for b {
for b in
func f, g<T
var b
}
}
}
}
class A : P {
}
d

