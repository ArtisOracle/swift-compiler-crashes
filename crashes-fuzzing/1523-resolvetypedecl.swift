// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
protocol a {
class A: d = 1)
}
func e: T>((""))(i<T) {
import DummyModule
func b(true {
}
class A : A {
class A, e = B
}
var e(f(c: T) {
}
}
let d<U -> {
func e!
typealias b {
}
class d.d {
var c("))] == c(f: A = b(t: Int -> {
}
f : c(T>() {
func b
typealias E
func b: a {
class A = h> String
}
class C<I : T? = 0) -> (A<Y> {
}
}
}
}
b[0x31] = Swift.Type) + seq
typealias g
struct A.e {
class A {
}
}
class A {
self, V, object2: T))
let v: NSObject {
typealias e : NSObject {
}
}
var e!
class a)
}
let g = a() -> {
import Foundation
var b<T : Int>(a(b(b()
struct c<T>)
extension NSSet {
}
protocol a {
func b
func a
class func c<T> d
case b = T.C: X.c {
return b: Bool)
}
typealias R
}
}
protocol A {
func a() {
func i(self.d: a = i> {
public class func g: 1)
return g, AnyObject.init<f : A<T>])
return self.C) -> Any))
class a {
return nil
let n1: Bool) -> {
}
typealias d.e = 0.f : A {
}
protocol d = a: A>(Any, let t: l.Type
([""
}
}
return true
return {
}
case b {
protocol b where H) {
}
}
}
}
func b: d {
}
class A {
}
self.count]
(a: b, Any, B<T! {
}
func e!)
func b(n: P {
func b(Any)
return g: T
}
}
}
func c
struct e where T) -> V>(() {
e {
enum S) {
func d
func b, let n1: d {
}
}
return b<S {
typealias e == B
import Foundation
return $0] = Swift.d.init(t: SequenceType, range.b {
}
protocol b : H) {
func b: Int -> e(array: AnyObject> String {
d.Generator.Generator.join(Any) -> [0x31] = [Int
convenience init(c = h, g, a<T -> == nil
}
typealias R
var f = [0
return $0) -> d>: e == ")
}
}
class c : ()
a()
class d<d where k.h : NSObject {
for ("[1)
return self.a() -> A {
}
}
let f : a 
