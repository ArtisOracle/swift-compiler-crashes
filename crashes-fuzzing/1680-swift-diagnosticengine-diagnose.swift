// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

alias R
func f<Int) {
self.init(Range<d
protocol A {
}
class A> Self {
return self.Type
}
class b: e == A<S {
enum A {
}
public subscript (x: NSObject {
}
for b {
class func compose()
case s((_ c<T -> ()
}
public subscript (h
let n1: String {
case ..C<c<T : P {
var b():
let f == g
class b: S<T>(true as [c
}
func f)
}
case s()
var _ = h)] {
}
var d = {
b: b.a("))
}
["))
println(g<T> Int = { x }
}
}
let c(b: S<T {
protocol A {
case C
import DummyModule
var f)
public var d where T)
if c {
return self, Any, i : ExtensibleCollectionType>(i<U) -> {
extension String {
}
class B == { _, e<d.E == a: (a: X<U, U)
typealias f = Swift.a(2, U) {
class A {
}
}
}
func compose<d where S<d<d {
typealias b = {
func i(self.count])
import CoreData
}
}
enum A {
func g> {
func e
(t: A<T.d>((object1: b()
}
return { x = Swift.B, 3] == B) {
}
}
}
struct c {
enum S) {
}
protocol e == e> S : c) {
class A> {
}
import CoreData
struct A : A? {
self.advance(c {
}
protocol a {
}
}
}
for b where A<T) -> A where f: a {
}
}
}
protocol C {
}
protocol b {
return { c>] {
}
typealias e : d == g(x(mx : P {
}
case c, g()() {
func b(v: P {
A.d) {
case c
typealias B) -> {
}
}
"
import CoreData
class b: A: () {
enum A where H.Type
}
return {
typealias R = f<T -> T>(a: ()
var b in return """[]).startIndex))
}
}
var d where l) -> a {
typealias B
struct X.c<d.<T: A, A {
func g: P {
}
func g<b
import Foundation
class a
var b {
func b()
public subscript (m: d = [B<T) {
class A<T! {
map(")
func b() {
}
}
struc
