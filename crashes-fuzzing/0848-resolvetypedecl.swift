// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


elf.join(x)
protocol a {
println().f == Int>("ab"")
return m: AnyObject)
}
struct c<d where h: e
}
protocol A {
}
}
}
A? = a: Hashable> T) {
protocol P {
func c> {
}
println(c, g(Any))
var b() -> T where g, e {
println(s: b[self.e = [0)
}
class A {
case C
convenience init<T>((n: NSObject {
}
}
}
return S<H : c() {
class A<U -> {
b: CollectionType where k) {
typealias e == d, q:Any)
}
[0
func f: ExtensibleCollectionType>(p: T> {
class a!
func b> {
class A? {
println(n: ("[T> {
typealias F = a<() -> : c)
}
}
enum A : d = [c()
struct S) -> U) -> T>? {
protocol a {
import Foundation
class A<d {
extension NSSet {
}
var a<T! {
}
}
var d == nil
let c {
var c(f: [T> U) {
func a<T>()
}
}
}
let n1: c: U>() -> String {
class b.B {
let t.a):
}
}
class func call() -> V {
struct d: String {
}
typealias e == 1][c(T) {
protocol A {
}
protocol C {
func i> V {
}
}
}
}
[T where T
class B {
enum B {
case C: a {
typealias h
}
func f() {
typealias C {
convenience init<d where k) -> {
typealias e = h
}
func b() {
d: start, end)
}
class d.Type) {
struct c = nil
}() -> {
b[1]
var _ = D> {
e : Int -> e(AnyObject> == e> Self {
func b.e, U.b in
struct d
b.E == a<h : T, A {
return g<H : T
class a() -> U {
return { }
}
protocol a {
extension NSSet {
}
class b<({
}
default:Any, Any, V, ""
typealias A : Range<j : b
func e)
}
case ..advance(b: ()
let end = b[0x31] == a: [c> A : T
f<T, U))
let b {
}
get
c]]
for c : Int) -> Any, let h.c : (f.<d where Optional<f = {
func f<T -> Void>("[1)
class C() -> (mx : A.A<j : b) -> String {
}
}
init((b: T)
}
return S..dynamicType)
}
return nil
class A {
protocol P {
}
}
}
}
}
}
}
struct S {
var d = [0)
assert() {
return d(b()) -> Any in
}
func b) -> <T where g<l : A, c) {
protocol C = c) {
}
class func g: e : T>() {
(e(a(f.e where Optional<c<T
}
func g<T : P> {
}
let f = D>(x, f: C {
println() -> {
A> String {
typealias f = true as String) {
}
println() {
enum a<C) {
struct e = {
}
}
}
class a: String {
}
}()
return d
}
class A {
typealias C = 1)] {
let h = true {
import DummyModule
}
}
}
func g<b
})))!.b {
self.join(B
}
var b: a {
}
typealias h, a(a
extension String {
typealias F>]()
}
var d()
convenience init()(b
class A? {
f = e: A<h>(t: T>(z(array: d {
protocol a {
}
var f = b()
protocol c {}
typealias e = {
}
}
func f<T) -> (mx : T] == Swift.b = b, let a : B? = { c<S : b: a {
}
class a)
assert("]
}
protocol b {
b) {
}
struct c = b
}
}
}
}
func a: Array) + seq
case C() -> (p
}
super.<T : ()
enum a: A {
self] = b> {
import Foundation
return ")
}
if c {
