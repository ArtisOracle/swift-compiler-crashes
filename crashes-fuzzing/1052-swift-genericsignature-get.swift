// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
extension Array {
typealias R = a<T.Element>(Any) {
func b, B>() {
extension NSSet {
}
case C<h>(s(a(c<Int>) -> (a: T
protocol a {
let d, object2: A<S {
}
}
}
}
init())(array: T>>(n: NSObject {
protocol d where g(self[self)
class c, V, AnyObject, end: P> T
extension String {
}
return x }
}
typealias d where Optional<c)
enum b {
}
typealias R = F
}
typealias R = e(A.count]
func d: SequenceType> : Any)
}
enum S<j : d = {
class func b(a: d {
init(f: A {
}
case .<T where f(x() {
return self.Generator..E == "](((b(bytes: S<T : C> a {
extension NSData {
println(A: AnyObject, U) -> Any):
struct e {
struct c : T>(()
}
func d: (2, y: NSObject {
}
func f() -> Any {
public var e> {
}
import DummyModule
return g: Any, AnyObject) -> {
}
func b(() -> a {
func a: A, e = a)
case .e = T]
func b(A> {
init(bytes: Array<e: A {
case C: U) {
}
import Foundation
class a: ((start, y: (b
}
protocol b {
let v: b
class c(")
struct X<e))
}
class a")(_ = B<T: AnyObject) {
struct c {
let end = a
struct D : U)
func a()
}("""foo")
func e> T -> Any) -> {
}
func f)
return { _, AnyObject)-> String {
A? = b: a {
func d
}
}
}
for (A>) -> {
extension String {
typealias e == { c<T {
class A>) -> A : T, x }
typealias h: B<c: 1, a!)
}
return nil
}
protocol a {
import Foundation
extension NSData {
}
}
typealias A {
struct X<Int
a)
protocol A {
static let v: b = b({
let i: Bool]
var f == h
return $0) -> String {
init <T! {
func a)
}
var f.B : P {
}
}
}
}
return g<S : d {
typealias d, a!
protocol a {
}
func b..A, e : ()
return nil
let d<S : AnyObject) {
}
class B == {
f: () -> T>?) -> (c>()
A, self, y: b> () {
}
"")
}
func f<T : CollectionType where T : 1, x in x = nil
}() {
let a {
}
}
}
}
i<T>, "")
}
}
func d: String
struct c = B
}
case C(false)
import Foundation
let h : A where T, AnyObject.A, f(n: AnyObject) -> {
typealias B == true }
class B : Int
}
func d<b: d wh
