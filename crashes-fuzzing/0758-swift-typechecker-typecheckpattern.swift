// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


= Swift.E
protocol b {
class A {
protocol a {
}
}
let t: c(p
}
}
func i(x: A, Any) {
import Foundation
}
}(() -> {
}
class a {
public class d, T {
public var f = Swift.startIndex).<h = {
}
protocol c {
}
struct d.init()
init({
}
}
protocol d where T -> String
struct c == b: Int = nil
public class b: (b: (f<d>] == b> Int = true {
func b: b: S<d.advance(i()))(() { }
class a((self.<T>: end: A, Any) {
}
}
class d.<S {
println(e(a<T : c] in
return [B.Generator.d>Bool) {
func c)
}
}
enum a<T.c == h: P {
enum A {
func a(.b = D>(c {
}
import Foundation
println(Any, d
}
init((g<T : SequenceType, let x }
let foo as String) -> {
return b(h
protocol P {
public subscript (.e, Any, i: B
}
func e: (Any, i> U -> [0.e(c {
}
}
typealias B : d = d>)
struct A {
let foo as BooleanType>() as String) -> {
var e: NSObject {
struct c = Swift.init()
func e, f<T>(object1, A) -> Any in
return nil
}
}
func b()
convenience init(Any) -> {
let h> String {
struct S(T) {
}
}
case c()
}
}
}
return NSData(.b = """\()
func f.advance(""")
convenience init(g() -> (f, object2)
import Foundation
protocol a : T>(a<h = Int) {
}
typealias f : T] = nil
(Range<h>
return d
for (a<T -> A {
return { c, Any) {
}
return "
protocol b {
import Foundation
}
protocol C {
public var a)
typealias C = c<h
}
func call(f)
}

