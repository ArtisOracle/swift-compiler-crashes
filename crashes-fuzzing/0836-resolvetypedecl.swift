// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


})
a: String
b(Any, B<T>) {
}
f: b = compose()
func b: String {
class func i<I : a {
struct S) {
}
protocol c {
let i(f(f() {
}
}
class c<T {
enum a()
}
let h: () {
}
}
return g(A> Any)
}
struct e = a<S {
println()
return b(x)
}() -> String {
private class B = B
}
println()
}
class A {
}
func a() -> Any in
return { }
}
}
typealias B.C()-> {
}
}
f == ""foo"cd")
}
struct Q<h : Any) -> [], A: T], AnyObject) {
return { self, y: b
var a)
class func i: b> Int = a(t: Range(bytes: A<T : c: NSManagedObject {
class a()
public class A : U {
}
}
case A> {
return { }
typealias C {
}
typealias e : A? = {
}
if c : String {
let start = b()
struct c, c(f([1]
protocol A {
}
class A.Element == {
}
return { c) {
}
public var b()
let b {
}
}
}
}
}
}
}
}
}
class func e<T! {
}
}
protocol e : I) {
return b: A> {
import Foundation
}
var f.join(A>(c(""
public subscript (p
protocol B = B, T : T>) -> [c<d {
var a(false)
}
func b(x(b: b: A {
var b) {
}
return nil
func compose(f)
class B == B
}
protocol a {
import Foundation
}
}
protocol a {
if c {
func e
self)
}
self] == f<b: P {
}
struct e : [Byte]
return [c) -> {
enum b where g, let b {
func i(a
let t.e<d
get {
class b
let t.a(z: ExtensibleCollectionType>() {
}
}
}
}
protocol A where S) {
e = i<T -> {
self.Type) {
f = [Byte]
protocol a {
}
protocol c {
protocol e where f<c>(x, Any) -> Any, end: b<d.dynamicType)
let f = B)
typealias B : d = d<T : A(x, end: NSObject {
let n1: d = c: P> {
class a() -> {
var b = B
}
func compose() -> : A {
return "[[$0..f == [1)
}
class d
extension A {
var a
}
}
self)
protocol A {
return [")
}
import DummyModule
private class a<T where T: Boole
