// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

() {
}
protocol a {
typealias b = T>, range.init<T> () -> String) -> () -> {
self.Type) {
}
protocol a {
}
return ")("cd"
var d where T where T -> a = nil
}
import DummyModule
func a)() -> {
}
}
}
init <c<b<T
func b.h : d = A>) -> {
}
typealias F
protocol A {
import Foundation
protocol a {
c(f.f = {
}
}
func d
case .h == [0.init() {
case C
case C(Any) -> {
return b: SequenceType> : 1][c> {
for c {
default:
}
}
}
}
}
var a)
class func i: A<T))
for (({
import Foundation
struct d.B {
func f: Int = d
class c in x }
}
return self.h == h
}
(start, e {
}
func f<Q<D> U, range.<Int][]))
println(t: SequenceType, self.join(Any) {
}
}
}
}
return $0
}
typealias C {
println()
let foo as String
class a(bytes: d
var a: b
}
case .C<(e? = Swift.C(#object1, a: NSObject {
}
let c, b : BooleanType>(false)
map([$0
}
import Foundation
protocol d = b: NSObject {
}
}
var d : Array) -> Self {
t: d = a: B? = {
}
}
class b({
}
e = F
func b(self.c {
var f, i : A<e: AnyObject)
let h
}
let foo as [c<T> U) ->(Any, (Any, f(c : Array<T) {
}
class A {
}
}
func d
class c(")
}
var _ = Swift.B {
}
class A {
return ")("")
}
}
}
func g<T> {
if true as [1)
if c in c : ()] == { }
static let a {
init(2, k : P {
case .a: d {
([Int]
func b, T : e> {
}
return true
func f: T> e: I.B)
assert(f<l : d>Bool) -> T? = d, ()
}
return { _, U>: A([B<d : ()
extension NSData {
func f() {
}
func b()
class A {
}
import Foundation
}
protocol A {
override func a() -> : A {
extension NSData {
func c: T : d
return ")) -> : c: 1, AnyObject) {
class B : A, a)
}
}
struct c where l.C> () { x in x = {
