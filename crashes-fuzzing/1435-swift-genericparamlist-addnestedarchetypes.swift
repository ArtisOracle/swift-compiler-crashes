// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
extension Array {
let h : d where B {
}
var a
}
}
protocol a {
protocol C = j> {
self.C) -> T).C> {
}
convenience init(self.h: AnyObject, object2: BooleanType)
func b<T, e? = B>(""
}
override init(c() {
protocol A = b: SequenceType> Any) -> {
}
}
}
switch x in x {
import Foundation
import CoreData
}
return nil
return g<T>) -> (start, i : T](s: (self, e = b.e : C {
}
protocol A : A<Q<d == 0
convenience init(array: T> {
}
func d
func f<(T
func c([c(a(array: $0
class A> : 1)
}
func g<T where H.C> {
typealias b {
enum S<l : X<T, Any)
protocol b in
f(A<b(start, f<T
class func e(x: A.Type) -> {
self.c = i: B
}
case C(i> : A, Any) -> Any) -> Any) {
}
struct S<U) -> T>(x: b: B<T.dynamicType.c = d<Q<T> : d: BooleanType, let t: c() -> {
return {
func x(T>(n: (h> T) {
func b(v: A, (T]
typealias e == B>) -> Void>]() + seq: T {
}
}
typealias d : NSObject {
func b.c)
typealias f = [T -> Int = a: ExtensibleCollectionType>()
self.R
protocol C {
let d(e(Any) + seq
let d, U)-> {
}
}
}
struct c: NSObject {
typealias F = 0.C(z(array: String {
import Foundation
}
e = B? = b, (t: A>()
}
}
A> {
class B : String {
}
return self.c {
class A {
}
b: Int = b: a {
protocol A : [T) -> T -> Any, Bool) -> Any, T
}
static let c : end: U) {
protocol b = e!
case .b = {
import Foundation
}
}
func f: P> T : C) {
f == 1][1, y: b() -> U) -> (e> Any)
typealias f : AnyObject.h == b: Any) {
class func g: ()
}
return $0.<d.startIndex)
let h : AnyObject):Any) -> T: Array<T) as String)
}
}
}
class b(2, Any) {
func e: d where B {
}
var d = c: T? {
protocol a {
return self.e == c()
map(m: (seq
protocol c in x }
"[1
func e?
typealias e : A() {
protocol c where l.e: b: BooleanType>(a: d == [].B<h> U) -> U : Int {
}
}
typealias A where f
