// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func g<T, c: a {
protocol a {
(h.B
}
typealias F
case c)) -> T : $0
}
struct S<e()
protocol b {
class A {
return !
}
func f<T
class func d
func b.Type) {
class func c
}
enum A : A : a {
}
}
let h)
typealias b = b()
var b {
typealias E
protocol b {
func b
typealias e : e: C {
}
struct d>)-> String = T> d>(c<f == F>?) -> a {
}
}
func f() -> e(_ c(Any) -> Any {
}
init <3)
return { x }
let c = a((a(v: P {
}
case C) -> Int = {
println(m())
let h, let d
extension A {
struct A, object2)
e : (() {
import Foundation
class func b()?) as [self.<C(seq: T {
func c: d : d : c(t: NSObject {
protocol c {
}
typealias A : SequenceType, e = nil
})
for b = Int]):
}
typealias d>) {
}
class func f()) -> V>
func g
deinit {
protocol a {
}
import Foundation
}
let c : String {
return S([[(""a)
}
struct d
protocol d {
}
return "a()
}
(t: S<T {
}
class func ^(n: a {
}
struct c<U -> e: CollectionType where A> : U {
println()
var f(x, A() {
protocol C = 1](n: [1, U>()
}
protocol a : B
protocol a {
}
import CoreData
}
protocol a {
func a(a()
}
struct S<T>(n: e == a<d {
}
typealias f = e())
var b: b: Int {
0
return z: [1].endIndex - range.count], (n: S() -> {
func x(t.e where T>) {
return $0.<T : b in x in x {
func b: Int = c> {
}
}
import Foundation
}
return nil
class a)
t: c {
var a
protocol b {
init()
let t.c: [].a({
import Foundation
func g<j : T where S() + seq
}
var e?
var b> T, T {
let foo as String) {
class A : T: b, a<Y> () -> (a()
0
return ")).Generator.c {
}
func f)
let foo as String))
import Foundation
get {
func b() -> Bool {
case A<1 {
protocol b = b.a<T> T> String {
}
A(b(c(A
}("[1, length: CollectionType where d<Q<T -> (T> S.substringWithRange(T] in
protocol a {
}
d: e((c()
func b: Range<T, (")-> Int = b.join() {
let g = .join() -> T where T]
enum A : Hashable> Int {
class C(m(A<d
}
f = true }
typealias g.h>? {
struct S) -> () -> : A: SequenceType> String {
class B : ()] = [T! {
}
enum S) -> == A.dynamicType.Type) -> String {
S.b in
func f: B.startIndex, end)-> () -> {
}
}
func f: (T) {
import Foundation
}
enum a: A, """)
return "
typealias F
() {
return true
typealias d
}
}
