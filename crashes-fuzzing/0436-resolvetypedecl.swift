// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


b
}
}
typealias R
}
func g<T
self.e == nil
}
class C<T where g: H.init<C<T
protocol A where T>("
}
func f: AnyObject) -> T where g: NSManagedObject {
class C
struct d.init(#object2)
typealias e = {
typealias h
typealias F>()
}
class func a
protocol A : d where T, f: Array) -> (c>>) {
static let h
}
}
assert()
}
enum A {
import Foundation
struct B<T where I.init(e: P> [unowned self.h> S<T.b in a {
}
return g: C> ()
}
private class func a(g<I : AnyObject) -> () ->>? {
}
return nil
let h == {
}
}
protocol C {
return nil
class func compose(b: A? = A? = a
}
typealias R
assert(c()
func a()
init(array: e = [unowned self.a(f<T>) {
}
}
static let h> T>(T) {
}
}
convenience init(AnyObject, V>: A()
class A {
}
}
}
return true
let c, V>)
}
}
}
class A : B(self.c = b()
self.e {
let f : A {
let v: Int
private let g = {
protocol b in x in x }
}
}
var e: AnyObject, U, f: String = {
typealias E
protocol A {
func b(t: NSObject {
self.E == b<T>? = {
var f = Int
}
}
e = b<U : B? = c
init() {
enum A : A.B<T] in
func g<T.h
}("")
struct c : Int -> {
return "))
}
}
}
private class A where A(t: P {
f = nil
self.c {
}
}
}
}
c: T! {
[B() -> T ->(false)()
convenience init(T: B<T
protocol P {
for b {
}
}
func f("
deinit {
}
class d
}
}
}
}
}
func g<T>)
struct B<T.b : d = {
let c: C
typeal
