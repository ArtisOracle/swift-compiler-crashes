// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


return self.e = { x in x }
let v: A? = B? = ""
let d<T>) {
struct B) {
protocol P {
if c : NSObject {
protocol b = c) -> {
func g.b {
init(g, g: e = b<T: Int = [B(t: () -> String = { c: A.d.e = {
typealias e == b: A> V {
typealias B<T>((AnyObject, object2: AnyObject, e: T> Void>? = {
return self)
class func a() -> {
typealias B
typealias E
e {
}
return nil
}
override init<c(AnyObject) {
}
typealias R
protocol d = nil
var d where g: T) {
}
return $0
func g, g: B? = c, AnyObject, e, object2: A""\(AnyObject) {
var f = {
}
let g = b() {
}
protocol C {
convenience init() {
}
class B == f)
}
}
self.b : B<f = {
}
}
}
}
func compose<T! {
import CoreData
return g.b = {
}
func b
}
}
convenience init()(")
func f<H : A {
}
}
var b = b.b = c>]() {
}
protocol P {
protocol A {
}
struct e == b: C<T
class d
extension NSSet {
extension NSSet {
return [unowned self.init(n: $0))
}
}
0)
enum S<U : c: c: Int = [T
extension NSSet {
struct d
}
self.E == T>(x)
let h
}
}
struct c {
let a {
}
case b : A? = c: NSObject {
let d.Type) {
}
}
class C> {
extension NSSet {
}
protocol c {
let v: String {
}
}(#object2)
convenience init<T -> Int ->>()(self.dynamicType)
init <H : H.init<T
}
class B<T> T> [T>: c: B()
}
typealias F
}
b
let t: U : B
}
var d where A>(n: B) {
protocol a {
}
func f)
deinit {
}
class d.c = compose<c: A? = nil
let c = 0)
var f()
}
var b: P> T where I.B : a {
}
class A {
if true {
typealias e = a
}
return ""
let i: P {
protocol c : P {
return self)
println(array: I.d: C> {
case b = a(self)
extension NSSet {
typealias R
struct c {
}
return g(t: A {
class func b(x: Int
init <c
}
return g: I) -> T where A> Self {
init<T>()(g<c
}
return "
import Foundation
func f<C> Int -> Int = {
protocol d where g<f = { x }
}
protocol d = f() {
var d = 0) -> : a {
protocol A {
}
import CoreData
import Foundation
}
return true
}
}
}
return b: A {
static let d: P {
import Foundation
enum A {
extension NSSet {
let t: A.h> U.e where g: Array<T
}
let a {
var e, object1: T.R
class A {
func b
}
}
struct B<A"")"\()
func f: Int = Int
typealias e : e
