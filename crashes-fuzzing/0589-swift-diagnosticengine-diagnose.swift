// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

 Any, k : (a(Any) -> String) { x }
func a)
func a<T : A, length: b("))
}
enum B {
private let c(a("
func b<T, k : b: b
println(array: k) {
func g<T.b {
var b in c : [T> T> {
let h == B<f : String {
func a: BooleanType>(false))()-> A : String {
struct Q<f = a)
}
return nil
let h: A, V>, T -> String {
}
return ")
var e: Any) {
let a<T])() ->(n: d = F
}
}
class A {
protocol a {
case A> Void>) -> == Swift.C
protocol b {
}
import DummyModule
}
}
}
}
struct D : c = ""foobar"""
var d {
protocol b where S(a<T>() -> {
case s()
assert()() {
let h == 1]])
i<d where T
get
func f())
}
class func a<T {
convenience init()
var d = compose(c(1]() {
}
}
return m() -> T {
return d.e(2, d
var f<T) {
}
typealias A {
protocol a {
struct S : P {
println(array: C = {
public var d = T>
struct X<H : A? {
protocol P {
struct D : A<T, end).b {
}
}
}
typealias B<h.c(Range() -> {
}
}
class C()
f, let h, e(AnyObject)
}
typealias e : BooleanType, c<e: end)
}
}
}
var d where d<b
typealias d, f<1 {
}
case b = F>](mx : a {
}
let f == nil
}(n: Any, T {
}
import Foundation
}
}
b.Element == {
b() -> S {
self.B<T
return b: a {
return b: S(c([c> a {
}
protocol b {
(seq
enum A : a {
let c {
class d.d {
}
}
import DummyModule
}
func b: d : NSObject {
enum S) ->() {
extension NSData {
typealias h> {
return !
class b: BooleanType, let d
}
}
struct c(a)
i> {
}
protocol c = B<j : X<f = f: b<T> {
var b, AnyObject) {
func b(1](t: H) {
struct S {
}
}
struct c : 1]
"foobar","A, U.Type
}

