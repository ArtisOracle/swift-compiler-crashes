// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
}
}
}
class a<T where h: U>(() {
}
println(a()
let c: T, end: e> {
typealias h.b : B? = h)
}
}
}
(z() -> {
}
let h, y)
class func b
public var d>(t: H) {
return m(#object1: String {
typealias e = {
func c
}
struct c
convenience init(x):
}
println(.Generator.h : NSObject {
if c {
class A : NSObject {
func f() {
class func b: P> {
func b()
}
")")
map(c: b(A, Bool) -> {
return nil
protocol b = {
protocol P {
var b: d == j> U) {
protocol c {
get
}
return p: B<T -> {
typealias e = h> String {
protocol c = a
protocol d = Swift.init(A> <H : Range(array: k.B : T)
}
}
() {
enum b = {
}
assert() -> T : BooleanType)-> String {
}
typealias F = f(a: A: d where B : C = .d {
}
struct B
var e(z()-> {
}
protocol d : l.A.advance()))?
}
b: T: SequenceType> String {
d
b()
protocol c where Optional<h: a {
let c())
override init<T) -> T -> T: T.init()
extension A {
}
func e> <T : C(#object1: AnyObject> e(h> {
let f = 0
extension A where T>, A {
let c
func g<T
}
}
}
var b {
}
}
func a)
class A, T {
func g.Element == F>()
}
assert(n: Int = "\(T) -> {
}
}
struct c = T>(v: c {
struct A = B
typealias d
get
func b, T -> Bool {
class func f(bytes: T>()
import Foundation
}
}
struct d(n: Any] = T
}
protocol b {
}
struct c(Any, A {
class A {
}
}
struct Q<j : A"a)
case b = d<U {
override init() -> Int = Swift.B, range.B? = b: NSObject {
}
}
}
}
public class C
extension NSSet {
typealias d where g<d.C) {
func g(T>] as a<h: a = Swift.A<Y> String
init <U : a : T -> Self {
struct c: l.e = 1, i(Range(Any)
return b(""a(T>() -> String {
}
}
return g.init<T : A = b> (c((T>? = e()
class A = Swift.startIndex, Any)
}
import Foundation
}
typealias E
func b: U.join(f.c {
class A, 3))-> V {
println() {
override func a!() {
return m: C(array: d = compose() -> String {
func e> {
}
assert(f<c<D> (start: B<Q<T>] = A<j : b {
class func b> a {
}
enum A = e<T -> {}
}
func f()
return d
func a
case c: T) {
func i<T) -> {
func b, f.b = true }
typealias e where T : A.c, B, e())
class B : (a(a(Any] {
import Foundation
}
}
}
func a(n: c(Any) {
}
var _ c: U.f = [T: d {
case .advance() -> Void>(z()
d, g == b: k) {
}
protocol a {
b> Any, a<T> String = g, e == [$0
protocol b = c: (A.a: T where f<h : (.E == B
let a<S {
return """)
func a)
var b<h : A: S(f: k) {
protocol b in
}
protocol e where I.c(B<b<T, object2)()
self.Generator.f = j> T> (x)
}
() -> Any, () -> U -> {
c>(z: e: Bool) {
typealias B
return m(c]):
}
get {
}
}
class d
}
super.Type) -> T.b = g, A : b {
var d = a: NSManagedObject {
typealias F = .a<T
}
}
class C<Q<T> Any in
}
init(b(c() -> S<d
struct B>(Any) -> : AnyObject) {
struct c : AnyObject.startIndex, T>(i("
protocol A {
class A {
}
return m(e():
case C(a: (e(1]
case .A<T where h
}
return ".A<d.c(T>) {
let a<U) {}
}
func b
protocol a {
import DummyModule
}
func f() -> ()
let foo as [1)() -> Any in
protocol b in 0
let a<I : b(b
for (""
}
class b
var d: d where d
}
}
}
}
class A<T, B) {
}
()
}
func e> Void>()!)
protocol a {
b(a))
return []
a(f.<c<T
}
protocol b {
b(T) -> T
var _ = [Byte]()
typealias F
}
typealias f = a))")
return nil
deinit {
struct A> Any, Any) -> == b, range.C<T>(2, e: b {
struct Q<b> Any in
}
case .startIndex, y)
}
typealias g(A<T, g()
struct A, AnyObject, g == B) -> {
0)-> Int {
struct A {
public subscript (a(b<j : String {
}
public var a)
return { c
}
func a
enum A : a {
}
enum b in 0
}
struct D : S.c : P {
import Foundation
var c> {
}
}
typealias d) -> T! {
struct S<d<T : C {
}
d) {
}
for c {
})
typealias B {
}
var _ = g<I : b
return b> Int -> V, x {
typealias A {
}
protocol b = b> T: b in x }
typealias d : [T>() {
func c<f : ()
}
}
protocol a {
d: a {
typealias g> {
typealias d: d {
init(b(a: Range<U, Any)
}
import Foundation
func a<d<A? = true {
import Foundation
return "\() -> U : Int = B<T) -> (i() { c<j : A? = {
}
let a
}
}
convenience init<T, AnyObject.B
class A: T>))
d..d.e == a<(b: Int = b: Int -> String {
}
}
enum b where T) {
protocol a {
}
func g<T>: Int = F>]() -> e?
b
protocol b : a {
}
}
b[1], ()
func g<T) -> T.h.init(c(A<U {
static let foo as String
typealias A {
typealias E
return !
}
return []
func g<T, Any) {
case .init() -> {
private class B : Hashable> Bool {
}
typealias B
protocol c {
typealias R
self.Type
struct Q<1 {
protocol A {
return self, b = B) -> String {
typealias f == b> T>>()!.dynamicType.<h = true as String
}
func c) as BooleanType>()
}
struct B
}
})(Any) -> Void>Bool) {
}
class func i: b> T>?
(c) -> String = A, y: (A, k : d: H) -> String {
}
case .Type) -> String {
}
}
func f: A<U -> {
protocol a {
}
class A where B : S<d {
let a: e
func d
for (t: T>? = [[Byte], 3)
protocol A {
protocol A {
}
return m: AnyObject, T : T>(Any, object2: BooleanType, B, a))
class b: String = B? = {
var a(x: B, i()
let a {
return $0
typealias R = b: Array<T.E
var b {
protocol a {
extension Array {
b
}
}
get {
}
import Foundation
map(T
var b, d
var b : end: A> {
return nil
}
return m()
func c<T>]
func e, (start, range.e {
}
}
typealias d) -> {
func i: SequenceType, A> {
func f<H : () {
}
}
}
func b(a
struct A = j> a {
}
}
var d : SequenceType where l) {
class A {
case A> A {
let a {
typealias e == a<T
func compose(x):Any, A> d.c) -> ()
let foo as a: NSObject {
c() -> U>) {
var f == b()
b: d {
(.startIndex, object2)
}
return S<T) -> {
struct X.c {
protocol d where S<T -> U) -> (n: S) {
func a: k) -> T : Hashable> T) {
public var b() -> A {
protocol a {
}
}
}
convenience init(A> T : (m: [unowned self.<(z(T, U)
}
import Foundation
for ()
}
}
class A {
typealias h: BooleanType)
}
protocol c {
}
struct A<T
}
struct e = nil
}
struct Q<e: T> (T? {
func f()
}
return d.c: A<T.b : P {
}
}
var e: c>(a: Bool])
class A {
extension NSSet {
func b<T : b {
}
typealias E
}
}
}
typealias g> String
class a : BooleanType, V, end: H.E
}
protocol b {
return NSData()
init(e: b = h: b[[](m: d {
self)
}
}
}
protocol a {
typealias f = ["""
import DummyModule
func g<T: d {
let x }
}
import CoreData
}
}
}
}
}
return nil
if c {
return { c, end: b
}
typealias f == c<d(a: CollectionType where T
return ".E == { _, T
}
}
b: $0) {
func c<T {
var b {
typealias d = { _, c<S : $0.b = a):
private class c in x in return { self[() -> Any {
protocol P {
println(bytes: [1, y: (s(n: X<T) {
}
}
}
protocol c {
var b((():
func f()
}
}
func ^(a<b<T
}
let a {
extension NSData {
}
protocol A {
}
protocol e {
return self.Element == Int
convenience init([B
}
}
let h: b()
}
struct A<f = i(A> {
return "A.f = d<T, Bool) {
case b where H) {
f = e, Bool) {
class b[T : Array<T] = a(x: $0
}
}
let foo as String)
func b(""a)
}
for (mx : b: Hashable> e? {
class A {
}
}
}
private let start = 1
struct c)
}
b, U) {
}
extension NSSet {
func g, f<T> String {
}
enum S<d = nil
let end = g: A? = [1)
protocol a {
class a(x(()
return ")
struct S : [$0) -> e(x) -> T>()
enum S<T> {
}
}
import DummyModule
}
println(A, ()
f<T> {
public subscript () -> V {
}
class d.B : [T where d<T.init()
}
}
case A, U, range.b.E
func d.b {
func e)
return self.d : I) -> Any, range: d where h: NSObject {
}
override func i<I : c()
println(a() -> U)
}
}
}
}
func e)
protocol c {
protocol d {
var b: A"
class A : AnyObject, g..Type) -> U) {
struct e = B<Y> {
return self.E == b
class C
return x }
return m: Any) -> T.g == B<C() -> {
}
let start = 1, e = j> (.Type) -> (p
}
e = b: d == 0] {
import Foundation
struct Q<1 {
func a: C(h
typealias d<T>
func f<T, U) { _, e where T : AnyObject, a(b
protocol A = .R
}
protocol a {
d.advance(true {
println({
func a<D>() -> {
protocol P {
}):Any, T
return [0x31] in
protocol a {
let f = b.h : end: $0) {
}
}
class func g() {
self)) -> ()
func c: end: I) -> {
case b {
var b {
func ^(h.c) -> == "](T> {
}
}
var e(n: [1]() { self.advance(Any) {
println()
println(array: d where S()
}
class b(b, Any))
}
var a: c() -> T : 1))
class a = c<d.b) {
}
func f<T>()
func g<T.init() -> {
func f(.A<C: BooleanType, g = a(Any) {
}
class func b<A) -> Int = c>()
}
class B : c]
protocol a {
}
}
enum B : b
println() -> Any, x in a {
[Any, A, y: a(p
struct c == {
let h == B<h == {
func a(c<T : C
init(T>(range.a([T>() -> String) -> U -> Bool {
return z: B
return d: Bool) {
return b: String {
}
class A {
func c])!
protocol A : T) -> ((T)
[0x31] as String) -> String {
class A : I) {
case A<T>Bool]..C) {
extension NSData {
}
class B = b.advance(start, let foo as String) -> a {
}
func a(c> V {
}
return z(s(seq
e where I) {
enum S<d
}
func a(e!()
protocol a {
struct A> {
}
var _ = b
enum S) {
func d: CollectionType where B {
() {
}
func b: end))
class C<T : Int
override init([T where B : String)
struct D : b: T>({
}
}
}
class B? = i(object1: T>)
}
class A {
}
return ""
}
}
convenience init<b<d: String) as String
var b: a = g<A<S : T>
}
}
class func g
let c = nil
self):Any) -> Any {
}
}
case C: String).e where T> U : Int
return { self)
if c in return m: A? = a)
typealias b {
self)""A, q:
var _ c() -> String {
}
return b> String {
let t: B? {
func c, range.join(b<Q<c, d.c : C {
init<h : 1))
class B<T> d>) {
func g<b: BooleanType, object2)
case b {
a(b: A, k : e> U : T
typealias e(t: A, let a {
})] == [1], V>Bool) -> {
protocol P {
class B(Any) -> T where A, A<c<T) {
for (i: A<D> String {
}
}
convenience init(T> {
}
convenience init(n: a {
}
func a<T where d.c = {
func compose<b.h>() -> : T) -> {
extension Array {
}
func f(b.d<A
import Foundation
}
default:
typealias A {
}
import DummyModule
case c(f(() -> () -> Any) {
case .B)) -> a : a {
}
}
private class b
}
}
for b {
map(f: A, T : a {
assert(T, e: Array) in x in 0
(.d {
t: T>() -> Int = {
func g<C
b> Any in
class a<T) -> Any in
func e("
convenience init())
class A {
super.Type) -> Any in
}
case c: b, T -> {
return m: a = b.advance(x: T> Bool {
protocol b : a {
}
}
class B : B
import Foundation
}
func d
}
assert(T>() -> String {
protocol b = D>() -> {
}
[c: Array) -> <c<T> e: a {
}
}
}
func d
}
convenience init(AnyObject)
}
import Foundation
}
(i: A? {
}
convenience init()))
}
init<T>(#object1: Int) { _, V>()
func g, c<C
}
}
class A where g.d = {
enum A {
for b where T>() -> Any) {
protocol b {
typealias d where l) { self.h
}
class func c) as BooleanType)
}
}
}
}
struct X.C(g(n: Range<1 {
}
}
}
}
struct e where A, range: a {
return true
}
}
func g<1 {
}
extension NSSet {
}
b(g<T where Optional<T: String {
enum b : a {
"
typealias e : NSObject {
func c(() {
enum A {
}
struct B
public subscript (() {
}
}
}
protocol C {
enum b {
import Foundation
case .C) -> {
}
func c<T>(n: String {
}
}
typealias B : Int = T>: NSObject {
protocol e = a: start: Int
}
}
return ["foobar"")
func i<d
(c) {
return z(T, end: T.C(b: l) -> {
return b<T? {
typealias F = e: B<T) {
struct A, T : [1](array: Any) ->((t: AnyObject)) -> T) {
b: $0
class b()?
return { x in x in return "\()(("""")
}
import Foundation
init() -> {
let t: (f.h == nil
func b
case C(b
}
protocol A {
}
}
}
}
struct B
enum B = c: a {
override init()
import Foundation
self.substringWithRange((""
d, object2)
class a: BooleanType, i<T, length: (Range<T)(a<l : [""
func g> {
protocol b = {
for c {
}
enum S) {
protocol b {
import Foundation
protocol A {
}
class c) {
let c, Any) -> : Any, range.Generator.c in return z(A> : B, T
(#object1: Int) -> String {
}
static let b {
protocol c = ""
import DummyModule
func a)
class A : Bool) -> Any) -> : Range() -> T>(false)) {
if c {
self.b
}
d
enum A {
}
public var e(g, object2: P {
}
func b: e: () in a = Int
d() {
() -> [c()(x() {
typealias R
protocol P {
struct e = f(g
}
}(A<e() {
class func f.advance().dynamicType)(2, object2)
}
}
class func c, d: b {
}
typealias C {
}
protocol a {
struct D : [1, y: S) -> {
}
for () {
protocol a {
class A {
}
}
import Foundation
(())) -> {
func i: CollectionType where I.d.Type) -> ()
var d : a {
protocol b {
func f<h == {
self.R
import Foundation
class d) {
self.c<T! {
}
init() {
}
(x)-> Any in
}
return self, B
let a!(f<T, Any) as BooleanType)
class func f<A, x in x = """"")() -> S<T where k) -> Any in
let t.Type
}
let v: U.c<A"
return { self.g = e(T>(x)() {
var c<Q<T> (h> () -> Int = g.c(self.B
get
var b: NSObject {
}
get
}
let h: e == g(f, let a {
class C> (T> String {
func a: C {
class A<T
}
var b : e : Int
var b)
typealias F
func a: d where T>] = i: B))
func a(#object1: d {
}
extension NSData {
case .Element>) -> A : start: (A? {
}
func g
let t: b(n: Int -> e)
}
}
class func e: d = j> S<T where T {
}
func compose() {
func a: CollectionType where I.C(bytes: T] = 1])?
}
let start = 1]()
}
struct A {
A? = b) {
}
}
}
class A<T : b("""","")
class c(Any)
return {
class A {
}
get {
typealias E
protocol A {
return NSData(n: k.Type) -> {
return x }
}
class A : end: 1
return d<T.<Y> e? {
class A where S) -> {
init<b: a {
func f<Y> String {
}
class A {
}
let foo as BooleanType>(t: I) {
struct A {
return self, x in 0] as String)
protocol b in a {
private let d: P> Any in
}
}
})
}
}
}
class a {
class A, y: Int = B(x, ""
}
init() -> [c() {
protocol P {
}
super.E == a: d<f : U : e
}
import Foundation
class A = i> String {
class d
case C({
convenience init() -> S) {
var d = 0)
b> (seq
struct c(.Element == {
return g> Any {
func call(A<T) {
self.b[(AnyObject, k : b(T>()
}
case s: d where T, range.init(A")
}
public subscript (f: Any, (b
}
func e!)
func e(T>] as ["
}
}
func f()
typealias h
var f = a<T!
