// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

tring)
}
struct Q<T -> String {
func d(g, U, Any) -> String {
let h: String {
protocol c {
func c<d
typealias R
extension A : P {
}
}
enum B {
}
typealias b {
protocol b = b() -> Any) -> a {
func a<T? = c
}
case c) {
import Foundation
return ["))-> {
let a: d where Optional<T> Any {
class a {
import DummyModule
}
}
var b in
struct c() -> String {
var e())
}
func d.e? {
class A where d.c({
func a
}
}
protocol A {
struct S {
let g : [1](n: A) -> ()
var f = { c: e: A, A {
class A..<1 {
}
self.C<Q<d : NSObject {
self.dynamicType)
if c == Swift.init()
var f == {
func c() -> T : SequenceType> T : a
self.e!)
b()(1](b: e = a<T> {
func x)] {
let f : c, e: (B<h)
c, y: a {
"]
}
convenience init<T, i<S {
}
func e)] {
init(n: a {
}
}
}
class A : BooleanType>(bytes: NSObject {
}
protocol c in x }
super.d : c {
var d.Element>(b(t: T>>(A<A<C())?
let a((_ = D> {
}
enum B : c(A>("[1](c> {
class A {
struct A {
}
protocol A {
}
}
}
struct B<T, e: NSObject {
get
func c: ((#object1, let foo as [c: Int = {
}
func a)
func a)))
}
return nil
protocol a {
}
override init() {
func compose<T.Type) -> () {
case A.R
convenience init(T? = D>(e!))
class A {
var b> T
return { x }
}
}
}
enum b {
return [$0) -> Int = B, "
return p
protocol A {
return g
let c, let h)
typealias d: d 
