// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


class func g<T) {
let h
let i: T.e {
class A {
import Foundation
struct c {
override init() {
}
super.init(object2)->)
return { c(array: a {
return self.e == a
self.a(n: P> [T! {
typealias F = b<T
init <T](T) -> Void>) -> T : H) {
S(AnyObject, U.init(g<Q<T>) {
let a {
var d {
let c {
func f.init(n: B<T) {
d.e = F
static let c
}
}(f, V, object2)
return $0)
e : ("
import Foundation
if true {
}
typealias B
var e)
S<T: Int -> T {
}
func b: A? = nil
var d = b<c: T>(c()
typealias R
}
[B<C> : d {
}
}
}
}
}
private class C) -> Int = D> Int = Int
d<T {
func b
d: A? = A> Void>() {
super.b = b: d where g: C {
class A {
init((b
}
func a(#object1
struct d<A()
struct Q<T) {
}
}
}
return $0) {
func a()
enum S<(x: A? {
}
}
import Foundation
}
func a
init<C
protocol P {
return nil
e : A>)
class A {
struct c {
import Foundation
}
class func a
}
}
let g = [unowned self.b = D> T>]() {
var f = {
let d<U ->Bool)
typealias R = 0
let t: B? = F>? = {
typealias e == Int
struct D : C {
}
protocol P {
var f<T.h = a
[T
func g<() {
protocol c = [unowned self.e = { x }
var e: c, object2: a {
func g: T>(v: (f: $0
return nil
}
}
class A : $0
class func a(e!.c = B) {
struct S<T>? {
}
}()
protocol c = c(f: B<U -> T : H.h == A(")
class d<T>()
init() -> T.e = A(#object1, e: A : C {
protocol b = D> Void>(v: A"A"""")
init(f)
return d
func b.in
