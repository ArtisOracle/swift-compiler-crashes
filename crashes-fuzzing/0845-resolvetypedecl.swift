// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


> <b
println()
(Any) {
t.A) -> {
}
func i: T, object2: B<Q<h : A, U)
init() -> d<l : String
}
}
class a<T where d: T> V {
protocol a {
convenience init(B
case C(x() -> Any) -> {
let h
}
}
typealias e = [Any) -> {
}
b<H : Int {
var d where Optional<d
}
i()
func f: C())
struct A<S {
}
class a: () {
func c: []
}
protocol b = 1, object2: a {
func a)
struct A, d.d..A""
})
}
typealias B
}
}
let d>()
}
return []
typealias e = B<U {
}
public class A : BooleanType, self.startIndex)
import DummyModule
extension Array {
}
}
class c(f.C) {
return NSData(Any, AnyObject> [c][Int](2, y))(A.f = c: e == a(a(A, end)
protocol P {
var b> Any) {
func a() -> Self {
}
println() -> {
assert(h>()
extension String {
func d<1 {
var b<3)
}
}
b: T? = { c<T> (b(B<T : $0.f == nil
return z(t: String {
}
}
}
func a<(i(s() -> Int = a<Q<e() -> : a {
class A {
}
init(x: b: l) -> ()) -> Self {
}
}
protocol b {
}
let foo as String) -> String {
protocol b {
func f() -> ((f<T>(a""\() -> ()
var f: start, T where H.E
}
typealias d {
}
}
extension String {
enum A {
}
}
}
protocol A = [Byte]
let c() -> String {
}
}
var c(t: Any] == [c) -> String {
}
func c, k : d>(x: [Byte]()
}
}
func d()
}
}
return NSData(.b in
typealias F = e(start, e == c
class a: [T> T>Bool)
}
enum S<1 {
return NSData(x)
import Foundation
struct d.R
assert(n: NSObject {
}
import Foundation
let t: P> Any, () -> (A
get
}
typealias B() -> String)() {
let n1: H) {
case s(seq: (A, object2: b = j> d.startIndex)
}
}
class a)
let c {
}
class A = a: B) {
}
}
}
func a
}
}
default:
}
init("
return !)
typealias f : ExtensibleCollectionType>>)()
func a<T -> {
public subscript ("ab"
typealias R
import Foundation
self.f == Int) in x }
extension String {
}
class a {
class A<T : P {
}
}() {
func compose<T> {
protocol P {
var e: k) {
}
class A<T> {
}
}
}
typealias e where T, U, Any)
return ""
var d
func a: T) -> Any) {
import Foundation
}
}
a: AnyObject, AnyObject) -> Any, y)(c: C> {
return p: T> String))
import Foundation
class B {
return [$0.<T> {
func f.Generator.b {
}
}() -> d, c<d.c> String = a<U) -> T where T: a {
switch x = i> U {
var b(B<d where d<B : d where T>()
d() -> (c) {
}
enum B {
protocol b = {
}
}
class A : 1)
import DummyModule
}
func b()
func i(_ c](p
}
}
}
typealias e()))
}
}
}
let i: T.Generator.c where B : d : String)
struct e == b<T>(c) -> U : a {
}
func f<S {
import Foundation
}
}
let t: (T.e
}
}
}
([1)
i: H.e? = T) -> String {
for (n: [T where A<b<h : b(g> T>(h)
import Foundation
}
func c<C<T> Self {
}
public var d
}
}
func b: start, y).c> Int = c> == {
}
var e()
func f(h: e
println()(i> S {
}
}
}
protocol c == {
func f(T>(A.Element == a)
}
class c() {
class A : [T> Int = j> String {
}
}
func ^(Any) {
}
func e
}
func a: BooleanType, AnyObject.c(Any)
convenience init(f: d: A, self)
protocol a {
struct c : end)-> {
case b {
}
func f: d : Array<h: ()
func f: Any, y)
super.c() {
println(T> String {
typealias e : U>) {
struct A> ()
[Any) -> : B(A<d where H.C() -> (b[$0
protocol C {
}
S<A.c<T].E == b: Bool)
}
}
0) {
}
case .A<c, object2)
struct A : [self.Type
}
println())
return { c, i : P {
struct Q<T>? {
}
}
func d
class A<T>] == T
}
convenience init<h.substringWithRange(.endIndex - range.e = B) {
var f = compose(c)
d.a: (T) {
return { self.dynamicType))
var a(f(self[0x31] = a
func c: CollectionType where k.E == b
init(() {
enum b in c : k) {
}
func e(B<T) {
}
}
class a()
protocol A {
typealias F = {
class func call(h, A {
enum a")
func b()
func b: A: H) {
private let v: B<h> (a<c) -> : P> T) {
assert() {
class a
func b: A {
b.h: String {
func c<T where T) {
self)?
class A, ".B? {
}
}
}
}
return nil
}
struct c(A, object2: d = a
typealias d
func c
}
}
}
return self.C> {
typealias f == A<T -> T : 1]
override func f<c)
class c
let b where Optional<T>(n: ExtensibleCollectionType>>
struct d>(n: c {
case A, e> {
if true }
}
var a
enum a
}
}
class A : Int = i> <d(1].dynamicType.A<b> {
}
}
get {
}(c
}
return g, let c
protocol c == i: d) -> {
}
}
class A {
func i<A> U {
let x in x {
}
}
import Foundation
}(v: [1))).dynamicType.<Int>("))
class func g<d = compose<A
func b([c> Any {
let end = { _, object2)
struct B>
}
}
}
(bytes: a = [Byte](")).init()
if true }
}
func f() {
func b
b(2, g
protocol a {
class A: A<T : a {
func b
return [0x31] as a<d where S.B : e: d = Int) -> {
})
return true
case .init<d()()
return ")
}
}
case C
}
class func g<T: S<T>()
class B {
class b(Range<Q<Q<d>(t: [T : e<l : A, U, e(_ c
}
public var e> Int = T>) -> T : ()
var a<T: A<d where T, T -> e() {
enum S) -> T>
let x = b(e: start, e : B<U) -> ((a)
}
func f(f: A? {
}
let f = h.C) -> Void>()
protocol b {
protocol a {
return nil
}
}
let c = h
f)
}
case c) {
}
struct e : c
let v: BooleanType>() -> {
return x in 0.startIndex, a: b: A.a<B == B, q:
protocol b = T> Void>) -> T where d>(i(([T {
class A where A, 3)
}
import Foundation
import Foundation
var d {
import DummyModule
enum A : Int = []() {
var _ c: P> (object1: c(T) -> String {
println(f(T
let v: B
class c(")
public subscript () -> {
enum S()
convenience init(bytes: Int) {
}
class func e? {
class c : (i: Any))) {
}
struct B
}
}
}
func f<d : a {
}
ca
