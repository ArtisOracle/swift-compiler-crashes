// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

 d<T
var b = c())
func f)
func a()
}
func b<T](AnyObject) -> Int -> {
func g.c
class A {
class A {
struct d
struct c {
func g.E == compose<H : String = a()
}
deinit {
enum S<H : NSManagedObject {
protocol A : c(n: B<D>(false)
assert(n: T where I) {
func f: A> S<T](f: d where A? = 0
class B(""
func a()
}
if true {
[T>()
}
class func b: T) -> U, f.h == {
}()
struct c == D> {
return [T>() -> {
let g = B<T! {
override init()
protocol a = Int
self.h = .b : B<T
init()()
}
protocol P {
d
}
var e: C {
typealias F>>(t: d where g, object2)(f<Q<D> : NSObject {
}
override init(false)
class B == c: B<c: a {
extension NSSet {
S()
if c : H) {
}
}
e where g.h: A? = nil
typealias B<T>? = 0) {
}
protocol c {
self.b {
typealias E
}
println() {
}
let g = B(AnyObject.B<U -> {
}
import Foundation
}
var f<T: T>(f, f<T>(f: C) -> T -> String = A: a {
protocol b = b: a {
return b<T) -> T
import Foundation
class A where A")
e = A? = a()
}
var d = compose(t: e: A.c, AnyObject.a(n: I) {
let v: B<C) {
var d where H.dynamicType)
if c {
}
}
for b = {
f = T> (n: A? {
}
class d.init(array: U : T) {
}
b: d where g(f)
class A where T! {
self.E
}
return g<T {
typealias R
}
protocol P {
}
}
class func a(f: String {
typealias F = nil
if true {
class A : T
class func b<T
var e)
}
class func g, object2)
let a {
class func f(f<T, AnyObject) {
}
d: AnyObject, e: C
struct c == c: AnyObject.a() {
var c: T>()
func compose<T>(object1: c(")
let c
}()
typealias F = { c()
}

