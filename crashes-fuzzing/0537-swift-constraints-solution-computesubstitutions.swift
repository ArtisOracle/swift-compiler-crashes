// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


var e: P {
}
typealias h
}
import Foundation
}
}
}
protocol A : T {
c(n: Array<T
let d<H : Int
private let d.e == F>()
var e: H.b {
struct d
}()
super.dynamicType)
import Foundation
let c
var d = c>: NSObject {
import Foundation
}
func b> {
import Foundation
struct S {
println(self] {
protocol C {
for b in x }
}
}
}
let a = 1, AnyObject) -> {
self.B<D>() -> (b: $0
struct S<T>>(x: T>()
class A : T: d where T>(T>()
}
static let d
return nil
init(n: c(#object1
}
self.init(t: AnyObject) {
}
S("\() -> Int = e!.dynamicType)
typealias B<T]() -> T -> T {
println((x: NSObject {
typealias B<I : H.E == [T>(b()
return { x in a = D>: T
init(x)
import Foundation
}
}
}
class A : e : Array<T] in
extension NSSet {
}
}
f = {
}
let c = D>>) {
var e: AnyObject, object1
}
}
class A : U, object1: NSObject {
return "A()
assert()
println(e!.c = [B<I : P> : String {
assert(e: T: B<T -> T>(t: d = { x in x }
typealias B) {
struct d.d
extension NSSet {
}
[B) -> [T.d
d
class func b(n: c() {
protocol e == { x in x in a {
}
let c> T> Void>(c(e: Int -> T -> T>) {
}
for b = b
}
class A {
class func call(n: C> Void>]() {
protocol e = b(f, f: B) -> T -> {
}
deinit {
}
typealias e == c(t: A> [unowned self.d<A.c: I.B<T {
import Foundation
}
func f<c, object1, V>: Int = b: B()
class func b()
import Foundation
}
class A : A.d<c> V {
}(n: Int = B) {
protocol C {
self.h == b() -> [T> Int -> T, f: d {
import Foundation
var b.h == .B == """
class func a(#object1, f, b = c() {
for b {
let c(() -> T -> T where T> Void>) {
protocol e = a() -> (g<T) {
}
}
}
}
typealias F = b
func compose(x)(t: T>)?
}
protocol P {
}
}
return $0
println(f: A.b in
}
i
