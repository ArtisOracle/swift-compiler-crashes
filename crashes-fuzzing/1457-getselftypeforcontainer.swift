// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

 func a
protocol c {
func f(c) -> T, k : e = B
class B = D> V {
class b() {
func f: A<c
}
}
protocol A : b {
class d(b(g
}
get {
struct S(B, Bool)) -> Void>(x, g == g, T: Int {
class a<T.A
}
func e: T>() -> {
}
}
return "A.e(t: A> (object1: A, let n1: NSObject {
func i> Bool {
typealias R
}
let t: b() -> Bool {
import Foundation
let g == { x }
let h
let t: [1))
self)()
}
}
}
import Foundation
}
}
enum A {
}
self.e({
}
convenience init() -> Int = c] = c() {
typealias e = [Byte]]]((T: U {
}
typealias E
()
}
default:
a()
override init() -> (").B<b<T
func ^().c()
self)
A, Any) + seq: A where g<Q<T.<j : P {
}
func b() {
println()
func b(c {
enum S<Int) -> (a<T> {
protocol a {
protocol b {
typealias e = true }
protocol A {
let foo as [Int
}
func g, end: A<A
func b> S {
}()
}
protocol b {
get
return "foobar"")
}
let t: c {
}
extension Array {
return { c(e({
return self.init(array: b[])
}
}
var e(T> (A, end: BooleanType)
struct c in 0.f = a: B, f(mx : [](t.Generator.C(v: b: B
func g, range.Element>] as String) -> Any)) {
class func f<T -> Any, end)(A) -> V {
}
}
[1](array: b = b: c) -> T : d<c, let d
}
}
return m()
}
i() -> String {
}
enum A : 1], range.init(""""A, range.h = Swift.Generator.a<T> String {
}
return true
}
typealias E
func b: S) -> String {
struct c in x in x }
public var b(h> (self.init(e> (true as String)-> Bool {
struct c<Y> T> {
init() -> : Int {
return "
protocol d = A<T>() as String) -> {
extension NSSet {
}
}
}
}
}
}
extension A = b(f<T! {
func a()
class B == h, AnyObject.E
func g<T>(""
}
case C
}
func f<d>Bool]]())
}
enum B {
}
typealias e<Y> {
func b(a)
func b: NSObject {
}
class a {
default:
}
}
typealias E
b(e> {
}
}
protocol a {
}
protocol A {
}
convenience init(false)
func f.d) -> {
class B)
return { c() { _, AnyObject) {
}
}
}
A: H.C) {
protocol a {
class A {
extension String {
func b> {
self, f(")
if c {
b(
