// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


g {
protocol b = T
struct e : Int
return """
}
}
}
let end = B<T
}
}
if true {
struct e : T>(e, let v: d {
(T, object2: b: Int {
}
import CoreData
typealias R
}
class A> Void>() {
protocol A where T : b> Any) {
struct B
}
}
return $0
return {
func d>) -> (h: b : C {
typealias d where T: NSObject {
extension NSSet {
typealias R
}
}
case s: B<D>(()() -> S<c: P {
}
struct e {
protocol d {
f<c)
class B {
struct S<T) {
}(n: U : c(self.C> () {
protocol d : 1
protocol c {
}(Any) -> () -> (t: c()
}
}
var b = B
i() {
let c : BooleanType, e()
func g<b> : ExtensibleCollectionType>) -> {
typealias f : C
typealias f = {
enum A {
func b.a)
f)
class func d: c>()
var e: b = b: b {
return [Any) -> S.b[]() -> {
var b = T> Any)) -> {
for c = Swift.dynamicType.g == b(B.C> {
import Foundation
class A {
}
}
protocol b {
return self))
}
var b(B) -> Void>(a: A {
enum a("foo"")
override init(() {
println()
struct c in a {
}
override init()
func c> String {
}
struct D : a: NSObject {
class A {
i<T) -> [T {
}
var d.Element == f.f = i<T where l.Element>>(bytes: e> String {
convenience init(1)
import Foundation
}
}
func c() {
}
map("]([](i(range.count])() in c == D>(g: d where S<d: d where T.E == c] = e> <h> : String {
assert(f<H : A, f: b : b> String {
typealias h>(#object1: AnyObject) in a {
struct Q<T> Any, A where T where A.a(()
func a<h = F>(b
let i: U -> {
typealias f == j> [c(Any, range: T, U)
typealias B) -> String)
}
})
return { x in a {
protocol d : String)
typealias d) -> Any {
e = {
self.startIndex, U, AnyObject)] = b
}
var d : NSObject {
let a<T : A: AnyObject) -> String {
a("))
protocol A {
case c) { c, object2: b.Type) -> ()
}
f: U) as [Int
}
import CoreData
func a: Int -> {
}
enum A {
}
}
(h: SequenceType where T -> String {
typealias R = B, object2: (h
func e?
init(c {
}
struct e == { self] {
let i> String {
typealias d == a)
typealias d = B)..C(x: a {
}
typealias E
var b()
get {
class A {
class func g
}
return [()
}
protocol A {
var b())
protocol P {
class A {
}
public subscript () -> Int = A, d.C> {
public subscript () -> () -> [Int](n: b {
self.join(true {
class a {
class B : Any)
}
let g == B) -> U) {
class A"):Any, k : B<U -> {
var b(x: e? = Int) -> == e? {
b: String {
return self.f = e)
}
class a {
init<d: BooleanType, A {
case A<h = [B? {
typealias F = A: d.startIndex)
var e<T) {
}
A<f == B)
}
let c = compose(T>(start: [Any) -> String = B<T! {
}
import Foundation
}
}
}
return NSData()
let n1: end: BooleanType>, AnyObject> U) {
var a(n: k) -> String {
}
protocol c == Swift.startIndex)
class B : Int {
default:Any) {
case .Element>() {
enum A : b : C {
}
}
protocol b = { c() + seq: P {
[1](p
}
class b(Any) -> A {
public var a
class A {
})] = D> V {
protocol b where S) {
return p: A>(x: c: c() {
}
}
if true as [[B<T -> {
func f(.d {
class c, k : Array) -> () {
}
}
return {
func a(.count]()
case s: b = 0] == B<T! {
self.E
}
}
typealias h: b) -> Any) {
static let c(A.A, U))) {
func d<j : b() -> V {
return []() {
class func f<T : A, g.d {
}
}
protocol b in
class B {
}
func g> S : b: a(x() {
typealias b = [0.init(c(g<T : B(a: Bool) -> T)
extension NSSet {
var b<T -> () -> == b: A>())
func f(e? {
import Foundation
}
func b, y: X<T>, T : A(range.h, e: B, A {
func b<T> Any) {
}
let i()
protocol b {
public class b: Any, U) {
}
import Foundation
}
return nil
class A {
case .B? {
}
typealias B<T>Bool) -> T.startIndex, A> : a<T> {
let v: T> String {
}
func d: A<f == a()(b> (a(self.B<S {
return {
class A : a {
}
}
class A {
return self.substringWithRange(T>(n: Int>) {
}
protocol a {
get
func f<U {
typealias e : c<U, end)!(p: A {
}
a)
}
let h
(start, A : U : ExtensibleCollectionType>) {
}
}
func i: ()
}
}
}
func a
extension NSSet {
return nil
import Foundation
struct c == A<T]
protocol A = D> String {
protocol a {
for b where T
func b<T](t: C {
}
enum A where H) { c) -> Bool {
case c()
typealias B<U.e where T] = i: SequenceType> Any in
assert(#object1, c()) -> {
}
}
protocol A {
default:
}
let c> A : String {
self).startIndex)
}
}
case s: A) -> {
return [0)
return x }
func b<T) {
}
func d.B>Bool) -> : Any, Bool)
}
}
var b {
typealias d()
case b = {
return "
func d<b: d = B
