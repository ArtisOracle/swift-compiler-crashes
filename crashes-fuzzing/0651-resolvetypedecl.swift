// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


func b
var b: Array<D>("
}
[unowned self.B : U, object1: NSObject {
return self.R
}
class B<c: d where I.c : e, f: Int
class func f)
case b in x in x }
}
println(e!.h> () -> Int = f)
}
struct d: NSObject {
}
struct B
let c
protocol d {
return { x in a {
init <T>(n: d = { c(false)
}
}
struct c = [T>() {
self.c = ")
protocol C {
func g<T) -> U.E
extension NSSet {
}
convenience init(self.h: (n: U : AnyObject.init()?
let c, AnyObject) {
extension NSSet {
}
func b: A : AnyObject) -> {
func a
protocol A : Int {
}
import Foundation
protocol e : String {
return b: NSObject {
}
import Foundation
}
}
}
}
}
protocol P {
}
let v: T: (f<T! {
}
func compose<T>: c()
}
0
}
}
convenience init(t: NSObject {
typealias E
func b
}
init()(x: String {
func call() {
return nil
protocol A {
func f<D>Bool)
}
var d {
import Foundation
}
private class A : C {
}
func b: T.E == F
}
}
super.init(self)
class A {
}
println() {
}
}
init("
}
var f = B
}
e = a()
func a() {
}
0) -> T -> ()
self.c: A")
class d<T
}
typealias F>(self.c
e == 0
struct e = 0
}
var e, AnyObject) -> {
}
}
func f: NSManagedObject {
let d: B<T>() -> T
self.h == nil
import Foundation
}
for b : B<T>) -> T) -
