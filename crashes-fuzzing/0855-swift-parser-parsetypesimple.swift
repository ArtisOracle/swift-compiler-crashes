// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


rn nil
}
func b<T.c] {}
super..d<1 {
}
}
return "a(c, 3)
}
public var f(g, d
typealias e?
class func g<e() {
struct Q<T : d {
for c {
typealias C = .h>()
extension NSData {
func b) -> (a(start, Any) -> Any) {
typealias h)
get
public subscript () -> A : d = b: [$0
return m(a: c
}
return b)
func b, AnyObject> Bool {
}
}
}
}
}
}
func b
}
enum b {
let n1: d where H) -> T : end)
func a)((c> : e where k.g == F>?
b> T)
typealias C {
}
return b[1)
for b {
let end = i<T! {
}
}
}
}
class a("""""
protocol A {
d() {
() {
convenience init<h.dynamicType)
struct c {
}
struct c {
class A {
class func g
typealias b = c
}
struct c == T: Bool][$0.A<T
}
func compose<d: d where I.d {
}
class B
}
self.E == b: b = {
}
}
get {
func i: C(a<T? = true }
"
class func g() {
convenience init((n: NSObject {
S() -> String {
assert()) {
protocol A where l..f = nil
}
import Foundation
var f = b<T)
return self.count])
class a {
}
typealias f == { self)
self)(Any)
init() -> Any {
}
return NSData(g<T>
func f)] = T>(x, k : B<T, Any) {
(T> T -> {
b
}
return true
typealias A {
func c> ()
func i: NSObject {
}
return nil
class func a
return m: a {
typealias F = { c> Any in
map(a)
}
}
var d = B):Any, let d>) {
override init()
struct S(_ = b> d
}
}
class A {
typealias f : $0) -> {
typealias e> Self {
import CoreData
}
println() {
class a: T>(")
}
func b
}
class b.startIndex)
class b: C {
struct A = a: P {
class a {
assert()
func a
public subscript ()
}
}
}
protocol a {
public var f = [], object2).c: AnyObject, T>(t.e : T : (x: B<T) {
}
typealias e)
}
func b([Any, length: a {
}
class C(array: A"))
typealias F
d<U {
func d(A? {
()
}
struct S {
}
A> {
func i> == "a():Any, (x)""](f<T: S) {
func c(range.a<T>? = {
}
class A"]
let foo as String
}
c(n: AnyObject, e: T) -> Any {
case b where Optional<A, x in a {
}
func a!
return self)
i() -> {
override init(x, B
func g<I : c> T>: BooleanType, Any) {
var b: d : Bool) -> ((c
}
protocol A {
class B
self.init() -> {
class d>) {
a(object1: c(a: ([Byte], f<1 {
func b(h
typealias e = d<U, range.init(b
import Foundation
return ")
}
let c() -> {
var d>(g> [self.startIndex)
}
func a)
func call(false):Any) + seq: b<d.init()
public var b {
b<T, e, let start = i(n: Any) -> {
let b where h.startIndex)
})
}
}
func a: end))
}
get {
println(Any)
protocol b {
return "
let t: T>) {
var f = c() {
func call(T: AnyObject> S {
}
func b: (())
f : BooleanType)) {
switch x }
convenience init() -> {
let g == h
let c() {
}
}
func g<T where k.Element == [c) {}
convenience init(true }
println("")
extension NSSet {
func i: Int) {
let start = B<Int) {
func e(array: end)
func c) -> T) -> T -> {
var a<T>] == true as BooleanType)
var b(c == j> <d, f: []() -> String {
}
}
println(A"
let n1: String {
import Foundation
}
class a = g, a<d.Generator.Type) {
init(range.d<B {
return d>(Any)
}
}
}
}
}
public var a
protocol P {
return S) -> U : a {
struct e : Int {
get {
let t: Int -> T where f<T -> Any) {
}
var _ = a<Int>() {
protocol B : I.E
typealias F
var f = B<S : a {
protocol a {
typealias d: NSObject {
import CoreData
func g
return x }
return !)) -> String {
class func c<U, q:
public var f<T
}
b.h: B? = e)
}
var b {
extension NSData {
func i: b(a<T>: A : b
}
self)!("")
}
}
enum A {
}
}
}
func a() { }
self.d: A<T>() -> e)
func c, i : SequenceType, 3).c: A<b[]()).endIndex - range.count])"))
import Foundation
if true }
println()
protocol A {
struct A {
import CoreData
func b
}([T] = a)(array: String {
protocol A {
}
protocol A {
}
}
}
assert((a: T
typealias d: T>(T> T
}
let c: A<C> T>(B, d(h: $0
func a<T.Type) {
return [T : String
}
typealias e())
var d where Optional<f = b.advance(T>() -> S) {
var b: [1
case c: T) -> {
i: A = i<S : C
func b.dynamicType)
enum A {
}
protocol d where d: Int = j> A : A, 3] {
}
return { self.b[]
S.init<d
}
protocol C {
func f: Range<l : 1)
override func a: d {
deinit {}
typealias C = a() -> Int = { c() -> <1 {
}
}
}
}
}
}
}
}
typealias f = f<T.endIndex - range.init(B<S {
struct X<d>(()) -> V, let b : AnyObject, a: P> Any {
}
}(b()
}
return $0.substringWithRange(B>: T? {
struct c<T : (n: e: String {
typealias h
let foo as [c():
class B {
import Foundation
}
var a")
}
init(x: A, a)
}
}
let
