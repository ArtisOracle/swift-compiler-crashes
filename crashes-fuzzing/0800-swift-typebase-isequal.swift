// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


A, a
class a
}
}
import DummyModule
func a(1, f: A.advance() -> String {
class func a: NSObject {
return z: SequenceType, i> {
}
protocol C = g(h: start, i(f(e: e
}
}
})
func e: SequenceType where g
}
let h : d == b(i: String {
}
}
return { _, b : d {
var a)) {
class b(n: X.init()
}
return m("""
}
let start = b, T>(.d
import Foundation
protocol a {
import Foundation
}
typealias d(A
}
func i<Y> Any, T : T.A> {
}
}
}
typealias e = {
return ")
}
class A {
}
}
(array: Any, f<d>) {
func b.count](t: (i: A, object2)
}
}
for (h: A
}
func b() {
self.init(v: a {
}
func i() {
}
}
var b: 1
var f<H : A = b() + seq: e: B)
typealias e = T) -> (s: AnyObject, AnyObject> Any) as a(c<T: 1]
}
var f = 1)
d
return "])!.E == a(A, end: c {
typealias F = j> T> T) as a(g: a {
}
}
}
default:Any, length: String {
func a<T, c: SequenceType where Optional<d : ExtensibleCollectionType>
}
protocol b = c
}
self.init<Int
protocol e = B
typealias R
func g: A : T>?) {
c)
}
}
self.Element == c() {
}
}
class C> {
class func c(p: Int = compose<T.E
struct Q<T where T, d<D>(""""foobar")
import Foundation
class func f<T, T -> {
struct D : C {
}
}
}
struct d
protocol b where T) {
}
}
func a(self.R
}
func f()
}
b(mx : Int = e)
}
private let d>(f(c where h
public class A {
}
protocol b {
deinit {
public subscript (bytes: Range(a")()) {
var a(t: AnyObject)) {
var d : start, i : String = nil
extension NSSet {
}
}
}
struct e = b> T where k) -> String {
}
}
protocol a = a(z(c].g == b(a() {
}
class c, B
}
}
return nil
return { c: SequenceType, object2)
struct A {
}
import Foundation
}
}
func x: Any) -> (n: e> T> Void>(A<T -> {
class func b
}
func c<3)
class A, g<T where Optional<T) {
}
}
}
func a: (b()
return !
struct c> Any))
}
}
import Foundation
}
}
case A, length: a {
}
protocol c : I.substringWithRange(a<T> (b[c<T {
}
protocol d = b: d>>(.c> A = f()
self.a<3] {
}
case b = f(b: Range<j : [c<T> T>]([Byte]
println(self.C) {
let end = i(c(T! {
class A : a {
}
}
}
var a(self.c = nil
b, AnyObject) -> (a(a(a(AnyObject.<d where g.C> Int = nil
class A : B<T>()
return {
let b {
}
}
import Foundation
}
protocol c == nil
}
func e: T>(Any) {
typealias e : NSManagedObject {
let a: Int {
}
struct A {
}
}
class B {
return { _, y)
}
}
}
}
import Foundation
class A> (a
self.Generator.E == d: T, self.Element == a: CollectionType where d>: U {
typealias e = c: U) {
var d where f(b: d
var _ = [1]((A<T>
typealias g<T> Int -> S : Hashable> == [1]
c: ExtensibleCollectionType>(Range(array: Hashable> : P {
import Foundation
typealias A {
let c : b = e)
assert(","""
S<T: P> Any, e? {
}
class c {
}
}
typealias b in return nil
func a(start: C = e: Any)?
b.advance()
}
case A"]](array: NSObject {
println(A, i> String = nil
return p
return x in x in x in 0
func d({
()
}
}
typealias b = {
c) -> {
typealias e where Optional<Int>? = h
}
typealias b {
}
a<j : b: b: 1]()
case C
}
var d where T>(")
class func c<D> T>(AnyObject)
typealias e : b, U) { x in return "a()
class b.B {
class A : [T: b
(1])) {
"")
var b[B
}
}
}
assert() {
}
t: b = b(()(start, a<T>>(self.c : a {
}
(T? = d()
class func b
}
"
struct A<l : a {
}
}
protocol c : b: Array<T>(self.E == Swift.g = b: a<d.c = nil
b
protocol a = T, U) {
var b : b in
}
}
let h = b: a {
import Foundation
(((c() {
let i: b> : Bool)
func g.advance()
return d>) {
protocol b {
import Foundation
func a(e: String {
extension Array {
typealias B
struct X.Element>(#object1, f(n: String {
}
struct e = a([1](false)
}
return { c(h
func b: l.A<T) -> T
}
class b(A.Element == Swift.a):Any, B<3)):
return p: B, 3] in
convenience init<T where I) {
protocol C = D> Int -> {
typealias d == c] == 1
protocol b : C = e(A<T -> : () + seq
public subscript ()
}
}
class A {
}
protocol b {
typealias e = [self.c: A, (Any)
}
return ")
}
}
assert(self.R
}
var b : Bool) -> String {
class A> Any in
return true
}
struct d
}
}
}
let h):
convenience init(array: Any, (Any, e == [1]()
}
}
import Foundation
}
}
typealias f == a<B : c: d = a)
}
}
if c {
typealias h.startIndex)
func b(A((b: A.dynamicType.E == {
switch x {
})
case s: ("
println(range: T) -> (A, let start = nil
}
func c: SequenceType where d
func i: C> T] = Swift.Type
typealias e: NSObject {
for c : a {
}
class B : Any) -> (a)
struct c {
}
typealias R = c
case b = [](false)-> V {
enum S<c
protocol P {
protocol b = T) -> () {
struct c where T>() -> V, B<c(p: C {
func f(""""")
protocol a {
}
extension NSSet {
enum A = [].b<T>(n: Array<T) -> : (a<T.c(array: AnyObject) -> : U) -> {
}
struct c(T]("")
func a(start, U>()
}
class a: Hashable> {
var f == {
enum A {
func c, 3] = B, Any) {
}
typealias A : BooleanType)()
extension NSSet {
}
var b> U -> Any, U) {
case .Type) -> {
}
}
return { self.<Y> () {
class A = b) -> Void>(x)
class a : b() -> {
public class func b: A {
}
struct A, T] = B<D> T) {
}
}
class A {
func d>(T>(i> T>({
}
typealias f = { c<U -> e()
case A<T) -> == [0x31] == a(start, AnyObject) -> Bool {
override func e?) -> {
public class a<T>)
return [T -> Any] in
}
assert(n: CollectionType where B {
protocol a {
}
convenience init(x) {
}
typealias b = Int>(_ = c) -> == 0
return { x }
import Foundation
switch x in x }
f()
struct c()
struct c> Bool {
}
enum A : C<T) -> {
func e() {
A.startIndex, a(""")
protocol b {
typealias h
struct e : NSObject {
func i: String {
var b = e: a {
}
func c: b> {
t: a {
func call():Any, y))
}
}
}
let a<U : a {
func b()
return true
return self, A) {
typealias B
case .E == [0x31] as String)
}
}
func f<d.count].A>(.startIndex)()(start, f.join(B) { }
var d where T>Bool) -> String = j> String {
protocol c == c(A> {
println(self)
func a: d = .b = Int) -> String {
}
}
self[B<I : T, end: T: T) -> () -> String {
struct c = Swift.Type) {
var e, let c<S : start, Any) {
return p
private class d
class a(b[self.advance() {
func a)
var e()
}
protocol B : Any))
}
}
case c: Int = { c(array: b
import Foundation
switch x {
protocol C {
var d = j> String {
func c] {
}
}
}
func b
self.d
}
let end = a: CollectionType where g<T>(i(c(i> String = T, object2)
(bytes: B
var b {
let foo as BooleanType, a<T -> T -> Void>))
func i<D>?
func a<c: SequenceType, B<T -> [","")
func d: d where g<T.advance(n: SequenceType, T -> Any, AnyObject) -> Void>(([1
return { _, k : T> () -> T, 3] in
var b() {
class A = .c : Int>
convenience init(T.init([0
}(z() -> T> () -> {
}
}
}
}
func f<T> {
let c = F>() {
import Foundation
}
typealias B<T][unowned self))
protocol C {
var d<d>)() {
let a {
typealias e where h: a {
protocol A {
}
}
public var a<T -> String {
self[](b: d == e> Any) {
import Foundation
}
}
struct B
}
}
}
b[Int
}
class func ^(""A, g : b<Int) -> {
b
import DummyModule
}
}
println() {
return m: T>>() -> e> {
}
func f() { self.Generator.advance()
typealias e where I.a)
}
override init(Any, AnyObject) {
}
}
extension Array {
}
}
class func a)
}
typealias E
}
class a {
init <f : S) -> Any))) -> String {
}
var f<T where T : 1]
}
}
}
d(array: T where Optional<d>(s: X.a
typealias h
}
class func i> Any {
var b {
struct A {
}
var e?
typealias f : Bool)
A: Int {
protocol a : Int
func x: A, y)
struct c
}
}
typealias e {
typealias g<d
struct c where S<c: 1])
typealias R
}
return self.Generator.E == b: U -> {
}
func i({
import Foundation
enum A {
}
}
}
}
init(range.E == T>Bool](T.d : NSObject {
}
func f..dynamicType.advance() {
}
}
let i<T : NSObject {
struct e == F>())
var d {
}
return m: P {
class b, T {
enum B : H.c : C: d.b {
extension Array {
let d>? {
import Foundation
struct D : b: NSObject {
return self.dynamicType.join(() {
enum B {
}
return self)
typealias R = Int>(f(_ = c
}
typealias R = compose<A, range.g == b("")
}
typealias F>()
f(x: C = 1]
private let end = B? = b: B>(x(start: String = a<T>(a
}
let d
protocol b where Optional<T -> : A<T>?
import Foundation
return ").E == b() { self.e == ""\(c())
convenience init([1)
protocol a {
}
b(b
extension NSData {
(b> {
}
let h)","")) -> : AnyObject, f<b[Any) {
struct e == f.b
class A {
}
() {
var e(c {
protocol a {
}
}
extension A = b> Any in
protocol d where g> U.Type) {
return m: H) -> T where T -> <T>]
protocol b in x {
}
struct B, range.A<d == h
typealias f = {
println()!)
func b: a {
println()
class A<3)!
class A {
}
return p: H.A
return x in 0
}
}
func c: B
struct c()
}
protocol P {
return self.endIndex - range.substringWithRange(x, A, f.init(.c : A {
}
}
}
}
}
}
case C
convenience init<T] == f: a {
}
}
}
init <j : Hashable> : AnyObject> : C() {
}
return S<S {
}
protocol e {
class B : (s: d(t: d {
class b(i<d = c(object1: NSManagedObject {
protocol a {
}
class func a(T? {
}
}
})
func c<T : Hashable> ()
func i: a {
class A {
self] = {
struct c> : b> U) -> : b
}
import Foundation
}
}
var b> == b(T) -> Any in
d.e == {
}
typealias d where T : b
let c == c
self.f = 0] {
}
}
}
struct A> {
func f.d) -> {
}
typealias B = a: k) -> T)
class d.Element>([c<T
}
println(A(b, B<f : a {
func compose(start: A? {
protocol d where k) {
}
}
(n: d {
return { c(x)
public class B {
}
}
assert([1)
}
}
func b
}
class a: e([() -> {
println() -> T>()-> a : b(i: P {
return nil
class A {
func b: b: B? = g> (t: SequenceType, end: Int -> (start: k) -> (z(true as [T, range.d
var b : NSObject {
}
return b((c<h, U>(e? {
}
extension NSData {
typealias e == c<A> {
}
public var d) {
i> {
}
self.a<h = f: T> {
func a<j : B
}
var b) {
struct A<c> T : a {
let n1: H) -> {
return ")
}
}
var _ c]
protocol A {
}
func i> : d = true }
func g() -> (s: d {
extension NSSet {
e : String {
(n: T, AnyObject.c: A) -> {
protocol c = [Int
}
}
case .B<S {
}
typealias d..E == Int>] = j> {
map()
}
convenience init()
}
case s: BooleanType>?
}
struct d
func a(true {
}
extension NSSet {
get
}
}
}
protocol a {
typealias f = ""foobar"
}
convenience init()
typealias d
println()
let f = D>(T>(e(c) {
enum A {
struct D : A<T! {
t: a {
var b = c() -> (f, f<T) + seq
}
}
}
let h
}
extension NSSet {
func i<T, let x in 0.init() -> Any) -> String {
}
}
}
}
init(#object1, object2: Range<h
class A> (T
})
enum S() -> ()
init() {
}
struct c<T
get
protocol c = "[() -> String)
}
enum a))
typealias d: SequenceType> U : b() -> T] {
}
case .dynamicType)
f, let d<d>() {
b: A {
func a: a {
typealias B
}
func a(Any, U>(b[1)
}
(z: C {
}
}
}
}
}
var b(Any, d) -> Int = B<T {
return [0
init() -> a {
typealias R = {
func b
protocol a {
}
typealias f = .Generator..g = A> (range.A> String) -> S) -> {
case c<T> {
return self.startIndex)?
typealias B<T : I) -> (a(AnyObject) -> V, Any, AnyObject))
}
return nil
}
class A<H : b: Any) -> {
enum A {
typealias F = .<T>).init(n: ExtensibleCollectionType>] == B>(_ c(x, Any) -> Self {
}
case C(true {
0
f: SequenceType, AnyObject) -> : U -> (c, AnyObject) -> (b: NSObject {
typealias b in a {
}
func b(mx : T> T) -> d(s: e(","))
}
a)))
typealias d>(b(",""]
func f<B {
struct D : b = A
return d>) -> (t: A {
}
func c) {
class A, 3] = d: SequenceType, b : 1, g == [1))
}
import Foundation
typealias e = 1]
var b(range.c : Int>(Any) {
class A : T> String = 0] = [c: T> String = a(false)
println(""
protocol P {
i(A, AnyObject, c: AnyObject) -> S<T {
protocol C = h
class d>? {
func b
struct D : [T) -> Int = [0
protocol b {
protocol A {
return b: S()
case .B<d>: d>) {
protocol a {
switch x in c {
func ^(t: Array<d.join(t: a {
}("))) -> String {
func f):
convenience init(b(T], range: [(z(a<h = h)) -> a {
}
}
func i: String = b()
var b: A<d>(b> String {
}
for c {
}
enum B = b> A {
class a {
println(f: c>()
extension NSSet {
typealias d {
class A>((p
func g<C()
class C(h
}
}
func c<b, A.c) {
class B : $0.endIndex - range: l) -> e<d>(a)
let f : A, V>()?
}
}
return "ab"
protocol B : d {
}
let start = e)"
func d
}
}
class A: U, Any] as a() {
func b, Bool) -> : b<T : d == {
}
}
}
}
func i(t.B.c<T>(false)
init<T> {
typealias F>() + seq: Array<1 {
class a: AnyObject, f.init()
extension NSData {
}
}
}
}
public class a(false)] = 0) {
class A {
}
}
protocol B : Array<T where T : AnyObject, length: I.Generator.advance(start, f() -> (c(start, e> {
func e() -> U) -> a {
func f)
}
protocol b = B
[1
var d {
func ^() {
}
assert(object1: 1
}
class C()
func f, 3)
protocol A : a = B
}
func d>(T> : Any)
func a(v: d.a)
func b() { c: S) {
return self)) {
return { _, T) -> U) -> e(Range()(#object1, d: $0.substringWithRange() -> {
for c = b<T
}
}
class func a!(A.B, i(start: String {
func a: B) -> V {
typealias R = [T>]
import Foundation
protocol b = B<S : b: b {
case c: S(A) -> e
var f: U : C(self.c == A) {
}(p
convenience init()
}
private let h)
}
func a<T -> String {
func a<T
case C<T
case s(false)()!)
class func i: (x)
assert(T
var e, g = d.advance()
}(e
class a(1)
}
println(array: ExtensibleCollectionType>([]((a: d = [T : String {
}
d: H.A> Any, range.Generator.c : 1)
protocol c {
}
class b.advance(t: a : T) {
}
func f.d, V, B
var b where H) {
}
protocol A {
f):Any) -> U)
override func g> String {
return ")
}
}
return !(a<h)
}
var _ = B
c] == """)
func g<T.a
println() -> : P {
i: String {
}
}
}
let x in 0] {
typealias f = F>()
typealias C {
func b: ())
func a: Array<T) -> {
return nil
protocol b {
func b(b
return nil
}
protocol d = nil
}
}
}
func c: Any, q:
}
}
for c {
}
class A
}
}
}
println(start: U -> U)
for b {
func b() {
public var b.E
typealias R = [0.Generator.init<U -> {
}
}
return { }
func g<j : d = F>(T>))
}
class A {
case b {
}
func b: T]
}
default:
a(((bytes: Array) {
struct e {
func f<Int
func b> {
}(a<d<d(T
protocol A {
struct A : c(n: P {
println(Range()
}
case c<f = b
t: AnyObject) -> (seq
switch x in a {
typealias C = b
struct d() {
d((()
}
}
}
enum S() {
}
}
typealias g> String {
return d
struct c, e : A? = {
return !(array: C {
func g, A, d.startIndex)
}
}
func a)
protocol d where B == B<B : d {
default:
println(T! {
}
}
typealias e == [()
println(n: C {
b
func ^(x(".Generator.c<T {
let c, end: T>()
public var b {
for c = a(a))
