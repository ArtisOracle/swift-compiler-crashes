// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

elf)
enum A {
let a {
}
init() {
protocol b {
println().Type) -> {
var d where A: T> T)
class a)
class A<S : NSObject {
return !):Any) {
func f<e> (array: A? = 0.dynamicType.Generator.Generator.A(A, U.g == b: AnyObject) {
}
}
}
(Any, U) -> : B<S : String {
protocol A {
init(()
}
"")
func i(Any) -> S : SequenceType where T] = i<T: a {
S() -> [1]
extension NSData {
}
func b<T>() -> {
protocol a {
}
}
}
}
typealias f : A<h: b {
class a
let v: A.E == {
}
}
}
}
}
func b.h : a {
}
a
class B = [c<D> {
}
protocol b {
a: ()
}
}
}
typealias e, A {
class func d>(t: e? = .b {
protocol a {
return [1, e> {
class C(b(f: U : BooleanType, 3] = nil
var b
[Any] = [self)
class B {
}
import Foundation
}
return self.c(c(i> {
protocol b {
protocol a {
return "A<T -> {
return self)
typealias d where g
}
struct e : String)
var b = .init(i> Any {
func f: a {
if true {
}
b("
func b(f<f == i: SequenceType> String {
typealias d.e : b: a {
protocol b in return true
}
}
struct e = [Any, range.a
case C(a
class b: () -> String {
}
override init(v: BooleanType, V, A> Void>(x: P {
case .a: P {
}
}
init() {
protocol A : b()
}
}
}
class B, Any, length: A {
struct e {
}
}
import Foundation
func c: d {
}
var a: b(a<T.<3] {
}
get
protocol a {
extension Array {
deinit {
struct D : (","
struct D : A : I.Element == d.d
}
typealias F = b: NSObject {
enum b : A> ()
b> T>) -> {
}
import DummyModule
}
}
var b<T
let i<1 {
override init() -> : Any, 3] {
f: l.endIndex - range.startIndex, y)
func e!.d = Swift.B : AnyObject)
let h = f<H : S<Int>(t: l.init([B
init <d
super.init(x, object2)
struct e where T
typealias h>) -> {
class A<I : Any] == ","
}
init<T>: d = B(() {
println(Any) {
struct c : Any) -> T! {
let end = e((A<T -> String {
}
public var f<T) -> T -> a {
protocol c == e
protocol B {
}
typealias F = true }
enum A = nil
return ")
public var e)
class c<T where T : end: AnyObject) {
typealias d.Element>] = {
get {
}
d
init <c) {
}
let i: ExtensibleCollectionType>()
}
let c: k) -> {
fu
