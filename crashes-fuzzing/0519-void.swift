// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


import Foundation
return g.h: $0
}(f<T! {
var d where T.h == b<T {
}
}
if true {
class C> {
self.E
self.e {
class A {
}
}
return true
self.b = T>)
typealias F>()
}
func a()
struct D : Int
let h = nil
}
}
var d {
extension NSSet {
var d = F
class A {
b<f : T> : Int -> String = a()
}
typealias R
protocol e : I.B) {
struct B? = b(f: e: d {
struct c = [unowned self.d.b = c>? = B<T, g: AnyObject, f, object2: C
super.h = {
struct D : Int = A.E
init(f, b : NSObject {
typealias E
static let t: d = e: T]()
}
protocol b {
}
protocol e {
}
struct e = [T>(object1
typealias B<D> Void>(false)
if c = f: P {
protocol C {
func f<f : String {
return { x }
func a()
typealias h
struct B<H : T>: String {
protocol c == { c: Int = B<(g<f : Array) {
var e!.c {
var d = F>]()
class A {
}
0
class B<c, g: AnyObject, object2)
var b = nil
var c: AnyObject, g<T -> String {
}
let d
}
class d
enum S<T>() {
struct S(f<T>) {
}
}
func f: T where I) {
}
extension NSSet {
return "A: NSManagedObject {
}
class func a
super.c>()
struct B<T where H.c: NSObject {
deinit {
println() -> (f: d where I) {
e = {
}
}
protocol e = e: C {
}
class A {
return g<T : AnyObject, f: A {
}
let g = b: e: AnyObject) {
let v: a {
private class B<T
}
struct c {
return nil
case b = a(f)(self.R
class B? = Int
import Foundation
let c() {
class A {
let c: AnyObject) {
private class d: P {
c
}
}
protocol P {
}
}
extension NSSet {
typealias F>()?
private class A : a {
if true {
var e)
class d
let d.R
}
protocol C {
self] in
import Foundation
return $0
b
}
}
class A {
protocol C {
}
}
}
typealias F = e)
class func g<T>: H.c = nil
init(g<U : a {
deinit {
}
}
}
}
case b = b.init(g.E == c, b {
}
class A {
struct Q<T where I) {
deinit {
self.B
func g: T! {
}
if c : d {
typealias e = Int
if c = F>() -> S<c: c
let c, AnyObject.c = D> String = B<(")
let c>: AnyObject, b in
func a
}
}
typealias e = F>(self
