// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


return true
var f, U)"A>() {
class A {
}
struct D : Int
println(f))
protocol b {
println(f<T.init() {
}
enum S<Q<T) {
}
convenience init())
struct c = "")"")
c(self.b = .E
}
}
struct c {
}
return true
}
func compose() -> V>]()
}
func g<T
}
self.dynamicType)
typealias F>(n: String = b> : B? {
func b
}(g.a(self.B<T>](array: C> : String = nil
}
import Foundation
private let f = nil
var d = b: e where H.B == b
}
}
}(")
S<T>) ->(b: B<U -> V>() {
}
class func a
return nil
import Foundation
func g: (AnyObject, U, f: Array<c) {
var e!.Type) {
typealias e == F>()
typealias e == a
}
if true {
let c()
}
struct Q<T
convenience init(#object2: String {
typealias F
for b = {
}
}
func b<T) {
typealias F>: T>](f<U ->) {
}
}()
}
}
class C
let t: a = e: B<T
override init() {
if true {
convenience init(g<T! {
var f : T
}
e {
println(v: $0
}
struct S<T.E
return nil
super.Type) {
}
protocol e = a()
}
typealias B<T) {
import CoreData
}
struct S {
convenience init() {
import CoreData
import Foundation
let a {
println() -> T -> {
}
func b(v: T {
let d
}
enum A where H) -> T) {
enum A : AnyObject, U, object1: Int -> Int {
func call(g(self.d.b = T.E == b
protocol e = {
}
struct c == T
import Foundation
struct S {
private let t: T> Int -> T>) {
}(array: T] {
case b : d where T>()
struct Q<T) -> (AnyObject) {
let c: d {
}
}
protocol P {
super.E == "
func a() {
class A {
struct Q<c(t: C<T where T) {
}
enum A {
}
assert(f<T) -> T {
func call(f: A")
init()
}()()
func a() -> Int -> {
return b> Int = f(b.B == 0
}
return true
var d = b()-> (f(n: 
