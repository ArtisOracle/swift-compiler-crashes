// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

 == {
}
let f : ()
func a()
}
var e(c) -> (Any) { c) -> {
func c: B>(p: b in
}
}
case C() {
class B {
}
}
func f<H : d where k) {
class c = compose(Any, y: AnyObject.c == {
return NSData() {
}
typealias R
default:Any) {
func a!
let i: P {
}
}
return self.f == A? {
}
class C(t: Int -> : T : (.<T! {
}
}
}
}
}
import Foundation
}
}
func d
class func c: b<h : A {
override func a<c() -> {
A, AnyObject, x }
}
}
}
init(t: 1](A() {
}
class a<d
return { x }
case A<d
return {
protocol d {
}
func d
typealias f : [T>()
typealias f = B
return m()
var a() -> U : NSObject {
let a(() -> (array: A.e = a<U : l) {
d: T: A<T.Type) {
}
}
convenience init(e: T) {
}
}
}
}
e = b<T? = D>(h: start: H.B
typealias d: Int = B<U : String) {
}
class A = c<d : ()?) -> : C {
func b
let i(A, U)
protocol a {
}
assert(h: (f<Int])
enum b in
override init(()
map(p: e, x {
}
protocol A {
}
}
protocol B {
b[Any, x = i<h.B : NSObject {
struct d: T: C) -> Any {
return g(n: d
}
private let start = B
init<H : start, Bool) {
b) {
private class d<D> a {
class B {
}
}
deinit {
protocol c {
enum B = {
}
class func d<d>(self.endIndex - range: BooleanType>)
}
func g<U)
protocol a {
struct c() -> {
println(start, f(false)
import CoreData
class func d>(x) in x }
}
}
case c
class b):
}
class a: Int = e)
}
enum S<S {
get
}
public subscript ()
let n1: A, k : String)
}
}
typealias B
class B {
}
protocol c = h
func c<I : Hashable> Any in
let t: c : c(true as String) -> A {
func i([c>() {
case c(")
func b: c(c {
}
}
