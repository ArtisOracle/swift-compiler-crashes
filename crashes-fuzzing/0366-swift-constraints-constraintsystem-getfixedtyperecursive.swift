// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


lf.B
import Foundation
}
struct S {
}
private class A {
protocol P {
class A {
}
import Foundation
}
convenience init() -> Self {
self.e == {
extension NSSet {
}
func a(t: A"
import Foundation
}
e = "
struct S {
typealias F>()
let h> Self {
}
if true {
self.dynamicType)
}
}
}
}
}
var d {
return nil
}
var e: Array) -> (b
var e!.d
let d.c : T: NSObject {
}
}
[T
}
c: P> S<(t: T> {
var d = 0
var f, V, AnyObject, b = {
deinit {
protocol b = e: AnyObject, f: NSObject {
override init(t: C) -> Int {
[B
}
var d = nil
struct d.Type) -> U)
class C<T {
f = b> : C {
private let g = [B? = c: NSObject {
enum A : NSManagedObject {
}
let d.d<T where A")
assert()
}
let c = F
self.b in
}
typealias R = a() {
import Foundation
}
}
println()
typealias R
deinit {
}
0
}
struct S<T: A: T : T.e == F>(n: AnyObject) {
enum A {
typealias e == .c : Int
func b()
deinit {
}
func g: U -> {
private class A {
return nil
class A : A.Type) {
return g.e == compose()
protocol b = {
extension NSSet {
return true
e = {
protocol P {
init<T
func f: A()(T
let d.h = f<T! {
let d: Array) {
}() -> : Array<T>()
}
return [T.E
return "A("""\(false)
}
}
}
}
extension NSSet {
typealias F = c()))
return nil
import Foundation
private let c {
struct B<T
return d.e : A {
case b : a = f<T
typealias F>) {
func b
func g<c: AnyObject, e!.c {
extension NSSet {
convenience init(t: NSObject {
}
}
}
b<c> Int {
}
func b
init(b(array: Int = f, V, g<I : C {
self.h == c: B<T where g<T](false)
}
import Foundation
private class A : Array<H : A? {
}
func g: T! {
var c: A.b in
typealias F = {
var c
}
typealias E
static let a {
}
}
import Foundation
}
init() -> (array: H.d: C) {
class B<T>>() {
}
}
}
var d = F>(n: A? {
init(se
