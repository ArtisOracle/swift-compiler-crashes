// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
struct c)
}
protocol a {
init()
typealias f : ExtensibleCollectionType>())
case .Element == T) -> : Int = i: Hashable> ("cd"
typealias R
}
}
}
let d>, e where H.b where d>() -> Any, x }
return nil
}
}
protocol e : 1], e: AnyObject, "foobar"
}
protocol c : () -> {
self).c where h.d {
}
typealias d
class func a: String = f<T
func b<T) {
protocol P {
struct e : C {
typealias e?) -> String {
}
S<T>() {
}
}
import Foundation
}
func b.init((""
}
}
return S<A, i : b: Int = true as [B>(self.c {
typealias b where f<c(("
}
func i<d.E
return "))
func b
convenience init<d
}
enum b {
}
init()
}
class a(Any)
}
protocol A {
struct c(a<T>(()] = nil
class A.c : S<c) -> {
(()) {
return m: SequenceType, i> String {
}
let f = 0))
var d : (T]())(t: a {
protocol a {
class B : A> T -> (start, y))
private let h> {
func a: d == nil
let a: [() {
func b()
case b {
[unowned self.startIndex, range..c() + seq
func g<T where T) -> a {
var _ c<(b> a : X.e = {
func i: ()
return $0] = [$0] in
var b {
self.<Q<f = Int], x in x in x = 1](#object1, c: C: $0) -> (a<T: T>(g<S : d = c<e: a {
struct e where B {
}
assert(c<T>? {
return d>(_ = i: B, U) -> {
case s()
struct Q<d<T : B
assert(x() {
}
self.<S {
case C(t: (range: (c> (p: B)(c(((Any, T : NSManagedObject {
}
protocol a {
init <T: b : a {
struct X<T, U.c {
import Foundation
b(A.C) -> T
func f(a: Int>(x, U)
case C((bytes: SequenceType> {
self[0x31] in
enum S<T) -> T>() -> String {
typealias f = c: T, U) {
import Foundation
let t: ()
return g: Array<T>(a: String {
}
struct X<H : NSObject {
d>()
self, k : CollectionType where H.<T> e() -> : Any) -> Any)
}
}
}
}
}))
return [Byte]
f(""
func f<S : A<Y> (A<S : B
println(T) {
}
}
return self.init() {
default:Any, range.B == b<d {
return "
func b, y: b[self.A<H : Int {
() {
class b, length: A {
}
}
}
func f<1 {
func i<j : String {
return z() -> {
struct c {
}
}
typealias F>] in
d
}
typealias e?
typealias e where I.C(Any, Any) {
assert(e: d = B)
let i()
}((c : b where g..E == B)
}
let n1: Hashable> {
typealias b {
println(Any) -> String {
import Foundation
}
import DummyModule
import Foundation
var f<T)-> [Any, ((Any, Bool) {
for c {
typealias B = T: (A<Q<T> S<T -> == g: T, i<U {
}
typealias R = Int
}
}
var c(x)
return d.d
var b {
assert(f(Any) -> {
protocol P {
case C<T.startIndex, Bool)
public var c<U {
class A, a: 1](t: d = T) {
enum a()) -> {
override func compose()
typealias d {
var b in
}
d
class B {
typealias f = .g = "ab"")
typealias e = b(c(_ c: Range(g(h: l) ->(n: H.e> e: Hashable> Any, (Any, AnyObject, AnyObject, T : SequenceType> Bool {
class func e
}
case c) { x }
import Foundation
}
return {
}
protocol A : A: b in
}
let i([Int>>(Any) -> U -> (T, T -> {
}
func g> ((m: Int = b) -> (b) -> e: 1)
}
}
class A {
typealias h: String {
extension NSSet {
case C(array: String {
struct c> V {
func e?
func b)?) -> (n: BooleanType>) {
}
extension A {
import Foundation
class a {
convenience init<T) in x }
override func g<d where g
}
}
}
()
enum S) -> Any) -> {
func e(")))
protocol e where I) -> {
()
}
}
struct A : AnyObject> V {
struct c()
func e)
}
import Foundation
func c] = T) -> S : U -> ()
let c(a<f = b: A, T : b {
}
class func a(A<T) -> Any) -> {
func b, ()
}
}
}
}
var b("foobar"ab""foobar""
}
override func ^() {
var c: NSObject {
}
var a)
class c in x in return !
return self.a
class A {
}
struct Q<f = c(f: A> V>(start: a {
(x) {
class d.Type) -> U -> (i: l) {
}
func a<T
struct c == c(A, AnyObject, a)
}
}
class func call() {
case .advance(T, ("))()
typealias f = c(B
convenience init(().e where T) {
case .dynamicType)
typealias R = D>(h: T! {
import Foundation
struct S {
}
case .d.C())(range.A.Element == T>
if c {
}
}
}
typealias C = 1, AnyObject> Any)!.substringWithRange(.a(g(a)
func a)
}
protocol C {
}
let a!(Any) -> : String {
}
class b(a() {
}
}
super.Generator.c {
struct S : 1, let d
}
protocol a {
func g<T>>() -> {
self.C(e: Any, e == T> Any in
let c<T
return self] = i: l.c : Range() -> (a<d
}
return z(p: e: H) -> String {
}
}
}
}
let i("A")
assert(A, g = b: A, object2)
}
class a<T.E == 0
typealias F = {
typealias e = "])) -> ()
protocol b : SequenceType> Any in
var a()
override func f() -> S {
func a((p: P {
}
case s: d = c(.E == a(e)
}
}
extension String = { c<T>([c: $0
}
}
}
func a: b: A : d {
let f == B>("):
protocol b {
})
convenience init<d(e))(self.startIndex)))
}
}
case C: (1](b: T, length: ExtensibleCollectionType>(start, AnyObject, g : [Byte].b : ExtensibleCollectionType>) {
return $0] in
class a!)
struct c<T] = compose<T> (.Element == 0
}
}
}
}
}
var d = true {
f = nil
}
let b : c
}
return x = [1)(true }
}
b) -> d>().Element>) {
protocol a {
func f<T where Optional<c
protocol c == c
func c) -> : A? {
}
}
protocol b {
import DummyModule
}
func e> String {
S<c>) + seq: Bool]]() in x in x }
self.g == b, x }
struct A {
}
}
var b: P {
public class c<T, U, k : end)() {
deinit {
}
extension NSSet {
}
}
protocol b {
let foo as String)
}
}
typealias e where h> U : a {
var f = a: P {
func i<T>
}
let i: A? {
}
}
typealias h>) -> T> String {
}
}
}
func a: NSObject {
return [c
convenience init<T
typealias d == {
return b
}
return self[0
class a {
""foobar")!() {
}
var b {
class c
}
}
}
}
}
var d = .A
typealias f : k.E == 0] = ")
import Foundation
class A = b: A(self.c
println(")
}
func f(t: AnyObject> () {
init <(a: T>() {
let h: d where T] = j> {
}
}
let h : B? = T> {
return b(x))
return self] in
}
t: T, Any) {
}
return {
protocol A {
}
init((x: B
}
}
typealias B? = e)
return x }
case C: Int>)
typealias e where Optional<H : [0x31] {
}
override init<U) -> Int = c) {
func e> String {
enum b {
}
extension NSData {
}
}
func a(n: [Any) {
}
typealias A : ()
extension String {
init(Any) -> T>
}
}
protocol A {
return b(.endIndex - range.a: NSObject {
let b where A.e
enum b in
}
}
var b() -> : [T -> Int = B
convenience init<U : BooleanType>() -> [1]
protocol b = D>()
(start, U, U>(h>]
let t.d>? {
var d
struct Q<h
func c() {
return """
func a<T>?
let b = Int) -> Int {
get
S() {
protocol P {
func call() {
public var e(p
}
}
return ","
var _ c, V, T where H) -> T where g: A {
}
class func f() -> {
}
}
protocol c : b
struct A {
struct c
protocol d {
func e> : end)
import Foundation
i(x, T where T>()
struct S(A, ""A, end)
protocol C = b(B
}
var d where T>? {
protocol c {
}
}
}
func b.E == A, T : d where T>(self.E == {
return b: T : $0] {
let x {
protocol a : [T>() in x in c {
protocol b = [("\() {
}
}((B) -> T]
}
protocol b {
case .B<C
func g, range.dynamicType.init(n: String {
struct e = 1)
}
}
typealias C {
A, f: (a<S {
var _ c() { c) {
}
func f.A<U) {
var e() -> {
}
func e(b(f() -> {
extension NSData {
class c in x }
}
func c<T -> T : SequenceType, let h: A, i : T, T
}
enum S((T! {
typealias R
import Foundation
c
func c<A, self[self.h : d where f<T, q:
}
}
func a(e<d : SequenceType> ()
let x in return z: A.advance(2, U) in x }
}
return "], 3] = [c(x: Any) -> {
(h.init()
}
}
}
struct A<d == [Byte], e = nil
deinit {
}(A<T> String {
case b {
}
typealias R
}
}
return ")
struct A.B, length: A : e!.B) -> {
}
typealias f = T>(")).init(e: Bool) {
}
class C()
}
}
return [1, self.dynamicType.advance(() -> {
self..Generator.advance()
class B : a = .init<d where H) {
func f(T>(e(1
class b((m(seq
protocol A : T)-> : NSObject {
}))
deinit {
var b = Int
}
func b(""a
enum S(seq
protocol b : T> Void>: S<I : S<T][self)
}(Range(c> Any in
return ").C(T, y: a {
}
}
}
}
}
}
}
}
}
assert(a()
return $0
p
