// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


protocol A {
extension String {
}
var d {
}
enum S) {
return NSData(bytes: d>? = nil
return b: (t: SequenceType, range: k) {
typealias R = { x }
struct D : l.<Q<U {
S<l : a: A, g: Any) as [1
protocol b where B == a
protocol b in
}
let t.init() -> [Byte](bytes: ExtensibleCollectionType>] = D>(c = Int>) -> T! {
println()
class B : Int
}
return S<h = T, g = c("""
typealias e: e()
}
func g<c()!() -> : d where I.R
func a: S) {
return S.C() -> : C {
import CoreData
protocol a {}
typealias g<T, V, Any, x in a {
struct c : [c: CollectionType where Optional<T, U) {
typealias e = A) {
}
var b(f.e> [T : start, object2)
typealias e> Any, range: A.advance(")
return { c> : X<S : (((h: BooleanType)(A<T {
class A? = e: A? {
}
return { c() {
}
}
enum b in
var _ c: Int = b()
public var b() -> (false)
}
case .Generator.substringWithRange(b(x) {
b() -> == b(T) {
}
class a {
}
}
func c, a<A> () {
class A {
class b.c : B>: T) -> Bool {
d: T? {
import Foundation
}
let d>()))
func b[B.init(A> Any) -> Int -> () as a
import Foundation
}
var d
}(T.Generator.advance(A, self.count]
typealias f = A<c) {
e : b() {
typealias e where T where d(T)
}
import Foundation
}
}
extension NSData {
}()
func e!
class A, AnyObject> Bool {
case b {
}
protocol c == 1)
func a
func f: A<T, object2)
}
}
self)
protocol P {
return self)
protocol b : b: C {
class func d.init() ->("
class B == b(a<3)
let h.substringWithRange(f, U>? = d<T>((_ = b
}
}
public subscript () -> : H.d: b where H.b() -> : NSObject {
}
class A {
}
class func a(array: a {
}
}
}
protocol b = c() -> Int = { c<b: T -> {
}
}
class func i<T] = 1
}
let foo as BooleanType>()
return $0
public var b : A {
typealias e = {
protocol a {
case c(start: b)
assert(c()
}
}
}
import Foundation
}
protocol b {
init()] as BooleanType)
return "\(bytes: U : String {
func b> {
}
typealias b : SequenceType, AnyObject> {
}
}
class A {
protocol b : e: C> U.<d
}
let g = .E == c
}
}
fu
