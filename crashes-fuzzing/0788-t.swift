// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


B
init(A.Element == A<T.Type) {
println("""a)
get
return [T where f.init(x)
class C<T>(T: a {
}
}
struct c : l) {
}
public subscript (A> : String {
struct S.h>, 3] {
}
}
enum A {
let i> ([1)
func f() -> {
struct A {
typealias B) -> Int = d<T> U) -> {
convenience init(c(2, i(x: Any)
deinit {
class func c])
b: A, Bool]
struct e == {
}
self).Generator.C(#object1, T.b {
println(g, Any, q:
}
return x in x }
}
extension Array {
protocol a {
}
([T>) -> Bool {
import Foundation
}
}
var a<j : e : 1])
}
class b: a {
}(g.f = true {
default:
protocol b {
import Foundation
typealias A {
}
}
}
class A {
func g<e() -> : SequenceType, d
}
}
protocol d : c, U) -> d()
assert(b() -> V, f<h, U, k : C {
return "\(f: d = ")(g
get {
}
b: CollectionType where H) -> == "\(() {
let end = { c<e)) {
protocol C {
}
let i<T: T, d()
println(x) { c
}
}
case ..d where T..c in a {
class func d>>
class B == [[B, a(g())
}
}
return d) -> {
}
let a {
return g<S : NSObject {
}
}
}
let c {
}
return $0.A.startIndex)
}
import Foundation
func b: d {
}
b> : C(t: a {
import Foundation
}
func g
}
}
for ())
}
typealias e(Any, i: d.E
}
protocol c {
class C> {
class A : T.startIndex)
d<T) {
typealias A {
class B : Int
protocol a = e: e> () {
}
return "
func a")
(m(t: B<T>(Any, ")
}
import Foundation
typealias F = a: ["
}
func g, (AnyObject) -> (f(A<T: B
var d = e(a<f = c(b
typealias F = {
println(Any)
private class A : CollectionType where f, range.Type) {
public var _ c> {
}
let t: C<d.c {
}
let c(n: b<b
typealias E
}
return true
case b {
class B : S.C) -> {
}
func g<h)
}
case C(() -> {
let g == compose<T) {
class func f)
import Foundation
case s: d {
enum A : d<T) -> {
class B {
return g, (b: A, f)
return b> ()
typealias A : BooleanType, A {
extension NSSet {
}
typealias e = [1](b((h.Generator.Type
var e> d>(Any, () {
return nil
println(i> U -> Self {}
func f<1 {
convenience init(self[T
}
protocol b = b: c
init <T, U) { }
struct S) -> Any {
}
struct c((c == e))
}
}
}
case C
}
struct c {
typealias F = nil
protocol a {
let i: X<h: NSObject {
protocol a : l.a)
}
let t: c> {
}
extension Array {
}
0
}
protocol e == b(1])
typealias F
func a() -> T) -> {
}
func e?) {
struct S) -> {
}
typealias R
}
import DummyModule
protocol a : (start, T : a {
self.Element == B<T
let g == i(n: A<d {
}
c: Any, A<T, U))
}
}
var c: T> {
})
import Foundation
func a(b, T : Int>()
struct c: NSManagedObject {
return self))
}() {
private let t: b> A {
self.c in a = f, object2: P> Any, let g : BooleanType, y: Bool])() -> {
}
}
typealias e == F
struct e = [1)
}
}
func d: [$0] in
override func c(Any] == c](self[()
[(c<T>()
}
}
}(T>) -> {
}
protocol A : b> Any) -> <B : ExtensibleCollectionType>()
typealias e = {
protocol a {
}
case C() -> S : d = b> {
}
protocol P {
class B : NSManagedObject {
class A {
typealias C {
}
private let h : ().h : b: SequenceType where k) -> : AnyObject) -> T, self.init(b[c: b<(b(i> d.e: b where T, y)
enum b in 0))
typealias A : (1, U) {
case b {
func i> V, Any, end: b({
}
}
b
func b[1
protocol d : A {
extension Array {
})
}
class A {
return z: b() { c<Int>, d
return ")
self)
class a {
assert() -> T> [c] = 1]([Any, g(b> String {
func f: String
protocol a : a {
var a)
func c<T> : Bool]() {
case C
}
}
}
if c {
}
}
return x = F>("""
func g<C(#object1: Int
}
override func a: NSObject {
}
return z: String {
struct B
}
protocol b where B = ")
f = Int>()
class a {
typealias d = """]
import Foundation
}
public var b.b in
}
}
override init(f() {
protocol a {
class a)
}
}
typealias b in 0] {
enum b : A<d where h: A, b : d = "")))
}
protocol a {
class C> : A? = { self.Element>? {
}
typealias E
}
let c {
for c in return self.Type
let b = i> {
return d()
import Foundation
}
}
public var b {
func b.Generator.c) -> Self {
f, A {
}
}
}
class A> (c: Any) {
return ")() -> d
}
}
init(T, A {
func b(s: I.E
convenience init(self.a<T, f(i> S {
import Foundation
if c {
return { c<j : Any) {
return "ab")
enum S(n: String = i<c<T>>() -> {
}
return x in a {
func g<d
let a {
class A {
enum S<T) -> Any, y)
}
enum S(c]
}
struct X<H : start, A {
get {
convenience init(mx : T, e!)))
}
enum S.count]
typealias f : 1)))")(v: Int>(a(f()
convenience init("")(a
struct S : S() {
}
}
class A where B {
class A<T? {
import Foundation
let f = B<H : P> Void>, c<b()
func g..c : BooleanType>() -> {
case C(range.count]]
protocol B {
struct c = h: end: C() {
}
var b {
public class A
() {
}
func b(self.init() -> Int {
return m() -> String {
}
}([0x31] == b<d
}
}
func i> Any in
for c {
func f<T) -> {
import Foundation
case C
}
typealias d {
}
if true }
}
protocol A {
}
}
protocol a : CollectionType where T>():Any] == i<T> {
switch x in x in a {
}
var a<T.A, T where H) {
struct A, f<T, U, a(A<b
class a {
}
class A {
super.e() -> A {
}
}
return !)
func e!(array: Int {
func g<T) { x }
}
struct c {
protocol P {
let i(b() {
enum S<T.Element == {
convenience init((b> {
}
println()
class c()
extension NSSet {
return nil
case A<Int) {
var d : C {
self)
typealias e = { c(start: start, T>(Any) -> : A.c
println()
}
}
b<f = A) -> : AnyObject, let x }
case s(c
deinit {
func b() -> Any) -> {
protocol a {
return nil
}
}
class A = .c: A"]
typealias d == [], self.c {
import Foundation
}
}
println() -> A {
}
import Foundation
t: ()
struct A {
struct S {
func a)
}
}
}
}
class c {
}
func a<T>({
}
return ""a() {
}
class A, ")
func c]
convenience init(")
return "\(e
return $0
}
protocol a {
protocol b {
println({
func b: (B
protocol A {
d(Any, range: C) {
() {
private let d
var f<T) {
protocol a {
var b {
}
}
}
}
}
for c = f..a)
typealias e : c {
}
(a
}
class func i<T : P> (h> Void>(_ c() -> : a : ExtensibleCollectionType>Bool]
protocol A {
func ^() {
}
println(a<d>? = nil
let d
class c = i> String {
protocol b where h: b: b = e)
func d: H.endIndex - range: SequenceType where A, AnyObject.h> {
}() -> {
class b()
protocol b where I) -> (n: d>(Range(object1: end):
var b {
}
}
assert(b<I : Int])
var d {
return self.A"a: H) ->())
}
func d.Generator.Element>(Any, let end = ")
println(A, f, self.Element == [unowned self.<j : Any, e? {
typealias h>()
func b: AnyObject) {
struct c == f() {
func g<T>() -> V {
import DummyModule
func b
return !.d
init<Int
}
}
}
struct c : NSObject {
import Foundation
func e? {
class A {
return nil
}
}
switch x }
}
enum B == e, AnyObject.h)
protocol b = { x }
protocol a : P {
}
convenience init(f() -> S<T {
func g() -> ()
convenience init<T>() -> {
struct e where T) ->(start: String {
func g<T
return { x }
class func d: CollectionType where B {
func c() {
override func i() {
struct e = { self] {
struct e : A, k : [T) {
}
func b() {
e where T>(c() {
}
let v: Any) in c = A, AnyObject) -> Int {
class c<Int]
return [T : () -> String {
return { _, 3)
let foo as []({
}
}
var b = { c) -> {
case C
var f(a)
public var b)
return S<d>()()([B(() -> {
}
func i<A, Any) as a: Any) {
}
struct A {
let h: b = b.advance()
t: Int
}
static let g == 1)
}
import Foundation
}
b.E == "foo"".b : 1]
typealias h: d == c
}
p
