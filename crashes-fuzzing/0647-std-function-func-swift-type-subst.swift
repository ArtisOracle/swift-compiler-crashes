// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
class A {
protocol P {
protocol A {
println()
let d
import Foundation
func g(b: Int -> T.E == nil
static let c: B<T>)
}
struct c == c
var b(AnyObject, f: Int
class B<T>)
return d<T>) {
for b = b
var b: String {
return d: B<T>)
}
if true {
convenience init()
var d = nil
return """A: T! {
func g: A? = .Type) -> {
protocol P {
func b: U : Int = 1
deinit {
convenience init<T : a = {
}(self.E == F
class func f: AnyObject) -> T) {
return b: A: AnyObject) {
override init()
}
let h = nil
return ")
protocol C {
super.d: AnyObject, object2: (false)
}
[B<T>()?
}
}
}
}
var b = compose() {
0) -> (T.d<T) -> {
return { x in a {
protocol d = a(false)
return { c: U : A {
return self.init(T>>(g, g<T
return [B) {
}
func f()
let f : I.h
}
}
var e!.E == F>: Int {
let c {
self] in
func call(g<T.e where H) {
}
}
return nil
}
}
}
}
import CoreData
protocol P {
}
typealias e = .E
if true {
deinit {
}
typealias F>("
struct c {
let h: NSManagedObject {
protocol A {
if c == b
protocol C {
let d<(v: A"
class B == {
typealias B<A.c, f: U -> {
}
func a
protocol e : A(object1: Int {
}
struct c {
return "")
}
var b : $0
class A {
}
protocol A : () -> {
}
let c(("
typealias B()
}
}
protocol b = B(array: A"A? = Int
}
func f()
let g = c: T {
}
return [T>? = 0)
}
enum S<T> Self {
func g<D>? = Int
var d {
protocol d = {
override init(array: T where I.R
}
}
}
var f<c("\(array: T) {
self)
import Foundation
protocol e == a(self)(")?
return [unowned self.R
class B == {
}
}
var d = B<T>() -> [B? = a(")
}
struct d.R
class B()
typealias B<
