// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


(object1: d = b> A {
return !)(m("ab""a<T {
case C()
}
println()
}
protocol P {
import Foundation
class A>>()(A"]
(s() {
}
}
class C<e?
}
}
b.E == b> (p
var f = e
class func b, d
protocol e where Optional<T, range: $0):
}
func c
}
}
extension NSSet {
extension String {
return S<T -> {
(2, y: String {
}
return nil
}
func f.E
}
func a<e> Any in
protocol b in c = Swift.c], let h
func f, e = i: (h: A>(Any, T>(object1: X.Type) -> U, Any) {
}
class b((b: [])
}
func b(b[B)
import DummyModule
}
extension NSData {
}
}
}
}
}
}
import CoreData
}
func d: b[T>(() {
}
}
typealias e = "foobar"""a<Y> T) {
protocol c = "
case c<T>()
var b in
func d(i: d
class func f<U {
}
case .<T) {
class a!.c = true }
class func d
class A {
()
}
func a)
t: T>(t: A {
}
var d = d: a {
}
import Foundation
var b() {
enum a<B : T: Bool]
typealias e {
func b<T -> {
func c) -> String {
protocol P {
protocol C = {
}
func a<D> String {
class b.c in c {
enum B == {
}
}
let n1: e == a)
extension Array {
struct c in c == b[Byte]]
}
class d.startIndex)
override init() {
}
typealias E
let b where S.join(t: c {
}
}
func b.A, c, Any, B, T where g<T>?) {
}
typealias b {
println()?
func b(T>((""\(x, end: [T : b(e(x)
d
func d
class func e!)
}
convenience init<T -> {
typealias F
}
case s() + seq
}
typealias B? = {
let v: b: B>(mx : d where k) {
}
protocol P {
}
}
class B<j : (self] = c>(a: $0) -> {
func i> V>() {
protocol C {
func g.<T : T) -> == nil
class B == T>(c {
default:
class func d
}
class A : T> Bool {
super.f = B>(T]
class c {
case C("
typealias d((a
let
