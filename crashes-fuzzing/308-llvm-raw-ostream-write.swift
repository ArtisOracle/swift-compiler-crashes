// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

b
protocol n = k
n()
func n<q {
    l n {
        func o
        o _ = : k {
}
class k<f : l, q : l p f.q == q> {
}
protocol l {
    j q 
    j o
}
struct n<r : l>
a)
func a<b:a
}
class f<p : k, p : k n p.d> : o {
}
class f<p, p> {
}
protocol k {
    e o
}
protocol o {
    class func k(dynamicType.k()
f j = i
f l: k -> k = {
    m
}(j, l)
f
protocol k : f { func f
struct A<T> {
    let a: [(  th
}
func prefix(with: String) -> <T>(() -> T) -> Sting{))" }}
struct c<d : SequenceType> {
    var b: d
}
func a<d>() -> [c<d>] {
    return []
}
func f(c: i, l: i) -> (((i, i) -> i) -> i) {
    b {
        (h -> i)   d $k
}
let e: Int = 1, 1)
class g<j :g
}
func a<g>() -> (g, g -> g) -> g {
    var b: ((g, g -> g) -> g)!
    return b
}
func f<g : d {
    return !(a)
  enum g {
        func g
     otocol p {
}
protocol g : p {
}
n    j  }
}
protocol k {
   class func q()
}
class n: k{  class func q {}
func r<e: t, s where j<s> == e.m { func g
k q<n : t> {
    q g: -> e) -> e {
   e b e.c = {
}
 {
   e) {
        f  }
}
protocol f {
   class func c()
}
class e: f{  class func c
protocol a : a {
}
d = i
}
class d<j : i, f : i where j.i == f> : e {
}
class d<j, f> {
}
protocol i {
    typealias i
}
protocol e {
    class func i()
}
i
(d() as e).j.i()
d
protocol i : d { func d
enum S<T> {
    case C(T, () -> ())
}
 a
}
struct e : f {
  i f = g
}
func i<g : g, e : f where e.f == g> (c: e) {
}
func i<h : f where h.f == c> (c: h) {
}
i(e())
class a<f : g, g : g where f.f == g> {
}
protocol g {
    typealias f 
    typealias e
}
struct c<h : g> : g {
    typealias f = h
    typealias e = a<c<h>, f>
