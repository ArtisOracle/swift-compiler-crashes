// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

)
}
}
}
struct D : a {
protocol b {
class C(Range()
self] == 0
func a(Any, U.Type) {
var b, let h)
func i: e: a {
func a
extension NSSet {
}
typealias b {
class a {
protocol b {
typealias e = [Byte]
switch x }
typealias B : d = b))
}
class A, ()
class A {
}
class A : k.C(b.Generator.g = F
let x in return {
}
}
case b {
return self.init() -> Any) {
}
var b = {
return nil
}
}
struct e : start, e = 0)
struct A? = b, x = A.A, a([$0
var a
get
let v: A: b: start: CollectionType where H.f : [1
f<T) {
}
let start = nil
}
class func c([T : A<T) -> (Any] = g.h
case c> e: () {
}
class A : Int>) { self.R
protocol A : 1], B<H : Int = b: b[$0.A> S()
class A {
let a {
}
}
enum a
}
typealias R
A? {
func d: b: A, Any) {
}
func b() {
class A> T) -> {
() -> V {
protocol a = Swift.a)
self.init(t: NSManagedObject {
public subscript ("
func a(mx : start, () -> V, Any, f: b) -> {
})!)) {
class b: String {
}
S) {
}
}
func c(() -> {
}
func b)
var e: Int = a<I : ()
typealias d = {
}
static let t: c
typealias e : c {
println(f, T>()
}
func f(s("")
}
self.<T, e() -> ((g<e<U) -> String {
}
}
class func f: Int = [1)
default:
typealias e = B<()
private let b = b) {
}
var b : a {
}
assert() -> {
deinit {
typealias d = [T where T : b) {
case C: NSObject {
t: NSObject {
class A {
protocol b : T : AnyObject, Any, 3] {
typealias b {
func b[0
class c) -> {
typealias C {
(T
typealias e == b: d where T: AnyObject, V>(f: b<d: C) {
}
}
convenience init("foobar"a)
var d {
}
class func a<U {
typealias B<h = B
f<h == Swift.B {
e {
}
protocol b {
override init() { c
}
protocol B : T> Int {
}
}
}
}
typealias h.Element == [unowned self] in
class func f<U.startIndex))
struct Q<() -> {
[["
class A.c = T? {
}
}
let n1: Int>]
class
