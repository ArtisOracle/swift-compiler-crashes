// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


let f = {
}
class b: b> A : e(.Element == a()
class A {
return !
typealias R = "A> Void>?
struct X<T> T>(self] = c(b(h: e where f: A> () {
}
}
return m: A {
b<T -> T>(p: Hashable> Any) -> == g
class B, e)
let x = b(start: d>(i<T : U>() {
return $0.Element == [")
func b
}
convenience init() -> {
func b: NSObject {
return $0) {
}
}
}
typealias e?
}
d.b where T.startIndex))] == b.e == [self.B == Swift.E == nil
func a"
public subscript () {
}
}
protocol a = g
struct A {
0
}
typealias e where l.c {
}
let t: b : e = d>>(b.b = a<T>(self.dynamicType)
class A.E == 0
return z: NSManagedObject {
class B {
typealias d.b : BooleanType>(A, range: $0
}
typealias F = d
}
}
}
init<T where T where A) -> (T>(T.C) -> String {
}
self)
return nil
}
}(a
struct c
enum S) {
}
import Foundation
func compose<T -> (A","cd"\() -> [".E
func f<Y> S {
func i() ->() {
func c: P {
}
struct X.c> {
}
func f<3] = B<T, y: Range(2, A {
c
"foo""a<Int) -> Void>() -> {
func f: d {
var b {
let b {
}
b() -> Bool {
}
}
class func c<h : A.init<T>, y)
init(([]()?) {
func b.count], f: Hashable> (m: c<()
}
protocol C {
}
class b
let h : b {
return $0) {
protocol b = a<T where I.a()
d
protocol a {
typealias E
}
import Foundation
init()?
get
}
func b) -> Int = {
func i<T>) -> [0x31] as a: k.h : [0
f.startIndex)
case .startIndex)
func a)
func a<Y> U : A : Int
func compose<T> : C<l : d = g({
init <T where T : C(n: (Any)
protocol C {
}
self.dynamicType)
}
protocol d = [1](")
protocol A : a {
func a<d
}

