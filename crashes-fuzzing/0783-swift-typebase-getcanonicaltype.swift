// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


a {
}
}
}
switch x in a {
}
protocol A {
protocol b {
typealias B : B({
typealias C {
enum S) { x }
}
let d>(bytes: Int>Bool](c)
extension String {
class func f("foobar"[Any, f<A.Generator.init([")
let h
}
}
}
}
func f: String {
typealias g<T? {
self.h : A<C("A> ()
let d.b: Bool]
class func c: T) {
var d == c][c<U, "a(b, e: b: String {
init() -> Any, g
extension NSSet {
protocol b {
}
}
let h> String {
typealias d<T -> Any {
func a(T.c<T>((A, Any, let c = c: d where H) {
}
var d : Int {
}
import Foundation
class func compose(b()
}
func b: T) -> V, let h> {
class func g<T> T -> T>((AnyObject.B
typealias b {
return self.b
return nil
class a {
func g<d = A() + seq
class B {
}
class b: Int>(() in 0] as String)
func f(array: U)
}
protocol b where T..e? {
}
func b> T> {
func c()
struct e == true }
S<Int
public var f<U.f : String).C) -> {
let i<Int>Bool) {
let a {
A, end: A<A")
for (Any) -> <T where T
return !(2, A = T) -> {
}
func a(a)
}
class B {
struct S : d = A>) -> String {
}
}
}
let a(start, x = 0) {
}
import Foundation
protocol P {
struct d, a<h> S<Int](t: b)
case b {
d(b<d
for (x(t: d<e: () -> : e: end)
}
var _ c() {
extension NSSet {
}
}
[T : b)
self)!)
}
let t: d, let d: c) -> {
struct A, A {
}
public class b: String {
override init(a(Any) -> {
func i(range.init() {
[1)
func a()
typealias C {
struct S {
}
}
class A {
}
}
"")
class c = 1
let t: e<Int]("")(e()
}
typealias R
class a {
return z: e, let h: P {
class B {
}
}
}
return [Any)
struct e = F
typealias R
func e()] = c
struct c(x)(B.init<T, x }
protocol a {
c(")
enum S.join(n: d where g(c<(v: P> <f == a).B {
protocol b = g("")) {
struct S({
func a: Int = b
struct c, g<S {
enum A {
()
}
let d() -> (array: I.e : Array) -> T -> Self {
case A? = d<T where S<b: Int) -> String)
}
struct d.Type) in x {
var f = B? {
struct c {
struct c where d() -> {
}
let d: C> U) -> Any in
enum b where l) -> Any {
return self.c in x = b() {
protocol c == d, x in a {
protocol b = c) -> Int = i(()
protocol a {
}
}
}
return self.A> {
class c(true {
func b<f = ""
}
typealias R
enum S) {
var b where T, a() {
var d = j> (object1: (c(t: b.Element == [1]](b
}
func g> Int = 0
(T) in return { c: SequenceType, self.R
}
let h
}
private let g : e: B(t: H.c)
let n1: a(T.C(.c = A, k : b, y)
}
let n1: T -> {
}
return m: a {
}
for (g(array: Bool], T]
class a {
protocol b {
}
struct X<T> Any in
}
let a {
}
}
}
return d.f : A {
}
var e(b> Any) -> {
let d.B<T? {
extension A {
}
}
let c = h> (z: b = [Int) -> ()
self[c, end: b(seq: b = 0
}
private class C<C) {
enum b : B) { _, B
}
protocol a {
protocol c == D>(e> U) {
}
(c<(B) {
convenience init() -> A {
}
}
protocol b {
println(p
}
f<T {
class B : AnyObject, end: Array<S {
return { }
protocol e = F>(array: Any, q:
return true
typealias e = Swift.f = {
struct c : a {
protocol a {
assert() -> {
}
}
}
}
protocol b {
}
typealias e {
let c {
}
}
switch x }
self.Element == 0) + seq: Hashable> {
deinit {
func c] = b(x(.c {
protocol A {
}
}
self.c {
convenience init<T -> [self..b: d == 1, y: a : NSObject {
func b(b
}
enum a: (A<f = j> T) -> (self] = a(i> Bool {
protocol P {
}
var f<f = B) {
let a)
func a<l : Int = a() { _, a() -> {
var c: A {
var b: Int](Any) {
}
}
}
typealias B {
}
struct Q<T, f.R
typealias d.b {
}
return ")
var d {
func d
}
}
struct d
let start = [self] = ")
func b: b: []() -> {
typealias e where I.E == Int])
protocol b {
}
}
}
f<f : AnyObject) -> : b> {
convenience init(g<d
case C(a)
import Foundation
var b = c<d: e == true }
A<e? = { self[B<b> S<T -> (array: l) -> S) -> U : String = {
}
typealias e == [Int
}
public var c, x in return $0) -> [[[1
}
protocol a {
}
func call("
}
enum a!)
}
}
extension String {
func i: B
struct S : b: [0
protocol a {
class A {
return self, g(self] = c: Any) { self.init() {
var f<Int>], 3)
import CoreData
func a<H : d = {
f<T, e where T {
}
}
func f: c] as [Any) {
func g((A: b> V, g.C> S {
}
let n1: b) -> (self.C> {
protocol b {
var f: A
typealias e {
println(z: d == F>() -> String {
(c in 0.dynamicType)!
return self, e> {
return x }
class func a<T -> {
convenience init({
let v: [Any, a
}
}
func e() {
}
return b: AnyObject, a)
case C
var b {
return [1]
protocol a {
import Foundation
}(a: T>()
typealias R
}
}
}
typealias e : b, d(p
func b, g<T, e> {
case A? = a
typealias d():
override func c) {
class c
for b {
init(t: [Any, x }
}
}
b<1 {
import DummyModule
}
}
}
}
}
}
var a() -> Any in
class C(a<T, U)
}
class func a)
typealias F = compose() {
protocol c : BooleanType, U):
}
switch x in x in c = nil
case .b) -> Self {
}
}
return NSData(Any)
typealias F>() + seq: NSObject {
typealias f = c() -> ()
public class C() {
}
typealias h
import Foundation
}
protocol c {
struct Q<I : AnyObject, AnyObject> T) {
}
b("
convenience init(() -> e, Any) {
A, self[].C(i: String = b: P {
func ^(x, a<T>() -> U) { c][Byte]
}
func f(g(n: Array<T : [[unowned self, Any) -> Any) -> : B
}
var c, Any) {
}
super.C(_ = {
typealias f == nil
private let v: A> S {
protocol A {
let t: AnyObject) {
i: b: A : Int {
}
}
class A {
var b {
public var b(true {
let t: NSObject {
}
}
case C() -> (g<e(p: (")))?
}
assert(f<T, T) -> T>)
struct c: A> V {

