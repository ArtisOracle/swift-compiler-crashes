// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
struct c {
typealias F = 1
struct S {
var d = a
protocol b in
typealias e where T, AnyObject, f<T) -> {
typealias E
private class func a() {
struct B
d.c {
c: c(f)
static let g = 0
convenience init() {
return g<T : A: A: C) {
struct D : H.init(b<T>()
println(x)
protocol e == D>]()?
}(array: d {
}
import Foundation
convenience init() {
return d: Array<T
var b
struct c = "\(f<T) {
func g<U -> {
init(x: C> V {
c("
var c: String = A>(t: T>(c
protocol P {
class A : P {
}
class func call()
f = a(AnyObject, AnyObject) {
typealias e {
}
convenience init(f<T>: NSObject {
protocol e : NSObject {
let c == a
}
struct B("A> {
}
protocol a {
}
struct S {
b.B : A.init(e!.E
println(t: NSObject {
f = nil
var d = {
func b.R
c: d {
class A : c(b> {
println(b<C<T -> T>(array: c>>? = b(b
}
let t: B(t: String {
}
}
struct S<T.B() -> {
}
struct e == A? {
}(t: C> (")
let h == nil
convenience init() {
var b: String {
enum A {
}
class func g: A? {
class C<H : C {
self.init<T.b = {
var e: P> T {
}(x)-> () {
var e: T> {
d
}
if c = 1
func f)(t: U : NSObject {
class A {
let t: Int = nil
protocol c : e)
let c
[T.E == e!.E == {
}
class d<U -> [B<I : I.c>("
import Foundation
import Foundation
override init<T: String = T
class B<U : d where A.h> V {
class C
struct d: Int {
}
return true
func g(T>(f<T>(t: d {
import CoreData
var f<H : I.e == ")?
deinit {
c()
import Foundation
let d: Int = 1
class func a(b: String = ")
}
let d<T> {
return { x }
}
}
override init()
}
func a()
private let h
}
}
}
}
let g = a(self.init(t: 
