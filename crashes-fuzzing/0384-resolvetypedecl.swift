// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


var b<T, object1: e: C) -> T where g: Int
}
}
class C<H : d where I.e == F>) -> (x: AnyObject, g: c()
}
}
class A : c: T] {
static let d: A>(self.B == {
}
protocol e = T! {
}
protocol b = D>? = 1
struct e = c> V {
struct e where T) -> Void>? = a()
}
}
class d.B : NSManagedObject {
println(x: c: T> {
func b: Int
}
class d
let c = c(T]()
func f() {
let f = 0
private class A {
}
println("")
[B<C<C<C
private class A : String {
var d {
if c : d where I) {
case b in
}
}
[T> Int -> (f<C) ->) -> {
}
func g<D> V {
let v: NSObject {
}
}
}
}
init <Q<I : P {
convenience init()
return nil
struct Q<T {
d.b = T
return nil
}
}
var d = B<T) {
}
protocol A : d {
}
let f = .E == {
}
return g, object2)
func a() -> Void>() {
deinit {
}
}
}
return self)
let c = c, V>(v: NSManagedObject {
typealias R = c) ->(AnyObject, f<f = F
}
}
class func f: B? = c() -> {
class A : d where g()
}
let h
protocol b = f: P {
}
protocol a {
if c = b<T] in
init(x: A? {
}
func f: NSManagedObject {
struct S {
}
}
}
func b() -> [T.d
protocol C {
}
}(()
typealias F>: U : A")
static let i: a {
}
}
}
return b: T>()
static let i: P {
extension NSSet {
class func g<c
}(self.d: A"\(false)(self] {
func f)?
}
enum S<T -> V, AnyObject) -> String = { c(g<T>(AnyObject, f, e!.B == b(x)
var f)
func f<T -> {
self.B : C<T: U : A where T
}
class B<C) {
}
func a("\()
struct D : a = "A"A.e {
typealias e where I) {
override init() {
return true
typealias B<C
}
typealias R
func f, g<T) -> Self {
import Foundation
private let t: NSObject {
}
}
extension NSSet {
func a(self.b = [T>? = {
struct e : T>()
deinit {
}
import Foundation
class func compose(v: AnyObject, e!.B<f = f: Array<c() {
}
self)()(t: NSManagedObject {
convenience init(f)
}
}
return nil
init(")
var d = { x }
}(g.dynamicType)(n: String = F>()
import Foundation
}
func f<T, e: NSObject {
var e)"A")
}
var b in
func a
class func a(array: C> ("")

