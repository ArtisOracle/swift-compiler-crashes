// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

protocol A {
    func c() -> String
}
class B {
    func d() -> String {
        return ""
    }
}
class C: B, A {
    override func d() -> String {
        return ""
    }
    func c() -> String {
        return ""
    }
}
func e<T where T: A, T: B>(t: T) {
    t.c()
}
enum S<T> {
    case C(T, () -> ())
}
struct A<T> {
    let a: [(T, () -> ())d : Seque  }
}
func e<T where T: A, T: B> -> T)!
    r b
protocol a {
    class func c()
}
class b: a {
    class func c() { }
}
(b() as a).dynamicType.c()
class i<h>: c {
    var g: h
    init(g: h) {
        self.g = g
        e{
    j d>
}
class f {
    typealias e = e
a)
func a<b:a
func m<u>() -> (u, u -> u) -> u {
   p o p.s = {
}
 {
   u) {
        o  }
}
s m {
   class func s()
}
class p: m{  class fun: o) {
}
func s<v : p o v.m == m> (u: String) -> <t>(() -> t) -
)
var d = b
=b as c=b
<c b:
func b<c {
  enum b {
   func b
var _ = b
class m: f {
    j h) {
}
j(n k i)
func ruct j<d : Sequencpe> {
    var m: d
}
func f<d>() -> [j<d>] {
 
func ^(a: BooleanType, Bool) -> Bool {
    return !(a)
}
protocol a {
    class func c()
class b: a {
    class func c() { }
}
(b() as a).dynamicType.c()
b
protocol c : b { func b
func some<S: SequenceType, T where Optional<T> == S.Generator.Element>(xs : S) -> T? {
    for (mx :       if let x = mx {
     d: f{  ceanTy b {
    clasi() {
    }
}
protocol A {
    typealias B
}
class C<D> {
    init <A: A where A.B == D>(e: A.B) {
    }
}
() {
    g g         h g
    }
}
func e(i: d) -> <f>(() -> f)>
