// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


\()
}
import Foundation
}
func a(n: A>()
init <(")
typealias e where T
protocol A {
d.c, object2: c: d where A"")
}
return g: ()
typealias F = D>() -> String {
}
super.R
}
func b: AnyObject.E == b<U : NSObject {
private class A {
for b = ")
deinit {
struct Q<T) -> T.E
let t: $0) {
protocol P {
}
}
func f: C<T>() {
typealias F = e: C> {
f = nil
case b : String = B) {
self.h = compose<T>(self.init<U : A> String {
if true {
}
var d = b<H : A {
struct c = b> () -> {
struct d.b in x in a = .R
func a(f<T>: B? = b<T
let c: Int = c
class B? = f<T.a(x: Array<T>)
let d.h == 1
}
}
class B? = a()
if true {
class A : Int -> [B? = e!.init()
}
private let g = {
convenience init(f: Int = f<T.c, e!.c>(array: NSObject {
}
d<T) -> T {
protocol P {
}
}
}() -> (n: d where g, AnyObject, f)
convenience init(x: AnyObject) -> Int = T, AnyObject, f.c> {
}
protocol a {
d.init() {
}
class d.E == Int
}
}
init <A"")
class A : A? = F>) {
enum S<T.d<T>)
}
protocol a {
return nil
}
}
init(b: T] in
}
println(x)"A.R
}
typealias F = nil
protocol P {
}
}(T
c: Int = T, f.h> {
}
}
func f: T>)?
typealias E
struct B(b
}
return b(T, AnyObject) {
}
import Foundation
var d = f: String {
return $0
return $0) -> {
}
func a(f, b in a {
protocol P {
}
let c: a {
if true {
}
}
}
}
}
extension NSSet {
return { x }() -> {
}
let c: U : d = 1: C {
let h = [B) ->() {
func g.d<A.Type) {
self.R
func a(""\("")(self] in
class B<T) {
}
protocol b = { x in a = F>() {
import Foundation
}
class C
import Foundation
typealias e == A")
func a(self] in
}
}
enum S<T, AnyObject, object2: T>(object2)
var b = F>(g: A? {
class 
