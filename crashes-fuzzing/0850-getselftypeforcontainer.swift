// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


protocol a {
protocol c : d {
func d<T: B, a
}
}
struct e where A> String {
convenience init()
}
return [T, Bool]
f = T) {
}
}
(() -> {
struct c: T where T> (""","
func c: 1)
}
}
}
b, range.init([self.B, 3)
}
return self.B
typealias A {
}
class C(AnyObject.B
protocol d where k.d
}
}
typealias d == Int>(f: e? = h: (Any, (n: C(B
typealias f = ")(A> T : U.A> {
class d>(g: (""
self)
class a: 1]
case .dynamicType)
return $0) -> {
return self.R
func i<T> V, self.startIndex, U) -> : H) {
public class B {
}
return {
public subscript () -> U)
}
case .Type) {
func e> String
}
let t: Any, Bool) -> S {
}
class a {
typealias f = g, a)
}
}
}
}
}
return z() -> ()
protocol A {
()
protocol B {
import Foundation
}
var b = c<T> {
var d>(".d) + seq
return b<T.R
func b, y)
func b> A {
struct e : end)
}
public var d = {
func b(z: U -> Self {
class B {
typealias h.g == i() -> : U : a {
var f..init(#object1: A<T : T) -> Bool {
struct e {
}
}
typealias d where k.d<T].d where T) -> ()
let h: T where g<T>("
import DummyModule
}
extension A = Swift.e = a() -> (p: a {
}
protocol b {
func d.B.e where S("ab")
var d where T -> {
}
class B == A
func a()) {
}
}
class b, g<e: B)
static let h : X<Q<T.Type) {
func c, 3))
}
func a)] = nil
typealias f = {
var d = [][T where S.h.g = i() -> {
}
}
for () -> Any)
var b {
struct A<1 {
protocol a {
func b> {
func c():
typealias B)
}
}
extension Array {
e == c, length: start, b : Array) {
return p
static let h: k.E == 1]()
f : [$0] = nil
}
return m: end)
var b in
}
}
for (c
var f.startIndex, k : A {
class a {
typealias h))
}
return b) -> Any in
}
class A> A : (Any, ")
public var b = "
super.dynamicType)
func d>(T, y):Any] = nil
class a<T> String = b[Byte](""
}
class b> : ExtensibleCollectionType>(t: C() -> () -> {
protocol b where g<Int) -> (.Type
}
let h : b(b: A<h : AnyObject.c = {
class A, x }
protocol d : C = {
func a)
func c()
protocol A {
}
}
}
typealias R
}
var c()
import CoreData
func b(z() -> (c) -> String {
protocol a {
func b> <C(false))
let i: a {
var _ c<T>(c
func d
}
if true {
let n1: AnyObject)
import DummyModule
}
}
[1][c> (object1, e(m()
b<T, i() -> <T) -> e(().init()
}
func e()
}
func a"ab"foo"
for (e? {
}
}
class c((self)
let i<T
e = d() {
struct e = 1]]("))
}
return d
import Foundation
}
class A = .C
let v: C {
protocol a {
}
}
}
func f: a {
cla
