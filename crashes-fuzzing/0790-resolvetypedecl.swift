// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


}
}
protocol b in x in x in a = 0
struct c = F>) -> T>()
class C<T where A: T>)(f, object2: Int
}
let g = f<Q<Q<T>(g()
var e: e: U)
typealias F = nil
let d
static let i: d = nil
protocol P {
struct S()
var e: A>? = F>)
return g<T! {
e = {
import Foundation
}
}
protocol A {
}
protocol d = Int
private class A : P {
}
}
let d
var e!.B : H) {
typealias F = b(x)
return nil
init <I : A: U)
}
init<I : c()
private class B == b<D>(false)
func g<D>) -> T where A("
S<T.init(")
[T
typealias F = nil
func g<C
return nil
typealias F = "
self.B<T! {
var e, f: Array<I : d where T] {
}
func f)
func b: d = T] {
case b {
return true
protocol e == F>]() -> (T> Self {
}
return nil
return d
class A : B) -> V {
}
import Foundation
protocol C {
[T>: P> V {
}
typealias F = .c == b<T>? = .dynamicType)
let g = b: c: e, object2: Array) -> T> T : a {
var d {
extension NSSet {
}
func a(t: C {
let t: e {
return [unowned self.B : T>()
typealias h: AnyObject, g<T where I.R
b<Q<T
}
var d {
func g() {
let v: U -> {
}
}
let h == D>(array: Array) ->(c: T! {
let t: AnyObject, b in
}
protocol A : NSObject {
self.c: c) {
extension NSSet {
let a {
}
}(f<T.B == F>()
self.e : AnyObject.b = b(f.E == {
return b: T -> () {
}
}
}
self.E == ")
c(x)
}
}
}
func f: T
}
}
}
}
}
var e: e : A: NSObject {
}
e == b
}
var e!.d
}
println(f))
func a(x)
return [unowned self)
convenience init()
}
println() {
}
}
}
}
let v: H) {
}
let g = 0)
import Foundation
S<C> ()
}
f
