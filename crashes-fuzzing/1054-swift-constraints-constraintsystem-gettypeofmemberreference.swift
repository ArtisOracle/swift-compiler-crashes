// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


enum S<T: I) -> V {
convenience init() {
extension NSSet {
}
typealias e == c: C {
}
class A {
}
println(t: B<U : Int {
class func call(f: () {
println()-> S()
b
let a {
}
let c: AnyObject, object2)
protocol P {
}
class d
println()
}
let c
}
}
self)
}
class d.b = 0) {
}
protocol P {
let d
}
extension NSSet {
return self.E == B<T.b {
override init()
func g<T : Array) -> T]() -> {
struct e {
}
extension NSSet {
}
protocol e == Int
for b in
let t: H.e = {
}
b: A()
}
return [B<T where T>()
var b : B<T -> Self {
}
var d where g: $0
class B == {
}
assert(b: String {
}
if true {
enum A {
struct c = b<T! {
self.b : T>]()
println() {
typealias e where g<T] {
}(object1: (t: String = Int
var b = b
let t: Int
typealias F
self.h == c>("""
d.Type) {
func f.b = B? = "")
struct B) ->(f: T>Bool)()
if c {
var b = nil
if c == .E == b(f: B<A.b in a = {
}
println(x: NSObject {
import Foundation
var f)
return nil
protocol A {
}(b<T -> Int = compose<T {
var b = a(")
println(e)
}
typealias R
let f = A())
}
