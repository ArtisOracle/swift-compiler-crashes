// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

> {
}
func a<T>() {
struct X<T> (e
protocol a {
}
for c = i<T>((c) -> {
}
}
func a)
enum A : $0] {
struct c {
let d>?
func a: b {
let end = B
class B<d {
protocol P {
class func call(T> T : d where h
}
func e!.startIndex, Any).f == {
}
var d {
func e? {
}
}
return m: d = [unowned self.A<T> ()
import Foundation
}
class c: end: $0) {
protocol A : T> Any, y)
}
extension String {
}
}() -> String {
}
}
}
struct D : b: l) {
}
}
static let end = 1
case s: B<c>(T
class A<l : String {
func b<j : ()
}
d
}
override func a(c) {
class B.c
i> {
return b[unowned self.substringWithRange(n: b
func call(Any, object2)
typealias A {
}
}
extension NSSet {
protocol A : A {
}
func d.Type) -> () {
return { x in 0
}
}
init <h, Bool]
class d.d<C> String {
}
}
}
enum B : B(("[Any, U) {
class A {
typealias e(v: P {
case .startIndex, U>, object2)
func b[]]
}
}
class a: BooleanType)
convenience init(a!)
let a {
super.init()
}
class b[c<Y> T>(b, a(a)
private let x = [0.startIndex)
assert() -> String {
var d() {
return p: b {
e = d>
protocol b = nil
}
self))
class b.startIndex)()
extension String {
extension A {
protocol C {
}
class func a()
f: a {
struct A<T>] {
var d
}
protocol b {
f(x, V>)) {
f: NSObject {
}
}
return x = b> (e?
return [c<T -> {
let d: A<S {
}
return b: String {
}
}
func ^(.R
}
}
for c {
typealias g> String {
var b {
protocol A = b)) {
}
init(A
}
}
func a: k) -> A {
switch x = ")
class a<3)
}
class A : A
