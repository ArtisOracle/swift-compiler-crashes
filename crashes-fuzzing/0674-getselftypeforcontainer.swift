// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


nce(b: NSManagedObject {
if true }
c()
}
func b(e()
var d = [1)
protocol A {
}
protocol d : a {
func b: A? = Swift.f = { x in 0
protocol P {
class B
protocol c where l) in x }
if c {
class b) {
var b<T? = [unowned self.f = d
func a(true {
d
}
return x = F>(()
case .e where H.B>
class func a<b() -> (mx : CollectionType where Optional<C(mx : SequenceType, T)) {
}
typealias e {
class a {
func b() {
}
if c : (x) { _, g = B<T : Range<B {
}
import Foundation
typealias e = {
struct c() -> {
}
func b(array: A<c(self, Any, T where Optional<T> T> T> Any) -> U : P {
}
let t: Any, AnyObject)
}
}
protocol a {
}
return self[c
}
typealias b = nil
}
func f, object2: H) -> String) -> {
}
assert(B, U) {
}
if c {
let f = T>] = b(start, 3] = c(T, AnyObject)
}
}
var e<T where T>(g.c = d: Array) {
class a {
case ..dynamicType)
class b: C) -> T {
typealias h)
deinit {
}
case C: T
struct S.h : d = c, U)
if c {
var b {
println() -> <d = nil
}
}
func call()
}
}
}
class b: H.c = T>(Any) as BooleanType, self.b = g<h)
}
typealias A {
let foo as BooleanType)
}
return nil
}
var b> V>() {
}
}
}
public var b(a
}
let c<T.E == j> U) -> T) -> ()
}
}
let a {
println(B)) { x {
class A = Swift.E
}
public class a {
var f = {
struct c {
typealias E
convenience init("".c() {
struct c : C> : T> V, Any, () -> ()
func a<D> Any in
self.a: ((f(start, T
}
extension NSSet {
let start = B))
func f<d: (a(g(n: T.Type) -> <T! {
convenience init(i<U : A? {
import Foundation
protocol C {
}
struct X<b
f: B
struct c : d {
class A {
}
}
class A {
class c(range.Generator.f = B)
}
}
init <d.g = g: P {
}
class func e(#object1, e == b
}
typealias e {
class B {
}
return self.advance() {
}
case .startIndex)
})
}
func f<c: a {
}
}
}
let a<h : A(x: A.d
}
enum B = true }
return ")
init(n: ()
typealias e?
func a<T ->
