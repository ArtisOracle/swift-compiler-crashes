// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


Object {
case c<h == Swift.Element>]], AnyObject) in return ")
}
[1
}
class d<T where d: I.B
class func x, B<A
extension NSData {
}
assert(x, AnyObject) -> String {
}
}
(c) {
import DummyModule
extension NSSet {
}
return ",""
protocol e : b(self)
}
}
return z: e!(seq: () {
func a<b> Any, e?
func f.endIndex - range.h == B
init() -> () -> ()?
struct S<T where T: A.A, f(A, U) -> : [T where T : b
let foo as a"""
var d {
}
}
init<l : SequenceType> Any {
S<T> e<U) -> () -> ()
let d
}
struct D : end: [0x31] as String
let foo as String))) {
println(n: (f: B
func a<e, d<c: (object1, y: d : T: end)
typealias b {
class A : (h> Void>() ->([Int])
}
e where d) -> U.init<d(Any) -> String
func e
var a(A? = a
class B : AnyObject.B {
func i()
}
}
override func f(false))
}
}
func f, length: Int>) -> S {
class C> a {
case C(b(A, U) {
struct c<Y> Any, f: b() {
}
}
self.join(b(A.B, "
init<T where B == 1])-> V {
}
import Foundation
return "\() {
}
struct S<T: a {
})
}
}
}
}
}
convenience init([B
override init(m: ().count](T)
class A : e: b: T? = B
}
func i<b, (start, a()
}
class C<T>(c> {
for b {
}
}
}
}
var d : b: a {
enum A {
var d {
}
func g<T : I) {
let a)
typealias F
enum A {
protocol c == c() {
}
}
}
static let n1: a {
}
}
for c {
typealias B>Bool]
}
protocol b = a<j : String {
class c : A, Any, length: (T)).a(b: String {
class C() {
class a)
convenience init(array: A"ab""")
protocol a {
typealias e: C> S : d where h, self.B : AnyObject) -> {
}
f = Swift.c: ExtensibleCollectionType>(b(x)
}
}
return x in a {
self)
typealias E
func e?) -> Any) -> {
protocol e where T -> [T] in
let b = b(array: BooleanType)?
}
}
return { self[0] = A, Any) {
typealias e
func b) {
let v: C = T, B
import Foundation
}
default:
}
}
protocol a {
case b {
func d
0
}
struct d
}
func g, y: S<() {
var f<3)
self.advance(T>(T) -> S {
func c: BooleanType)
}
}
typealias E
class A
}
typealias B {
protocol A : T? {
self.c {
class C(f)!("\()
case .a)
case s(e: e = h)
static let c: d = c<c(""foobar""
}
}
}
import Foundation
}
return []
return "))
func a: S<H : I) -> ()
extension String {
let i<h : d == [c] {
return $0) {
}
}
}
}
let a {
}
class A where d
if true {
private let c<T -> {
class A {
get {
class func b(b() {
}
}
protocol a = i<1 {
class A<T> Void>()
}
class A {
A
protocol A {
println()
struct c in x {
}
self.Type) in 0.b(n: [0x31] = e> : [Any) -> V, U) -> {
typealias e where T>) {
let b where T: b():
}
class a {
0] {
}
protocol b = [T -> (Range<T! {
func e: NSManagedObject {
}([[(A.advance(b((f: d == f: Hashable> <((()
class func b: Any) -> () {
}
private let d("a("")
}(a
}
}
}
func d<T {
return NSData()
return x in c == { _, Any) {
struct A {
d
}
enum A : 1], A, e> V, Any) -> [0
default:
}
}
typealias B
class a(n: X<T) -> (() {
println(Any, U, e = "
protocol P {
init(array: a
override func d.Element>()
func b
}
}
()
self.startIndex)
var d : () -> {
}
}
var b<D>(t.E == g
init()"foobar"
var a<T
private class a
for c {
}
