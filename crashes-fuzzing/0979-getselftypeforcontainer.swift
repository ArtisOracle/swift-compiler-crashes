// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


urn self.C(Any, a<Int) + seq
}
protocol b {
extension String {
}
protocol b : a {
0
func g, d
default:
class func a<b
func ^([c: Any) -> Int {
super.Type) {}
})) { _, y).C> Any, range: AnyObject, x }
}
}
init()
}
return S) {
typealias f : AnyObject> S) {
typealias R = a: X.c {
func b<T where g<U, Any) -> T, a<S {
}
let c = b
let x }
}
}
enum A {
}
}
struct c(b()-> T -> Any) {
typealias B<S : String {
public class a<T>() -> {
typealias e == e> T where g: d where T
}(h
extension A {
() -> {
typealias b {
}
}
}
convenience init((T, object2: start: Int = b: d == [Int>({
}
return "foo"[$0
var d = B<T> <T ->) -> String {
d<A, k : b[Any) -> A {
}
}
}
}
extension String {
[unowned self[Any) -> Any in
}
class A {
typealias R
class a {
return "
struct S : c<T where g: AnyObject)
func c
}
}
typealias B>()
let t: start, f<h, let x in x = a<h == "foobar"ab".c((c {
}
func a<T -> Any) -> {
func f<(".c {
class A {
return m(mx : e> {
}
protocol P {
let t.C(self, range.e == c> A {
let i<h == 0
}
return """foobar")
convenience init(i<T, a)) -> {
self)
}
class C(n: e> (B)
})
}
init <T : CollectionType where A<I : 1]
}
protocol b in a {
return NSData()
class A {}
func f)
}
}
class B : a {
}
}
override func b<T> : Array) {
}
var b: A>() {
protocol P {
case s(c(Range(false)
}
}
let c> Any) + seq
enum b in c : a {
let a: A> String) {
}
case s: ()
import Foundation
return b: SequenceType, T : Any) -> U {
switch x }
case s: A {
enum b {
self.c = { self.Type
for c where k) -> {
}
}
}
typealias e {
let foo as String)
class a() -> Bool {
static let n1: B, range.e> {
println() -> : start, 3] as String
case .R
func b: A<3] = [unowned self)) -> {
}
}
typealias B) -> Any) {
public var b[]("]["""
func b: k.E == Swift.A: k.Element>(a() -> {
init(Any) {
protocol c : [B)
convenience init(2, U) {
return self.dynamicType)
}
self[1, c((m: S<3)
}
public var a<l : ExtensibleCollectionType>, x }
convenience init(b, Any) -> {
case s: b(AnyObject) {
public class a(t: AnyObject, f: b = i(Any, A.dynamicType)
return [Byte][Int>
init <h = a)
}
class b()
protocol d : B
}
protocol a {
}
class a {
let b = b: [self, Any) -> (bytes: d = T, a((b<h : T where Optional<T> {
class a : T -> Int -> {
case .b() {
protocol b in x }
typealias F = {
func e?
}
}
}
}
}
super.Type
}
}
var e()->(c: U : b(A<T : Int = e: P {
deinit {
}
struct Q<d>() -> a {
self.A, c
enum b : AnyObject> (A.d>({
e = {
case C: (f<d>() {
protocol A {
println() -> Any) -> {
class func c](seq: $0) -> Int -> T) {
typealias C {
return ""ab".B
}
println()
var _ = b
func a
c
