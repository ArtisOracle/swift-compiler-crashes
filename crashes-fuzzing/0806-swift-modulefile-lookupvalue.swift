// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


enum A {
}
}
case c: Hashable> ()
typealias f = Swift.d
[1)] {
protocol c {
func f<c<T -> e)
class A = A: ("")
typealias e == d()) -> Any) {
}
class B<T](f(B.init()):Any] in
enum b = h, self.d where T>? {
override func compose(""\(s: SequenceType where H.c, e(start, Any) -> String {
func b
typealias R
let t: b()
enum S<Int) -> {
typealias e {
println(self.init())))
struct Q<T.endIndex - range.Generator.count]
}
struct c in return [T>({
typealias e(self..count](p
struct c<T](x: T>() {
for b {
return p
}
func f<T> (s: A<T>(Any) -> Self {
extension NSSet {
return "foo"foobar"a
}
}
struct c(i: AnyObject) -> (self.init(2, 3] = T, (c {
}
func d.count]
}
")
return x }
var e):Any] {
enum a<T -> String
extension NSData {
}
enum b where d.Type) -> () -> {
b: A: d = 0
}
}
}
init(n: l) -> U>) {
}
protocol a {
class B {
}
}
class b)) {
((array: b([]
case b in
func a(Range<(e: 1])
}
func g() {
}
}
protocol b {
class func a<S : Int = F>()
struct c(i> U) {
}
return "cd".a
}
protocol d : d == {
}
func g<h: SequenceType> T where B {
}
}
}
return $0
}
override func b> [0
println(z(1](T> {
enum A {
}
}
}
}
protocol c : Bool].b {
self.e = compose<h : c<U : Int -> : [], U) -> V, x }
import Foundation
}
assert(()] = compose(b.f : A
enum b {
public subscript () {
extension NSSet {
}
}
return x }
case c<1 {
assert()((T: Int>(n: (array: B<S : e == nil
var d>] = b> V {
S(x: d where T {
struct Q<D> T : A> : e(A.C> A {
protocol a {
protocol c {
self[T) -> () {
}
func a({
}
}
println() -> ((B<C(b() -> ()
return "\(b([c, a: A : (x: c<T, Any, A, 3)
extension NSSet {
}
return { x in return ["
}
}
protocol b where H) -> () {
return b
c: b(i()-> (T: Int = e: Int) -> {
extension NSSet {
}
case A> Void>))
func i<Y> Any in
init("foo"
protocol a = b, object2)
}
}
protocol A {
return S(b.e where I) {}
class B {
}
}
println(Any) {
}
}
}
b: B>(() {
}
}
}
println(false)) {
}
func b> a {
func x: T>?
}
}
}
}
case C: S<B {
typealias B()
struct D : Int) {
if true as [unowned self.f = b, f: T> {
struct S) -> String {
}
}
}
}
return [0.e {
return b> {
}
i(.c<d: T
}
case .c == a<d
}
}
typealias B<T>? = nil
func b() -> ()
enum B : A, a() {
}
}
protocol a {
class A {
}
class C(AnyObject> () -> Int {
}
}
import Foundation
}
}
protocol d where B {
}
}
}
var b {
}
}
}
self.startIndex, g == g<T])
func c
var c):
}
protocol d = e: C: X.join(Any) -> d>, i : A<T : (object1: C()
}
}
}
var _ c<d>() -> : AnyObject, Any, e> [1
}
func f: ()) {
}
}
struct c(#object1: b<f == a<T
}
}
public var d where h>
}
}
}
typealias E
}
}
}
case C(n: C> {
}
struct c : A
typealias A = d: c = [c(("")) -> Any, T where A, V, g()
println(t: b(n: A.init() {
}()
extension NSData {
class d.d {
struct D : Hashable> Bool {
}
}
class A {
let t: P {
init() in 0.e = A<T, e: d : l) -> U) -> {
}
let foo as [], U) -> A {
}
protocol b : C {
public var b> U>(A? {
protocol P {
typealias g<j : T
typealias F
}
}
func a<h = Swift.join(f: d == 0
class func b: NSObject {
}
}
class A: Any) -> () {
}
return b
override init(b, AnyObject) -> ()
f)
}
class func c: [0] = e> {
struct S : X<j : X<T>(T>() {
println() {
enum A {
}
typealias b : C = .c = B
func c
struct c<T>(Any, a")
class B<T> : B
var _ = [c])
let c) -> T) -> Any {
func f<A.startIndex)(Any))
typealias f = i: Int) in x in x }
}
}
}
}
protocol A : String {
d()
class func c].a() -> {
let i(((s(a() {
var f : A {
}
return NSData(e
}
import Foundation
}
protocol a : T> T : SequenceType> : c = 0
}
struct Q<l : start, (A? = T.f = g> T>: b = d
}
struct c : A {
}
}
}
typealias B : X<T : A: d = i: T>) -> (true as String)
}
}
}
}
return !
}
}
convenience init<h> T) -> {
class A {
func g> : start: Any) {
func f: a = d>("")
switch x = Swift.advance(b(z: c, f(z: b> {
protocol B : () -> == Swift.endIndex - range.init((array: I.startIndex)
return { c
func a(f: String {
var a(.count]
var c<T -> String {
let h: c {
func b<Int](Any) {
var a
init(start: b(T> {
}
protocol c = 0) -> V {
func b() {
import Foundation
typealias A {
enum S<T
case b where I.c) -> <T> : A, V>?
println(T.C()
return nil
var c())
func b: a {
class c: CollectionType where B {
protocol d where I.E == B<S {
func e: T
b: Int>(Any, x {
}
protocol A {
typealias e = a<T> {
struct e = [0.join(.B : B>() in x = [1, length: B
typealias e = {
}
}
func b: 1][c> : A> T) {
}
struct c {
}
func e("
typealias f : c(n: b<T 
