// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


Type>Bool) -> () -> String {
"""])
}
var d {
func a() -> {
class A {
}
func a(f<h == d: T>()
let foo as String) {
protocol C {
("
func a<I : a {
func d>(AnyObject))) -> ((self, i : Bool) -> {
typealias d
convenience init()
return self.init(start, e: end: CollectionType where I) {
var a(")(self)
}
protocol B : SequenceType> Any, range.C> V {
struct c(a: T> U) {
assert() -> a : A = d
}
class B {
class C
private let i<T : b()():
assert(false)
var b: [c<T>?) {
protocol c where h: Int
}
}
case .C<B : b(b() {
func b(f: b(B<T : Int = nil
func b.d<T where h: String {
func a(c(h, (T>] = [c<(A.Element == F>(A> a {
struct e : B
}
extension String {
typealias g.a)
private let v: A {
}
f == B>, "
func b: a {
var d where k.C(s()
class a: l.advance(bytes: b
var a)(x) -> Any) {
a))
}
class func e?) -> {
func g, x }
class c
protocol A : P {
}
}
typealias F = ")).Element>(f: T>(s() {
public class A<Y> {
var d = b(mx : b<T>("
return { c(a: T: T) -> Any in
typealias R
}
return x }
func a(f(#object1: B<d where Optional<T -> {
enum b {
}
class func g> [T -> T> {
}
protocol b {
}
case C("[Byte]()
struct B<T where B {
enum S(T) -> {
return "
typealias b = Swift.init(array: a {
return b: P {
case b {
}
}
typealias F = c] {
}
class B : d = {
protocol b = h: c: I) -> Int = nil
class A? {
println() -> {
func f<T> Int = [self[T : d {
}
}
}
}
class A {
func e
enum b = nil
struct Q<T> <T) {
}({
enum S(bytes: Hashable> (T: T] {
protocol a {
}
enum S<b> d
}
typealias b {
i> Any) {
func a)
class func b<1 {
i<T) -> [Any, let b {
}
typealias B>(n: P> () -> ("")
}
}
}
}
}
var a
self, T where T, Bool)
}
}
deinit {
}
return "

