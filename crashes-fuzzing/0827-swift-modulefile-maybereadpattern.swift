// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


{
func f() -> {
struct e : String {
}
")
}
}
}
var a(n: AnyObject> A {
enum S<b: k.dynamicType.Type) {
super.advance() -> a {
struct c)
return x }
func c<1 {
typealias B == b(c(a(seq: b: A {
protocol B : A<T] = Swift.startIndex, AnyObject) {
class A : a {
import Foundation
func i()
enum S<T, y)
struct e = B<T where T> T? {
class func g(self)
d) { }
}
}
protocol C {
return z: AnyObject) {}
}
return """)
}
super.A> {
typealias d>? {
return "
if c {
}
return {
return "
var b
protocol b {
b({
import Foundation
return b(Range(x, g = b() {
}
protocol a {
func g<T : A> == [c: c<T : BooleanType, e)-> : String {
typealias E
protocol b = j> U {
}
struct A? = { c: A, e<T: A> V>(n: S<T) {
}
let c] = b: AnyObject> () {
}
return b(g> String
}
}
}
S<h == c]
}
let v: C {
}
}
}
func a() {
return nil
var f = D> () -> : String)?
}
}
}
}
let t: A, e {
typealias F
self.E == f.Type) { x }
var f(a(2, U>(true as [Any, y)
var b<T, A {
}
}
}
func f<T>(v: U {
A..Generator.C(b([1
extension NSSet {
println(x, V>(T>() -> {
}
func c<T {
}
}
}
}
return {
protocol A : T>]
case b {
func i> Any) {
protocol b where A) -> T where S("foo""
class A.advance() {
func a)
}
func f: A<(T> : b) -> A {
extension String {
typealias F = compose() -> {
struct Q<U) {
}
protocol A {
var e: C {
}
case s: Any) {
public var f = 1
var _ c, let h: A = ["
func b: Hashable> String {
func a
return self.init(f(#object1, end: SequenceType> {
}
}
class B<D> (c> T, range: T>() -> a {
var c
}
return nil
class A, f)
c() {
return """"")
convenience init<U {
return self.B<T : BooleanType>(A
}
})
self.g : I.init(seq
var d where g, f():Any) -> T
class a {
var d == A"")
}(x)() -> a {
}
var a: B
}
enum B {
}
class b> {
}
class a
}
return z: a {
func b: C(T
}
import Foundation
class b()")(e(start, T
}
}
enum b in
enum b {
func b.A? = j> (Any) { _, (2, d.c(t: [B<T>)
}
enum a: String {
println(T>] in
typealias A {
}
}
import DummyModule
typealias B<B == { }
}
var _ = j> (f(A<c) -> A = a
}
println() {
}
}
A? = {
protocol B : c = c: SequenceType> T) -> a {
b: BooleanType>()?
return ")
class func b<l : b(A, obj
