// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


A : BooleanType>()
}
protocol C {
S) {
func e<1 {
})
enum A {
class A, Any) -> {
return nil
}
}
extension NSData {
for ([[c
let i> {
init() -> {
typealias C {
let d.substringWithRange(start, range.advance(true {
}
class a()
return g<C
class A<T) -> (x, B<d<T, g()) -> : b : 1))
}
typealias e: a {
class a {
}
0.C(h> V>(Any, q:
}
protocol a : (#object1, T> Any) {
protocol b where S() {
case .d) {
if c = 1]
}
class A {
typealias B>) -> ()
}
var _ c<T! {
e : e> [")
typealias e : SequenceType, x {
}
typealias d
protocol a : 1)] = b> (i<Q<f = 1]("\(object1: d : a {
return [$0) {
var b where k..E
init<T, 3] {
}
let h
func f())
class A> {
protocol A {
let end = b(AnyObject) {
return d>Bool) {
}
extension NSSet {
func e? {
deinit {
self] = true as [1
init <d = [B<T) {
return ","
var d : [c() -> Any) {
protocol A {
return $0) -> ("["")
func f<T] == [c
}
case c<Int>)
typealias R
}
}
switch x in 0
}
protocol a {
class func f(b
enum b {
protocol a {
case b {
protocol a {
func e: P {
}
enum B {
func i> Any) -> : ()) -> V {
}
func e, i : B(h.join(t: T) {
import Foundation
}
}
func g, e()?
enum a<I : c: b = nil
}
protocol b {
}
}
func b
return [Any, end)
}
}
typealias F = d
func a: NSObject {
}
var b where B : B, y: e: A, V>Bool) + seq
}
func e, V, (start, T>?
return self..A(c = compose() -> {
struct S : Int
typealias e(a<c<T, g<T, end: 1)) -> U -> {
let foo as [1)
}
}
func c()
protocol b {
}
}
class A {
}
}
return true
println((a(T] = true {
func f<T : T>(t: c {
c, c(object1, self.f = ")
typealias f : d {
}
