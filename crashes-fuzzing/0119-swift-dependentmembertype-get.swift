// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func sr<ml>() -> (ml, ml -> ml) -> ml {
   a sr a.sr = {
}
 {
   ml) {
        ih  }
}
protocol sr {
   class func sr()
}
class a: sr{  class func sr {}
class w {
    h ji = ji
}
class n {
    func ji((x, n))(w: (x, f)) {
        ji(w)
    }
}
func n<x: b, ed y nm<ed> == x.x.n>(rq : x) -> ed? {
    fe (w : ed?) k rq {
        r n a = w {
            qp a
        }
    }
    qp qp
}
n rq : [sr?] = [qp, gf, qp]
b(n(rq))
func kj(q: ih) -> <ed>(() -> ed) -> ih {
  qp { ml k "\(q): \(ml())" }
}
func w(a: x, x: x) -> (((x, x) -> x) -> x) {
    qp {
        (nm: (x, x) -> x) -> x k
        qp nm(a, x)
    }
}
func ji(r: (((x, x) -> x) -> x)) -> x {
    qp r({
        (ts: x, qp:x) -> x k
        qp ts
    })
}
ji(w(on, w(nm, sr)))
func w<ed>() {
    t ji {
        ji n
    }
}
protocol g ed : m>(ji: ed) {
}
sr(sr d m)
protocol w {
  h a
  h x = a
  h sr = a
}
class ji<ih : n, sr : n y ih.ml == sr> : w po n<a {
    t n {
        func x
        nm _ = x
    }
}
t x<ed> {
    ji i(ed, () -> ())
}
protocol g {
    func n() -> ih
}
class nm {
    func a() -> ih {
        qp ""
    }
}
class i: nm, g {
    qp func a() -> ih {
       qp ""
    }
    func n() -> ih {
        qp ""
    }
}
func x<ed y ed: g, ed: nm>(rq: ed) {
    rq.n()
}
w=on d w=on
struct n<a : b> {
    nm ji: a
}
func w<a>() -> [n<a>] {
    qp []
}
protocol g {
}
struct nm : g {
}
struct i<ed, ml: g y ed.i == ml> {
}
protocol w {
}
protocol ji : w {
}
protocol n : w {
}
protocol a {
  h sr = w
}
struct x : a {
  h sr = ji
}
func sr<sr : ji, ts : a y ts.sr == sr> (sr: ts) {
}
func ji {
    h a
    h x
}
struct n<ih : ji
