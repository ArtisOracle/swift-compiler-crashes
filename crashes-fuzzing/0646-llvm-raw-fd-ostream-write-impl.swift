// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing


func b
protocol C {
deinit {
struct e == { x in a {
let d
return [unowned self.e {
class A {
func compose<U : e where A? = B<C> {
override init(b.init() -> {
protocol e where H.c = 1: d = nil
var f: B) {
}(false))
if c == F>(f<T.e where H) -> : Int -> U, e: Array) -> S()?
override init()
println()
}
}
}
let c>() {
let t: C {
init(x: A.B(")(false)
typealias R = { c: String = {
}
init <T> V, object2: P> {
}
}
}
c: B? = b
}
return nil
func g: Int
}
let g = b<() -> U, V>(()
}
self] in
let h = c) {
func a
override init()-> : A? = B<T>(t: B<T {
}
private class d
}
}
func a
}
protocol e where H.c == 0)
return self)
}
if c = a(x: B? {
func g, U)
}
import Foundation
c: String {
}
return d.Type) {
func a() {
}
typealias F>Bool)
let v: A.c: AnyObject) ->>)(self.E == {
enum S<T where H) {
var f = nil
return self.init(e: A"
protocol P {
}
class B : A>>(self)
}
static let i: NSObject {
}
}
e : U : H) -> {
var d = nil
}
typealias e = compose<T! {
}
let a {
}
}
typealias e : e, 
