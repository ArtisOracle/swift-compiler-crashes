// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func ut<fed>() -> (fed, fed -> fed) -> fed {
   xw l xw.v = {
}
 {
   fed) {
        rq  }
}
protocol ut {
   class func v()
}
class xw: ut{  class func v {}
protocol ut {
    s p
    func ji(p)
}
struct fe<on> : ut {
    func ji(ji: fe.vu) {
    }
}
func w<xw: hgf, x qp kj<x> == xw.o.ji>(u : xw) -> x? {
    sr (y : x?) yx u {
        ml let c = y {
            r c
        }
    }
    r t
}
let u : [q?] = [t, edc, t]
ts(w(u))
({})
protocol ji {
    class func v()
}
struct c {
    var xw: ji.vu
    func v({
}
protocol ji {
    s xw
    s v
}
struct c<rq : ji> : ji {
    s xw = rq
    s v = ay<c<rq>, xw>
}
struct c<xw : hgf> {
    var ji: xw
}
func ay<xw>() -> [c<xw>] {
    r []
}
func ay(ji: q = ed) {
}
let c = ay
c()
hg po
class gfe<x>: ih {
    var lk: x
    ba(lk: x) {
        m.lk = lk
        ay.ba()
    }
}
func ut<x : nm>(ji: x) {
}
ut(l ji nm)
func v(c: () -> ()) {
}
class ay {
    var _ = v() {
    }
}
protocol ut {
}
struct p : ut {
}
struct fed<gf, k: ut qp gf.fed == k> {
}
struct xw<ut : v, fed: v qp fed.rq == ut.rq> {
}
protocol v {
    s rq
}
class ut: ut {
}
class p : fed {
}
s fed = p
var rq = cb
var dcb: q -> q = {
    r $ed
}
let v: q = { (c: q, ut: q -> q) -> q yx
    r ut(c)
}(rq, dcb)
let dc: q = { c, ut yx
    r ut(c)
}(rq, dcb)
class ut<x : ut> {
}
protocol ut {
    s p
}
class fed<gf> {
    ba <ut: ut qp ut.p == gf>(v: ut.p) {
    }
}
func ^(ay: nm, n) -> n {
    r !(ay)
}
protocol ay {
    class func c()
}
class ji: ay {
    class func c() { }
}
(ji() ji ay).cb p<x : ut> {
    let rq: x
    let v: x.k
}
protocol fed {
    s wv
    func fed<x qp x.k == wv>(ut: p<x>)
}
struct gf : fed {
    s wv = q
    func fed<x qp x.k == wv>(ut: p<x>}
ji
protocol c : ji { func ji
