// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
protocol a {
struct S<T : S<C> U, self.startIndex)
class C) {
import CoreData
}
default:
class func i: Bool](#object1: Array) -> {
}
struct A, i : A>? {
self.h == g
func a)
protocol a {
let c: C {
protocol a {
}
self[c> (object1: a {
}
}
func a: Bool)
return ""
struct B>()
struct c = {
let d<d.c {
struct X.startIndex)
func a<l : Array<T) {
class B : ({
})
}
func c: T, A, T where T
}
protocol b = b
}
typealias b = Swift..init()(a: () -> T -> {
}
struct c, self.Generator.g = {
}
}
class func a: B
protocol b = g: B, a(g
}
protocol C {
func i() {
return {
}
assert(A.R
return m: b.init(a() -> {
super.e where f<d where T) {
struct c = {
class a = a)
func a: A","a!
enum b in
}
}
class a: e<D>(c: A? {
struct c() -> Self {
}
assert(Any, U) {
protocol a {
}
class a {
protocol b {
}
}
}
return "")
("
}
case .c {
}
}
println(A, T -> Any) ->) as BooleanType)
}
class func b> == { c<T>) {
}
()
"
struct A..substringWithRange(B
}
return b<f : Int {
if true {
i(a().Generator.a: A {
}
import Foundation
func a)
(T! {
}
case A.<T : T
typealias e = true }
let d, B
protocol d {
struct D : 1]
}
let i() {
}
}
import DummyModule
}
return g<T] == [0] == { c(true as BooleanType, 3)
}
let c) -> {
let d
typealias e : () {
class A {
let d.B {
init() {
case c<T>()
public var a)
func f: b("]
println("A<h: k.a: a<d(A> () {
if true }
}
case b = b() {
}
() ->((object1: C = [Any) + seq
typealias d
import Foundation
}
}
case .<h : A
let g == c
protocol b {
protocol b where T : A> e: a {
}
func b)
}
class func f([[Int>>) {
}
typealias A where T, i : NSObject {
}
struct c: a {
typealias f = A, let start = c: d {
}
}
typealias d = [Any, AnyObject) -> String {
0) -> String {
}
func a: B<T where d<h == true {
}
let n1: d where d
}
enum A {
protocol B : A<T>([1)
import Foundation
return ".endIndex - range.B<d<T
}
}
let x }
}
}
struct D : T)
}
}
case .R
}
}
}
}
let c: (t: P {
extension A {
func b: B<b
}
}
get
}
a: d :
