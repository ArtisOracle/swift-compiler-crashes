// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

let v: d = nil
class C<T>
func b() as a
protocol B : P {
}
enum k {
}
func a
let g = nil
var _ = j
func g: C<T) -> {
struct B<A? = {
case c: A : A<C<T where B {
class
enum k {
class A<A<T.c
struct d<T where B : H.c: Int = {
case c
func j
protocol B : C<l : A {
class
case c,
let c
let g = b() -> V {
func a<T.b : d = nil
}
}
protocol B : A? {
}
{
}
struct B<T where T where T where T : a {
func a<h
class C<C<C<h: C
func j
}
struct B<l : H.init<A<C
class A : P {
struct B<T where B {
struct B<T
func a() {
class d<T) {
"\(t: A {
}
class A? {
func b() -> {
let g = nil
let a {
class A {
}
enum k {
class
case c,
protocol k : Int = b
let g = {
func g: A? {
protocol B : Int = f
if true {
func b
if true {
let a {
case c
func g: H.b : A.c: C
class A<T where g: A {
let c
var _ = nil
if true {
class
func a() {
func a<T where T where T where g: a
}
class A.b : a {
func a
var _ = nil
}
func j
if true {
{
}
}
class C<T where g: d = {
let g = {
let g = nil
let v: A? = b() -> V {
func a
}
() -> {
protocol k {
enum B : b: A {
protocol k {
func a<h
func j
if true {
func b(t: d = nil
let a {
}
class d<C<T where B : b: h { func a(t: Int = f
class C<T.c
let v: a {
let c: C<A? {
}
func b: Int = nil
class
() -> V {
class A : d = {
"\() -> {
protocol B {
protocol B : a {
class C<T.c
func a<T : b
func a<C
protocol B : A<T.b : H.c
let v: b: Int = {
var _ = f
case c: a {
func a<T where T where B {
protocol k {
() -> V {
class d<l : P {
protocol B : A? {
class A : A {
class C<T
if true {
let v: C<T
let c: A : h { func a<T) -> {
var _ = {
struct B<T where T : A : A.c
let c
struct B<T.b : P {
class d<T>
}
enum k : H.c
struct B<T where T where I.b : h { func b() -> V {
}
func a<T.b : Int = nil
func b: A {
protocol k {
class
}
{
let g = {
enum B {
case c,
{
struct d<T
class A {
case c
class C<C<T>
protocol B : P {
struct d<T>
case c: P {
func a<T
enum k {
protocol k {
let c: P {
struct d<T where g: d = f
var _ = nil
}
class C<T where g: A.c,
func b: C<T) {
let v: Int = {
() as a<T
}
protocol k : h { func b
case c,
struct B<T>
protocol B : a<T.b : b: d = j
let a {
if true
