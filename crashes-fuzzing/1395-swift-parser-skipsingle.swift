// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

tIndex)
protocol A : d {
func d
self.a: A> Any) {
struct e == nil
}
}
class A {
class A> Int = B
class func e<(1], B? = {
class B = Int
protocol a {
public var d() -> S.d, length: C
case A.Type) {
}
class A""cd"a(B, i : e(a!
import Foundation
}
var b((AnyObject, AnyObject> {
class A, g == b()
override func b(e!.<T>(Any) {
a: a {
let d: Bool) -> {
case .d>(.b = b: (c())()
enum b {
protocol b {
struct A {
var b {
}
private let h> () -> {
typealias h: Any)
public class c: Any, Any) -> Any, () -> : b where T where h: ()) {
public subscript () -> ("
var b, g = c(T, c>]() -> S(f()] as [unowned self.b.g = A? = B
enum b where g(e> (A> Self {
typealias f == A) {
case s: AnyObject)
class c
class a(() -> {
t: String)(f, y: CollectionType where g: Array) {
protocol c = [Byte].dynamicType)) + seq
}
switch x in x }
println((h: (.B
protocol A {
class A : A: Any))
func e, T -> String {
}
func a(A.f : T, x in a {
}
let foo as String
struct A {
}
}
}
super.C: d = b(self)
}
}
class a)
typealias C {
enum S<S : c() + seq: B, T where A, x in c = i> U) -> {
d
}
}
(self.a(A, length: Any] {
}
enum A {
protocol a {
func b> V {
}
}
}
import Foundation
protocol A : $0.c where g.E
}
protocol b where S<T : String) -> (Any, b : a<U : A, x }
protocol C {
}
}
}
}
}
}
}
let c> Self {
}
}
case .b {
typealias e == c
typealias A {
}
class A, range.h == a: Any) -> : ExtensibleCollectionType>() {
typealias F>? = b, AnyObject, T>) {
func x) {
public var b {
}
}
}
self.e, range.R
protocol A {
import DummyModule
public var a()?
var e> ()
typealias E
protocol A {
case A, i : A<T>(T> T) {
private let v: $0] = [1]
}
struct D : A: U)) -> == Swift.e == B) -> Any, f<T -> String {
}
}
enum B == nil
struct e : A<j : S(Any) {
var d where T> {
}
var f<U : AnyObject.init()
assert(range: Array<T> T, () {
}
[unowned self.B
class func d() -> T) {
}
struct c(#object1: AnyObject)(m: AnyObject, self.Element == B))
protocol b in
typealias B {
f: B<D> (c<T>(T: T) -> e(c: Any) -> : ExtensibleCollectionType>() { c, Any) {
init(self.advance(#object1: T>()
let c() {
enum a)
