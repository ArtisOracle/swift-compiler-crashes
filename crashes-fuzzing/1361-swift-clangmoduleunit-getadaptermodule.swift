// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

import Foundation
}
}
func a)
struct B(""")
func a(T: I) -> U) -> {
}
return g() {
}
self.join({
}
var f = [0x31] = Swift.init() -> () -> {
func f(x)
}
}
}
}
func f<3] as BooleanType>() -> String {
var b()
protocol C {
}
struct c == { x }
convenience init(B? = true {
typealias e = [")
class a {
}
protocol a {
func b.advance() as BooleanType, range.init() {
}
}
}
}
extension NSSet {
func e: U) as a({
self[0) {
}
func compose(b
protocol b in
class c = g<D> Any {
assert(b.c: X<j : T: a {
protocol A {
}
protocol e == Int
enum S<T? {
var d where S) -> T>(T] in
super.A>():
let f : a<Int>](f<f == f.c = g<Int>() -> {
func c][B<T>(true {
var b where A, Bool) -> T) -> T {
}
}
}
return """)) {
typealias b {
}
return ".<T>] = B<I : Any, AnyObject.dynamicType.B {
func compose<U {
struct S : a {
return m(#object1: (start: b where d
enum a
}
}
private let f = A<T>
protocol a {
convenience init<c: a : k.startIndex))
class A {
}
}
enum S(t: P> (() {
let c] = [1, self.b = i: P> (t.a<I : A")
super.Type) -> <T> (self.Element == F
}
}
(start: a()
import Foundation
enum b {
import Foundation
}
}
return NSData((x() {
}
func a!() {
}
typealias f : a {
struct D : Range():
class A, i() -> V {
let h> a {}
}
}
}
case b = c(A.C()
return p
class A {
enum b = [unowned self, 3] {
}
}
}
func compose(T) -> {
class C() {
}
class A {
typealias f = j> U : T, range.c in a {
}
for b where I) {
class b()
}(c(c == e() {
class B {
typealias R
func g: d
}
d<f : 1)
protocol P {
}
func call(true as a: Any) -> : b {
return {
}
protocol A {
}
let v: CollectionType where H.a!)
}
self.C() {
func f<b: AnyObject) ->(f.a: c {
}
}
}
class B
var e()
}
}
let end = { x = b
class b, T : b: Int>(x() -> T -> T {
b[Byte](")(.init<j : b.d<T)
func a
var b = a)
}
fun
