// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

{
}
class c {
protocol d == b(f: b {
protocol a {
a
var b
}
}
typealias f == c) -> String {
func e(a: BooleanType>() -> {}
if c {
var _ = d: c) -> String = true as String
import Foundation
func i: b
protocol b in
}
}
protocol P {
}
class b.a(start: a {
extension A {
protocol d where d("")
func c<c()()?) -> Void>("](T> {
deinit {
let i<Q<T, Bool) -> U>()
return $0
enum S<T>(g<3] as [self[], q:Any, k : Int -> : A? {
func i: String)
return b> : b: BooleanType, e?
return !.init(x: A {
}
typealias B : String {
enum b {
typealias d {
}
}
}
return [](object1: P {
protocol A {
var f : P {
private let d
protocol b = 1])
class A>("cd""
let c = b
class B == j> Any) -> {
d>: B<B == 1])
func a(true {
}
let d
self[[1])
var e> {
f = {
enum a
protocol d where Optional<T, g<(g
enum a()
}
}
func f: B>(".count]
extension NSSet {
case b where I) {
return nil
}
class C(")
}
}
var b.b<T>
typealias F = T, range.E
a
func d
class func g: String) {
case b = Int](i> (([]
}
class func a: A {
typealias E
return {
}
func b
let v: A {
}
let start = F
}
class A, i : P {
b(start: end)
}
protocol a {
}
var b<T, Any) -> String {
struct A.advance(self..<d<T {
println((n: (A<h> {
init() -> [1]](b() {
typealias e
typealias b where Optional<f == .b(n: Int>(.a(bytes: d = B(p: () -> (f, V, A: NSObject {
}
}
}
typealias B)
}
deinit {
}(").C(f: e: b: 1
return p: C(n: 1]
0] {
}
return b))
}
}
}
var d(i(n: T.a(")
var e
typealias R
func a"\(e: 1))"ab""
