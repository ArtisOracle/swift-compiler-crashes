// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

struct S<h: d where T : b> {
let c {
}
}
}
enum A {
func i<T) {
import Foundation
}
println() {
var b())
}
}
}
}
func d(T>(n: Int>>(")
}
}
0
return nil
}
class B {
}
}
println((seq
class A, T where h: C {
return self.init(T>?) as [c(e(A<S : B) -> Any {
}
convenience init(#object1, "))
A) {
}
}
}
}
}
b> (array: 1], e where T : AnyObject.g : () -> [unowned self.count]
let a<(1
public class d.init<T>(n: d {
typealias A {
enum A : c() {
return "
class C())
}
}
}
}
protocol a = F
}
var b : BooleanType)
class A {
assert()
t: I.startIndex)] as String)
struct e == compose<f = i<Q<B : Array<D> Self {
}
func call(A, V, x in c {
struct e where A, y: SequenceType> {
println(i: a {
var b<T].b: b
}(T? = {
func b: b
typealias f = i()
}
protocol d {
struct X.e == b() in 0
typealias b {
println() -> S..Type) {
class A, A, g<T, x }
protocol P {
typealias B
func ^(n: a {
import Foundation
let start = { c, 3)
f<T>("
(.init([0x31] = ..<T.c) {
}
}
return $0.B.c<S {
public var e> : c<T) -> {
func call() {
}
}
let c {
}
func g<1 {
f == a
return [c, d.b : T>>()
class d>(A> () {
return """)
}
}
b(A, length: d {
[Any, let t.A<T]
}
}
let foo as String)
let a(A.d.<T -> T where l.A: SequenceType where A> (self.B
return "\(b: C(T>>() {
protocol a {
assert())
}
extension Array {
}
struct A {
class c: P> (b> U {
}
assert()!(")
init<T>(x: S) {
