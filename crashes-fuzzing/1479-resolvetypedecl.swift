// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
protocol P {
let t: B>) -> {
class A<T: d {
}
protocol c in return $0) {
func g: A, range.dynamicType)
private let h : Int -> [0)((n: end: A> Any in
}
func f.startIndex)
})
assert()
class A>(")
class B {
var c> () -> (f(AnyObject) -> (range.dynamicType)"
class func f: P {
struct Q<T>()
}
func c<T -> Void>()
}
}
}
var _ c: A<S {
protocol P {
func f(b: T) {
}
override func d
var _ = [T
d
func c
protocol A : C {
protocol a {}
}
[1)
}
}
}
import Foundation
typealias A where k.a<T : A, length: () {
init()
func g> == nil
assert() -> {
return NSData() -> T : d = T> T
func a: B
}
}
import Foundation
extension NSSet {
import Foundation
func d>(")
}
}
}
println(s: B, object2)"a<T>(""\({
return !))
}
typealias B<Int][0x31] {
func b: T: AnyObject)
}
println()
import DummyModule
class func f: Any) {
}
protocol b : P {
if c {
}
println(x, i : String {
}
import Foundation
}
switch x {
}
var d {
case C(m(x, let i: (T) -> {
d<d where H.<T) -> : Bool]
}
func a<T>, B(#object1: P {
b
}
}
}
class B : NSObject {
init(n: (seq
func e> Any in
}
}
typealias B : B, Any) -> {
case .h: Bool], end: b(c, x in x }
import Foundation
import Foundation
protocol b : A : k.c = b[Any)
func b: ExtensibleCollectionType>(self.count]
protocol d where f(b> {
assert():
}
func f<T>() {
case b = b(e<l : d {
class A<T: CollectionType where g<T> (g
}
let x }
struct X<h : U) -> {
}
}
var e> T> {
protocol A {
case C
}
func b
private class A {
return b(A.count](A.b = B
enum A {
extension Array {
class A {
func b(f(T>>) {
import Foundation
var e(x)
class b<D>() -> : A, "")
func call(false)
struct S.startIndex, Bool](() -> Bool {
convenience init<l : AnyObject, A where h
f<T: U)) {
return { c][1]], e(i()
}
}
}
}
case .dynamicType.C() {
extension String {
}
enum a<T : NSObject {
func ^(false)(range: c
typealias B, V>: Array) -> String) -> Any) -> Void>(b) -> {
}
typealias e : T>(a: d = B.dynamicType.Element == B<T, b = """foobar"
class c<Int
}
typealias F
}
}
}
convenience init<T.Type) {
}
func g.Type) {
self.a: c((self.f = j> (a: B("
typealias e = a
class b
var a: B) -> 
