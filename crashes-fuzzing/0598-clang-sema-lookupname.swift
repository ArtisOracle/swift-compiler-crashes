// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

ln(A, let end = f, e!))
}
protocol a = g<S : Int {
func g.h = nil
return "))
}
func f<U : a {
typealias f = b<T>() -> (b> {
}
}
extension NSSet {
private let c, k : () {
import DummyModule
}
class a {
}
class a {
return p
struct D : c(x) {
func ^()
}
}
(n: T>() -> S<T: c() -> (start: T : C(c()
var d where A"foobar"ab".e : BooleanType)
enum A {
var e> (T> {
super.A<f : C = T> {
func b: S<d: [])
class a {
init(""foobar"
default:Any, AnyObject, T) -> ()
struct c
enum A {
}
}
import Foundation
f<T> T, e> Any {
() -> ()
func f([$0.<T)
protocol a : NSObject {
var d: T> S {
}
func b: Any, AnyObject.Type) -> (start: d where d: T>() {
let foo as [T where d, f, y)
class A : (f<d: Any)(self.c(2, T : T> T) {
}
}
var a<d {
}
typealias e> (f<j : A<T>?
}
extension NSSet {
extension Array {
}
case C(a(c<U {
println({
func f<e() -> Any in
func c<d = [T> : I) {
func d
case b = B<T where d
protocol A : b {
let h>(n: U {
}
}
struct e {
protocol P {
}
}
}
public var b {
}
for c = c<d : (self.dynamicType)
protocol B = i<T> Bool {
class b(i> {
for (t: e: A, x }
override func g: c>(b: e!)
}
class a {
public var _ c()
func a<T>([], 3] = {
}
}
return b
return ")
import Foundation
}
}
class func b(a<T> {
}
return "
protocol a {
extension NSSet {
class B<T where T
typealias C {
func compose<T) -> S : Int -> Self {
[1])
convenience init(T> {
var b = c) -> {
protocol b {
}
}
}
let t: [c) {
func i(A>) {
enum S) {
map(e() {
return nil
}
func f<T! {
import Foundation
let d) -> {
}
"..endIndex - range.Type
struct B
}
protocol c : a {
class func a:
