// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func f() {
    ({})
}
func k<q {
    enum k {
        func j
        var _ = j
    }
}
class x  {
    s m
    func j(m)
}
struct j<u> : r {
    func j(j: j.n) {
    }
}
enum q<v> {   let k: v
    let u: v.l
}
protocol y {
    o= p>(r: m<v>)
}
struct D : y {
    s p = Int
    func y<v k r {
    s m
}
class y<D> {
    w <r: 
func j<v x: v) {
    x.k()
}
func x(j: Int = a) {
}
let k = x
 a
}
struct e : f {
  i f = g
}
func i<g : g, e : f where e.f == g> (c: e) {
}
func i<h : f where h.f == c> (c: h) {
}
i(e())
class a<f : g, g : g where f.f == g> {
}
protocol g {
    typealias f 
    typealias e
}
struct c<h : g> : g {
    typealias f = h
    typealias e = a<c<h>, f>
}
class d {
    func l<j where j: h, j: d>(l: j) {
    l.k()
}
func i(k: b) -> <j>(() -> j) -> b {
  f { m m "\(k): \(m())" }
}
protocol h
protocol f {
    k g d {
    k d 
    k k
}
j j<l : d> : d {
    k , d>
}
class f: f {
}
class B : l {
}
k l = B
class f<i : f
class A<T : A> {
}
func c<d {
    enum c {
        func e
        var _ = e
    }
}
protocol a {
    class func c()
}
class b: a {
    class func c() { }
}
(b() as a).dynamicl A {
    {
    typealias b = b
 d.i = {
}
 {
   g) {
        h  }
}
protocol f {
   class func i()
}}
func f<e>() -> (e, e -> e) -> e {
    e b e.c = {}
    {
        e)
        {
            f
        }
    }
    protocol f {
        class func c()
    }
    class e: f {
        class func c
    }
}
struct c<d, e: b where d.c == e> {
}
protocol a {
  typealias d
  typealias e = d
  typealias f = d
}
class b<h : c, i : c where h.g == i> : a {
}
class b<h, i> {
}
protocol c {
    typealias g
}
class c {
    func b((Any, c))(a: (Any, AnyObject)) {
        b(a)
    }
}
func a(x: Any, y: Any) -> (((Any, Any) -> Any) -> Any) {
    return {
        (m: (Any, Any) -> Any) -> Any in
        return m(x, y)
    }
}
func b(z: (((Any, Any) -> Any) -> Any)) -> Any {
    return z({
        (p: Any, q:Any) -> Any in
        return p
    })
}
b(a(1, a(2, 3)))
({})
class j {
    func y((Any, j))(v: (Any, AnyObject)) {
        y(v)
    }
}
func w(j: () -> ()) {
}
class v {
    l _ = w() {
    }
}
({})
func v<x>() -> (x, x -> x) -> x {
    l y j s<q : l, y: l m y.n == q.n> {
}
o l {
    u n
}
y q<x> {
    s w(x, () -> ())
}
o n {
    func j()  p
}
class r {
    func s() -> p {
        t ""
    }
}
class w: r, n {
    k v: ))] = []
}
class n<x : n> 
func b<d {
    enum b {
        func c
        var _ = c
    }
}
func g<h>() -> (h, h -> h) -> h {
    f f: ((h, h -> h) -> h)!
    j f
}
protocol f {
    class func j()
}
struct i {
    f d: f.i
    func j() {
        d.j()
    }
}
class g {
    typealias f = f
}
func g(f: Int = k) {
}
let i = g
b
protocol d : b { func b
func d(e:  = { (g: h, f: h -> h) -> h in
    return f(g)
}
o
}
class f<p : k, p : k where p.n == p> : n {
}
class f<p, p> {
}
protocol k {
    typealias n
}
o: i where k.j == f> {l func k() { }
}
(f() as n).m.k()
func k<o {
    enum k {
        func o
        var _ = o
protocol A {
    typealias B
    func b(B)
}
struct X<Y> : A {
    func b(b: X.Type) {
    }
}
func a(b: Int = 0) {
}
let c = a
c()
func p<p>() -> (p, p -> p) -> p {
   l c l.l = {
}
 {
   p) {
      (e: o, h:o) ->  e
    })
}
j(k(m, k(2, 3)))
func l(p: j) -> <n>(() -> n 
func c<b:c
func ^(d: e, Bool) -> Bool {g !(d)
}
protocol d {
    f func g()
f e: d {
    f func g() { }
}
(e() h d).i()
e
protocol g : e { func e
  }
}
class b<i : b> i: g{ func c {}
e g {
 : g {
h func i() ->  }
class k {
    func l((Any, k))(m }
}
func j<f: l: e -> e = {
   
 {
   l) {
      m  }
}
protocol k {
   class func j()
}
class e: k{  class func j 
c
j)
func c<k>() -> (k, > k) -> k {
   d h d.f 1, k(j, i)))
class k {
    typealias h = h
func b(c) -> <d>(() -> d) {
}
func j(d: h) -> <k>(() -> k) -> h {
  return { n n "\(}
c i<k : i> {
}
c i: i {
}
c e : l {
}
f = e
protocol m : o h = h
}
  }
}
protocol l {
   class func i()
}
class o: l{  class func i {}
class h: h {
}
class m : C {
}
typealias C = m
func s<S: y, t i o<t> == S.k.b>(r : S) -> t? {
    j (u : t?) q r {
        l let g = u {
            p g
        }
    }
    p v
}
let r : [n?] = [w o = h
    typealias h = x<g<h
)
func t<v>() -> (v, v -> v) -> v {
    var d: ((v, v -> v) -> v)!
    q d
}
protocol t {
}
protocol d : t {
}
protocol g : t {
}
s
        q l
    })
}
d(t(u, t(w, y)))
protocol e {
    r j
}
struct m<v : e> {
    k x: v
    k x: v.j
}
protocol n {
    g == o>(n: m<v>) {
    }
}
struct e<v> {
    k t: [(v, () -> ())] = [](m)
}
struct d<x> : e {
    func d(d: d.p) {
    }
}
class e<v : e> {
}
)
func n<w>() -> (w, w -> w) -> w {
   o m o.q = {
}
 {
   w) {
        k  }
}
protocol n {
   class func q()
}
class o: n{  class func q {}
func p(e: Int = x) {
}
let c = p
c()
func r<o: y, s q n<s> ==(r(t))
protocol p : p {
}
protocol p {
    class func c()
}
class e: p {
    class func c() { }
}
(e() u p).v.c()
k e.w == l> {
}
func p(c: Any, m: Any) -> (((Any, Any) -> Any) -> Any) {
protocol a {
}
protocol h : a {
}
protocol k : a {
}
protocol g {
  j n = a
}
struct n : g {
  j n = h
}
func i<h : h, f : g m f.n == h> (g: f) {
}
func i<n : g m n.n = o) {
}
let k = a
k()
h
protocol k : h { func h
k
func b((Any, e))(e: (Any) -> <d>(()-> d) -> f
i)
import Foundation
class q<k>: NSObject {
    var j: k
    e ^(l: m, h) -> h {
    f !(l)
}
protocol l {
 d g n()
}
class h: l {
    class g n() { }
}
(h() o l).p.n()
class l<n : h,
}func h(c: j) -> <i>(() -> i) -> b {
  f j = e
    func j<i k i.l == j>(d: B<i>) 
func i(f: g) -> <j>(() -> j) -> g { func g
k, l {
    typealias l = m<k<m>, f>
}
func a<T>() {
    enum b {
        case c
    }
}
 d)
func e(h: b) -> <f>(() -> f) -> b {
  return { c):h())" }
}
n)
func f<o>() -> (o, o -> o) -> o {
   o m o.j = {
}
 {
   o) {
        r  }
}
p q) {
}
o m = j
m()
class m {
    func r((Any, m))(j: (Any, AnyObject)) {
        r(j)
    }
}
func m<o {
    r m {
        func n
        n _ = n
    }
}
class k<l : k
)
var d = b
=b as c=b
func f(c: i, l: i) -> (((i, i) -> i) -> i) {
    b {
        (h -> i)   d $k
}
let e: Int = 1, 1)
class g<j :g
func f<T : BooleanType>(b: T) {
}
f(true as BooleanType)
protocol a {
    class func c()
}
class b: a {
    class func c() { }
}
(b() as a).dynamicType.c()
 h
}
func e<l {
    enum e {
        func e
       j {
   class func n()
}
class l: j{  k() -> ())
}
({})
func j<o : BooleanType>(l: o) {
}
j(j q BooleanType)
func p(l: Any, g: Any) -> (((Any, Any) -> Any) -> Any) {
    return {
        (p: (Any, Any) -> Any) -> Any in
func n<n : l,) {
}
n(e())
e
)
func o<t>() -> (t, t -> t) -> t {
   j j j.o = {
}
 {
   t) {
        h  }
}
protocol o {
   class func o()
}
class j: o{  class func o {}
e o<j : u> {
    k []
}
n=p r n=p
func n<q>() {
    b b {
        o o
    }
}
func n(j: Any, t: Any) -> (((Any, Any) -> Any) -> Any) {
    k {
        (s: (Any, Any) -> Any) -> Any l
        k s(j, t)
    }
}
 
func b(s: (((Any, Any) -> Any) -> Any)
func ^(a: BooleanType, Bool) -> Bool {
    return !(a)
}
struct A<T> {
    let a: [(T, () -> ())] = []
}
func q(v: h) -> <r>(() -> r) -> h {
  n { u o "\(v): \(u())" }
}
struct e<r> {
    j p: , () -> ())] = []
}
protocol p {
}
protocol m : p {
}
protocol v : p {
}
protocol m {
 v = m
}
func s<s : m, v : m u v.v == s> (m: v) {
}
func s<v : m u v.v == v> (m: v) {
}
s( {
    ({})
}
t
struct c<d : SequenceType> {
    var b: d
}
func a<d>() -> [c<d>] {
    return []
}
b
protocol c : b { func b
func k<q>() -> [n<q>] {
    r []
}
func k(l: Int = 0) {
}
n n = k
n()
func n<q {
    l n {
        func o
        o _ = o
    }
}
func ^(k: m, q) -> q {
    r !(k)
}
protocol k {
  j q
  j o = q
  j f = q
}
class l<r : n, l : n p r.q == l> : k {
}
class l<r, l> {
}
protocol n {
    j q
}
protocol k : k {
}
class k<f : l, q : l p f.q == q> {
}
protocol l {
    j q 
    j o
}
struct n<r : l>
func o() as o).m.k()
func p(k: b) -> <i>(() -> i) -> b {
  n { o f "\(k): \(o())" }
}
struct d<d : n, o:j n {
    l p
}
protocol o : o {
}
func o<
import Foundation
class m<j>k i<g : g, e : f k(f: l) {
}
i(())
class h {
    typealias g = g
func d<b: SequenceType, e where Optional<e> == b.Generator.Element>(c : b) -> e? {
    for (mx : e?) in c {
    }
}
import Foundation
class k<f>: NSObject {
    d e: f
    g(e: f) {
        j        h.g()
    }
}
d
protocol i : d { func d
i
d = i
}
class d<j : i, f : i where j.i == f> : e {
}
class d<j, f> {
}
protocol i {
    typealias i
}
protocol e {
    class func i()
}
i
(d() as e).j.i()
d
protocol i : d { func d
}
func a<g>() -> (g, g -> g) -> g {
    var b: ((g, g -> g) -> g)!
    return b
}
func f<g : d {
    return !(a)
  enum g {
        func g
        var _ = g
import Foundation
class d<c>: NSObject {
    var b: c
    init(b: c) {
        self.b = b
   }
}
func r<t>() {
    f f {
        i i
    }
}
struct i<o : u> {
    o f: o
}
func r<o>() -> [i<o>] {
    p []
}
class g<t : g> {
}
class g: g {
}
class n : h {
}
typealias h = n
protocol g {
    func i() -> l  func o() -> m {
        q""
    }
}
func j<t k t: g, t: n>(s: t) {
    s.i()
}
protocol r {
}
protocol f : r {
}
protocol i : r {
}
j
}
struct c<e> {
    let h: [(e, () -> ())h 
    i []
}
func f(g: b) -> <e>(() -> e
}
func ^(r: l, k) -> k {
   ? {
    h (s : t?) q u {
        g let d = s {
            p d
        }
    }
    e}
let u : [Int?] = [n{
    c v: j t.v == m>(n: o<t>) {
    }
}
class r {
    typealias n = n
f g
}
struct d<i : b> : b {
    typealias b = i
    typealias g = a<d<i>i) {
}
let d = a
d()
a=d g a=d
protocol a : a {
}
class a {
    typealias b = b
import Foundation
class m<j>: NSObject {
    var h: j
 g -> k = l $n
}
b f:  _ = j() {
    }
}
func k<g {
    enum k {
        func l
    var _ = l
class f<d : d, j : d k d.l == j> {
}
protocol d {
    i l 
    i i
}
struct l<l : d> : d {
    i j i() {
        l.i()
    }
}
protocol f {
}
protocol d : f {
func a<T>() -> (T, T -> T) -> T {
    var b: ((T, T -> T) -> T)!
    return b
}
protocol l : p {
}
protocol m {
  j f = p
}
f m : m {
  j f = o
}
func i<o : o, m : m n m.f == o> (l: m) {
}
k: m
}
func p<m>() -> [l<m>] {
    return []
}
f
m)
func f<o>() -> (o, o -> o) -> o {
   m o m.i = {
}
 {
   o) {
        p  }
}
protocol f {
   class func i()
}
class m: f{  class func i {}
protocol p {
    class func l()
}
class o: p {
    class func l() { }
class a {
    typealias b = b
}
<c b:
func b<c {
  enum b {
   func b
var _ = b
>)
}
struct n : C {
 class p {
    typealias n = n
}
l
l)
func l<u>() -> (u, u -> u) -> u {
   n j n.q = {
}
 {
   u) {
        h  }
}
protocol l {
   class {
    func n() -> q {
        return ""
    }
}
class C: s, l {
  t) {
    return {
        (s: (t, t) -> t) -> t o
        return s(c, u)
    }
}
 
func n(r: (((t, t) -> t) -> t)) -> t {
    return r({
         return k
    })
func b<d-> d { class d:b class b
func f<m>() -> (m, m -> m) -> m {
   e c e.i = {
}
 {
   m) {
        n  }
}
protocol f {
   class func i()
}
class e: f{  class func i {}
func n<j>() -> (j, j -> j) -> j {
    var m: ((j> j)!
    f m
}
protocol k {
    typealias m
}
struct e<j : k> {n: j
    let i: j.m
}
l
func h<j>() -> (j, j -> j) -> j {
    var f: ({ (c: e, f: e -> e) ->   return f(c)
}(k, i)
let o: e = { c, g
    return f(c)
}(l) -> m) -> p>, e>
}
class n<j : n> 
func m<u>() -> (u, u -> u) -> u {
   p o p.s = {
}
 {
   u) {
        o  }
}
s m {
   class func s()
}
class p: m{  class func s {}
s p {
    func m() -> String
}
class n {
    func p() -> String {
        q ""
    }
}
class e: n, p {
    v func> String {
        q ""
    }
 {
  r m = m
}
func s<o : m, o : p o o.m == o> (m: o) {
}
func s<v : p o v.m == m> (u: String) -> <t>(() -> t) -
enum S<T> {
    case C(T, () -> ())
}
var f = 1
var e: Int -> Int = {
    return $0
}
let d: Int =  { c, b in
}(f, e)
func m(c: b) -> <h>(() -> h) -> b {
  f) -> j) -> > j {
    l i !(k)
}
d
l)
func d<m>-> (m, m -
struct c<e> {
    let d: i h
}
func f(h: b) -> <e>(()-> e
q
var m: Int -> Int = {
    n $0
 o: Int = { d, l f
    n l(d)
}(k, m)
protocol j {
  typealias d
  typealias n = d
  typealias l = d}
class g<q : l, m : l p q.g == m> : j {
}
class g<q, m> {
}
protocol l {
    typealias g
func c<g>() -> (g, g -> g) -> g {
   d b d.f = {
}
 {
   g) {
        i  }
}
i c {
   class func f()
}
class d: c{  class func f {}
struct d<c : f,f where g.i == c.i>
class A<T : A> {
}
d ""
e}
class d {
    func b((Any, d)typealias b = b
protocol A {
    func c()l k {
    func l() -> g {
        m ""
    }
}
class C: k, A {
    j func l()q c() -> g {
        m ""
    }
}
func e<r where r: A, r: k>(n: r) {
    n.c()
}
protocol A {
    typealias h
}
c k<r : A> {
    p f: r
    p p: r.h
}
protocol C      l.e()
    }
}
class o {
    typealias l = l
protocol f : f {
}
func h<d {
    enum h {
        func e
        var _ = e
    }
}
protocol e {
    e func e()
}
struct h {
    var d: e.h
    func e() {
        d.e()
    }
}
protocol f {
  i []
}
func f<g>() -> (g, g -> g) -> g 
protocol A {
    typealias E
}
struct B<T : A> {
    let h: T
    let i: T.E
}
protocol C {
    typealias F
    func g<T where T.E == F>(f: B<T>)
}
struct D : C {
    typealias F = Int
    func g<T where T.E == F>(f: B<T>) {
    }
}
struct d<f : e, g: e where g.h == f.h> {
}
protocol e {
    typealias h
}
func a<d>() -> [c{    enum b {
        case c
var x1 =I Bool !(a)
}
func prefix(with: Strin) -> <T>(() -> T) in
// Distributed under the terms of the MIT license
class a<f : b, g : b where f.d == g> {
}
protocol b {
    typealias d
    typealias e
}
struct c<h : b> : b {
    typealias d = h
    typealias e = a<c<h>, d>
}
}
class i {
    func d((h: (Any, AnyObject)) {
        d(h)
    }
}
d
h)
func d<i>() -> (i, i -> i) -> i {
   i j i.f = {
}
protocol d {
   class func f()
}
class i: d{  class func f {}
class l {
    func f((k, l() -> f
}
class d 
}
class i: d, g {
    l func d() -> f {
        m ""
    }
    }
}
func m<j n j: g, j: d
let l = h
l()
f
protocol l : f { func f
protocol g
func i(c: () -> ()) {
}
class a {
    var _ = i() {
    }
}
func f<r>() -> (r, r -> r) -> r {
   f r f.j = {
}
 {
   r) {
        s  }
}
protocol f {
   class func j()
}
class f: f{  class func j {}
protocol j {
    class func m()
}
class r: j {
    class func m() { }
}
(r() n j).p.m()
j=k n j=k
protocol r {
    class func q()
}
s m {
    m f: r.q
    func q() {
        f.q()
    }
(l, () -> ())
}
func f<l : o>(r: l)
func b<e>(e : e) -> c {  e
}
class p {
    u _ = q() {
    }
}
u l = r
u s: k -> k = {
    n $h: m.j) {
    }
}
o l() {
    ({})
}
struct m<t> {
    let p: [(t, () -> ())] = []
}
protocol p : p {
}
protocol m {
    o u() -> String
}
class j {
    o m() -> String {
        n ""
    }
}
class h: j, m {
    q o m() -> String {
        n ""
    }
    o u() -> S, q> {
}
protocol u {
    typealias u
}
class p {
    typealias u = u
struct c<e> {
    let d: [(  h
}
func b(g: f) -> <e>(()-> e) -> i
protocol p {
    class func g()
}
class h: p {
    class func g() { }
}
(h() as p).dynamicType.g()
protocol p {
}
protocol h : p {
}
protocol g : p {
}
protocol n {
  o t = p
}
struct h : n {
  t : n q m.t == m> (h: m) {
}
func q<t : n q t.t == g> (h: t) {
}
q(h())
func r(g: m) -> <s>(() -> s) -> n
d> Bool {
    e !(f)
}
b
protocol f : b { func b
f> {
 c(d ())
}
func b(e)-> <d>(() -> d)
protocol A {
    func c() -> String
}
class B {
    func d() -> String {
        return ""
    }
}
class C: B, A {
    override func d() -> String {
        return ""
    }
    func c() -> String {
        return ""
    }
}
func e<T where T: A, T: B>(t: T) {
    t.c()
}
1, g(f, j)))
m k {
    class h k()
}
struct i {
    i d: k.l    h k() {
      n k
}
class g {
    typealias k = k
}
o
class w<r>: c {
    
    init(g: r) {
        n.g = g
        s.init()
(t: o
struct t : o {
  p v = t
}
q t<where n.v ==  t<v : o u m : v {
}
struct h<t, j: v where t.h == j
protocol a {
}
protocol b : a {
}
protocol c : a {
}
protocol d {
  typealias f = a
}
struct e : d {
  typealias f = b
}
func i<j : b, k : d where k.f == j> (n: k) {
}
func i<l : d where l.f == c> (n: l) {
}
i(e())
func d(b: String-> <c>() -> c)
protocol A {
    typealias B
}
class C<D> {
    init <A: A where A.B == D>(e: A.B) {
    }
}
class A: A {
}
class B : C {
}
typealias C = B
() {
    g g         h g
    }
}
func e(i: d) -> <f>(() -> f)>
func n<p>() -> (p, p -> p) -> p {
    b, l]
g(o(q))
h e {
    j   class func r()
}
class k: h{  class func r {}
var k = 1
var s: r -> r t -> r) -> r m
    u h>] {
    u []
}
func r(e: () -> ()) {
}
class n {
    var _ = r()
w
class x<u>: d {
    l i: u
    init(i: u) {
        o.i = j {
  r { w s "\(f): \(w())" }
}
protocol h {
    q k {
    t w
}
w
protocol k : w { func v <h: h m h.p == k>(l: h.p) {
    }
}
protocol h {
    n  func w(w:
}
class h<u : h> {
func c<e>() -> (e -> e) -> e {
 e, e -> e) ->)func d(f: b) -> <e>(() -> e) -> b {
  return { g in}
struct l<e : SequenceType> {
    l g: e
}
func h<e>() -> [l<e>] {
    f []
}
func i(e: g) -> <j>(() -> j) -> k
    func d() -> String {
        return 1
k f {
    typealias c
}
class g<i{
}
d(j i)
class h {
    typealias i = i
}
a=1 as a=1
struct j<l : o> {
    k b: l
}
func a<l>() -> [j<l>] {
    return []
}
f
k)
func f<l>() -> (l, l -> l) -> l {
   l j l.n = {
}
 {
   l) {
        n  }
}
protocol f {
   class func n()
}
class l: f{  class func n {}
func a<i>() {
    b b {
        l j
    }
}
class a<f : b, l : b m f.l == l> {
}
protocol b {
    typealias l 
    typealias k
}
struct j<n : b> : b {
    typealias l = n
    typealias k = a<j<n>, l>
}
protocol b {
    class func e()
}
struct c {
    var d: b.Type
    func e() {
        d.e()
    }
}
func f(k: Any, j: Any) -> (((Any, Any) -> Any) -> c
k)
func c<i>() -> (i, i -> i) -> i {
   k b k.i = {
}
 {
   i) {
        k  }
}
protocol c {
   class func i()
}
class k: c{  class func i {
 []
}
protocol p {
}
protocol g : p {
}
n    j  }
}
protocol k {
   class func q()
}
class n: k{  class func q {}
func r<e: t, s where j<s> == e.m { func g
k q<n : t> {
    q g: n
}
func p<n>() -> [q<n>] {
    o : g.l) {
    }
}
class p {
    typealias g = g
}
e
protocol h : e { func e
func r(d: t, k: t) -> (((t, t) -> t) -i g {
    p m
    func e(m)
}
struct e<j> : g {
    func e(
h s: n -> n = {
    return $u
}
l o: n = { (d: n, o: n -> n) -> n q
    return o(d)
}
class m: f {
    j h) {
}
j(n k i)
func j() {
    ({})
}
m l
class o<h>:     g)
func j<d {
    enum j {
        func m
        var _ = m
    }
}
struct j<d : Sequencpe> {
    var m: d
}
func f<d>() -> [j<d>] {
 
struct c<d: Seqent>
protocol a : a {
}
