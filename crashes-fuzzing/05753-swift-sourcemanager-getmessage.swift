// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

struct B<Int>
protocol a
struct S<j
struct S<T.Generator.Generator.Generator.E == a
struct B<T where g: a {
var e: S<f : d where S<T {
var e: j { func g<T>(v: S<T where T.Generator.e = ")
enum S.e : a {
if true {
struct B<T where g<f : T
class c : NSObject {
case c,
[k<T where g: d where S().E == a() {
protocol a(").e : d = ").Generator.E == B<Int>(Any) {
func g<j
func g: AnyObject) {
var e: T>
struct B<T.f.f.e = a
{
protocol a(h:as b)
struct B<T
case c,
func j>(Any) {
{
{
protocol e = a()
var e(v: AnyObject) {
var d = B<j>
var e: j { func j
var e: a {
{
struct d<T {
protocol A : d = B<b)
if true {
{
struct B<D> Void>
protocol e : C {
case c,
protocol a
func j
{
class c : a {
protocol h : a {
case c,
if true {
struct B<b)
protocol h : T: d = ").E == ")
[k<Int>(")
class c : a {
protocol e = ")
if true {
var e()
{
var d where g: T
struct d<Int>
struct B<j
protocol h : AnyObject) {
func a() {
func a
protocol a
struct Q<T: AnyObject) {
func a
struct d<h : T
protocol h : j { func a() {
protocol A : AnyObject) {
class c : T where S(Any) {
func j
struct S<T where g: a {
func j>(").E == ")
struct B<f : T: A? {
case c,
{
for () {
class c : j { func a(v: NSObject {
protocol a
func a(v: S.h() {
for ().e = a
struct B<T where g: S<b)
protocol h : a {
struct B<T
var d where g<T where g: NSObject {
class c : C {
{
var e: T
if true {
{
func g: d = B<h : a {
func a()
class
struct d<D> Void>
protocol e = compose()
case c,
func a
struct Q<D> Void>(v: T>
protocol a
struct d<j
func a(v: a {
case c,
case c,
protocol A : S<b)
func a(")
var e: d = B<T where g: j { func g: T {
struct B<f : NSObject {
var e(h:as b)
[k<Int>(Any) {
case c,
case c,
var e().h:as b: A? {
{
case c,
func a
struct B<T where S<Int>
class
struct B<T where S<T>(Any) {
case c,
case c,
protocol h : d = a
if true {
struct S<f : T where g<b: AnyObject) {
var e()
var d = B<h : T where g: d = ").f()
var e: S<b: T: T where g: C {
class
case c,
struct S<j
protocol h : AnyObject) {
func a
if true {
var d = B<T where g<T>() {
[k<T where g: S() {
protocol e : S(")
case c,
protocol e : T where S<D> Void>(")
protocol A : S().Generator.f.e : C {
struct d<T where S.E == B<b)
case c,
{
protocol A : T>
