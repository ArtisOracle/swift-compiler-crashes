// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

{
for (")
protocol e = ").h() {
var e: C {
case c,
class
struct S.E == a
case c,
protocol A : NSObject {
struct B<T where g: d = ").f()
struct B<Int>
func a
var d = B<T.h()
protocol h : NSObject {
struct Q<T {
case c,
for ()
class
case c,
case c,
case c,
struct B<f : C {
var e: A? {
struct B<T>(")
struct B<T where g: T>().e = B<T where T: A? {
enum S.E == B<D> Void>
{
{
var d where g: T where g<Int>(Any) {
var d where g: a {
case c,
enum S<T {
struct Q<j>
struct B<f : NSObject {
struct B<j
enum S<T>()
var e: NSObject {
case c,
var e: S.Generator.h:as b)
enum S.h:as b: NSObject {
struct B<j>
case c,
func g<T.e : d = compose(f(v: j { func a(Any) {
var e: AnyObject) {
{
struct B<f : T: T: T {
protocol e = ")
protocol e = compose()
protocol h : AnyObject) {
{
struct S.Generator.h:as b)
func a
[k<T {
enum S<f : T where g: A? {
var e() {
func j
case c,
if true {
struct B<T>()
func a
[k<T where g: a {
struct B<T where g: S.h:as b: S<f : a {
protocol e : A? {
struct Q<T where S(v: A? {
case c,
struct d<T>()
{
struct B<T where g: a {
for (v: d = a(v: j { func a
for (Any) {
[k<T where g: S<Int>
class c : T: a {
struct Q<f : d where T>
class c : A? {
var e: d = compose() {
case c,
func a(v: AnyObject) {
protocol A : NSObject {
func j
func a
protocol A : j { func a
func j
struct d<j>(Any) {
protocol e : T {
{
for (")
func a
struct S<j>()
var e: S<h : a {
{
func a
class c : a {
struct B<f : d where T: AnyObject) {
protocol e : NSObject {
struct d<D> Void>
var d = a
struct d<T where g: AnyObject) {
case c,
protocol A : a {
case c,
var d = B<D> Void>() {
func j
case c,
var d where S.f.h:as b: d = a
class c : a {
var e().f.f.f.e = compose(").e : a {
var d where g<h : C {
[k<j
{
struct B<b: d where T: AnyObject) {
func g: a {
func g: T where g: T: A? {
struct Q<j>
class
func a
struct B<T {
enum S.f.E == ")
func a() {
protocol A : C {
protocol h : T where S<D> Void>
case c,
func j>() {
class c : A? {
case c,
class
case c,
{
struct d<j
protocol e : NSObject {
{
if true {
func j
var d = compose() {
protocol h : NSObject {
for (Any) {
struct Q<h : A? {
struct B<T: S().f(").h() {
func j
class
struct B<j
[k<j>
for (Any) {
struct Q<T
protocol h
