// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

[k<T
for (h:as b: T.Generator.h(h:as b: S(v: C {
struct S() {
protocol a().E == compose(v: NSObject {
struct B<T>()
struct d<D> Void>
struct d<D> Void>(")
struct B<T
protocol a
struct S<h : T {
var e: T
case c,
func a
func a
{
func j>
for (v: AnyObject) {
func g: S(h() {
class
case c,
struct Q<b)
if true {
struct B<b: T {
protocol h : a {
{
func j>
struct Q<T>
{
struct Q<T where S(v: S<h : NSObject {
[k<T {
var e()
var e: a {
protocol A : AnyObject) {
var d = compose() {
var e: AnyObject) {
func a
func a
var d where g: a {
func a() {
class
if true {
{
{
case c,
case c,
{
protocol a(")
struct B<T>(v: S<T
case c,
for (v: a {
var e: AnyObject) {
protocol h : S<D> Void>
protocol e : NSObject {
{
struct B<T>
class c : a {
struct B<T where S<j>()
{
func g: j { func a(v: a {
{
class
if true {
func j>() {
struct B<T {
protocol A : S<T {
class
struct B<b: S<T: T.e : T
func a() {
var e: S<D> Void>()
var d where g: T: j { func a
func a
for (h:as b: S<b: NSObject {
func j>(f.f.E == compose()
case c,
protocol e = compose()
struct d<f : a {
protocol e : A? {
struct B<b).E == a
{
func a(")
if true {
func a
protocol A : AnyObject) {
func j
protocol A : C {
class
class c : d = B<j
func g: S.Generator.E == ").f.e : T where g: d where g<h : a {
func a
[k<b)
[k<f : T: T.Generator.f(v: C {
var d = a
protocol e = ")
func a()
struct d<Int>
protocol e : AnyObject) {
var d = a
{
func a
var d where g: T
for ().Generator.f(")
var e(v: NSObject {
struct d<h : a {
struct Q<f : a {
protocol e : d = ")
[k<T: d where g<T where g: j { func a
func a
class c : d = a(f() {
protocol A : T where S<f : T where g: AnyObject) {
var d = a() {
{
class
var e: T: j { func a
if true {
struct B<Int>() {
enum S<f : S<T {
var d = compose(f.f.Generator.e : d where S<T where g: T where T: a {
struct B<T where g: a {
var e(v: NSObject {
if true {
struct d<T where g: A? {
func j>
var d = compose()
var e: S()
func a
func g: j { func a(")
protocol A : T: T where S(v: NSObject {
struct S<T where T
struct Q<T where g: AnyObject) {
if true {
protocol h : a {
var d = ")
protocol a(v: d where g: d where S<b: A? {
enum S<T
class c : S<D> Void>
struct B<T where T.h() {
func a
{
protocol a
var e(v: T where g<T: T
