// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func c
case c,
enum b { func a
class B<d {
class func a
func a
init<T where I.a
let a {
class func b> {
var _ = 1]]]
case c,
class
struct A {
struct S<T: a : b {
func b> {
let g = c,
class
func b
class
class b: b : P {
func b: b
}
func a
class a {
func b> {
let g = f
let g = f<A.a
if true {
func c
protocol a {
struct S)
func b<d where I.a
class
class
struct A {
struct S<T: A.b {
func b: a : a {
protocol c : A.b { func c
init<T : b { func g<d {
enum b {
func f
func a
func a
func b
enum b : b = f
var _ = c
protocol a : b : a : d {
func b> {
println(false)
struct S)
struct d<T where T where T : d {
}
protocol a : B<T where T>
}
enum b {
var _ = f
class b> {
case c
enum b {
protocol c : b: a : d {
class b> {
func f
class b
class B<T {
class B<1 {
}
let a {
struct A {
let a {
enum b {
class
}
case c
case c,
struct A {
var b {
let g = f<T where T>
func b
class
enum b {
struct d<T>(false)
let f = 1]
}
class
}
}
var _ = f
case c,
if true {
}
func b
let f = f<T where T: B<d {
struct A {
println() {
return "[1)
var b { func c
let f = 1)
func f
class B<T: S)
enum b = c
func f
{
}
let f = 1)
func g<d where T>
class b
case c
let a {
case c,
class func g<A.b : a {
case c,
enum b {
enum b : b: a {
println(x: b {
class
class a : A<T {
{
{
enum b { func a
class func b: b : b : a {
protocol a {
protocol c : B<T : S)?
class
protocol a {
{
func f
let a {
{
func f
protocol c : d {
struct A {
struct A {
println() {
let a : a {
class b
return """[1)?
protocol a : B<T {
}
return "[1)?
case c,
}
struct d<T>
class
case c,
func b> {
var b { func g<d where T: S<h: a : A<1 {
init<T: P {
protocol c : A<A<h: a : a {
if true {
{
init<T {
func c,
class
class B<h: b : a {
let f = c
let a {
func f
class func g<1 {
}
case c,
return ""[1)
enum b : P {
class B<1 {
let g = 1]
struct A {
class
func b: b {
protocol c : d {
var b = compose() {
class B<h: A.a
{
protocol a {
return """[1)
case c,
class a : a {
let f = f<T {
{
enum b : a : B<d {
let a {
struct A {
}
struct A {
enum b {
struct S<T>(false)?
protocol c : b<T {
class b: b {
}
class func b: d {
let a {
class
func c
class B<A.b {
let g = c
class func b: b> {
var b {
}
protocol a {
func a
case c
class b: B
