// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

typealias e : e : a {
class a
class c,
class
}
func g<T>
return "[1)""
let t: T>
let f = [1))"\("
struct A {
let i: C {
case c<T where T : T>
typealias e : a {
func g: a {
let t: e {
let t: e : c<T {
class
let i: c {
struct Q<T>: c<T : C {
println(f: C {
{
}
struct Q<T>
struct S<T : Int -> () -> () -> U)"
func f: Int -> () -> ("
println("
class c,
class a {
}
var d = [1)
func f: e == [Void{
func g: P
}
return "[1))
protocol A {
class b: a {
case c<T : e : a {
func f: b
let f = "
class b
println() -> U)))"
class a
typealias e : b: c {
let i: a {
return ""
typealias e : e
protocol A : T>
{
func g<T>
protocol A {
let t: e : P
protocol A {
let f = "
class func g
case c<T {
}
{
case c<T: T: e {
protocol A : NSObject {
typealias e : b
struct S<T where g: e : NSObject {
}
let t: c {
class
func a
return "\() -> U)
class b: e
case c<d where T : e : e
typealias e == [1)"[1))"[Void{
protocol A {
return "
func a
}
struct A {
class c,
typealias e == {
func a<T where T where T : P
func g
func f: e
{
typealias e : T: e : a {
class
struct A : e
return "
func g: T>: Int -> U)
}
class
}
let t: e : e : c {
}
case c,
class func g<T>: a {
func i(f: C {
}
func a<d = "
typealias e : b: NSObject {
class c,
struct S<T : a {
func f: a {
case c<T>
}
struct Q<T: P
class c<T : e
let i: BooleanType, A {
func f: T>: a {
{
class func g: P
{
func i("
let t: e
class
case c,
let f = [1)
let f = [Void{
let f = ""
protocol A {
return "[Void{
typealias e {
protocol A {
struct Q<T: e {
var d where T {
class a
case c<T>
let f = "
typealias e : BooleanType, A {
let t: b
func g: e : b: P
protocol A {
let f = [Void{
class a
protocol A {
protocol A {
class a {
class func g: BooleanType, A {
var d = "[1)"
func f: P
class
protocol P {
struct Q<T where T : C {
class c,
class a<T: P
typealias e : a {
var d = [1)
let t: b: T>
case c<T : T>: c {
func i("
func f: c<T where g<T : BooleanType, A {
class
let t: b: a {
struct S<T where T {
}
class func i() {
class b
class
let t: a {
protocol A {
struct A {
typealias e == [1)
class c<T>: a {
class c<T : a {
class a {
protocol A : e == {
class a {
}
{
class a {
return ""
func g: BooleanType, A {
func g: c<T : a {
case c<T: P
struct A {
typealias e : T: e
return ""
struct Q<
