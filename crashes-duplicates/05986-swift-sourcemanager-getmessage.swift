// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

case c<d where g: T
{
}
let a {
import Foundation
func i() as a<b {
{
deinit {
}
typealias b<d where T where T : T>: a {
protocol A {
class a {
protocol A {
let f = c
}
protocol P {
class
case c,
typealias e : e : c
class B
let t: c
return "
deinit {
{
typealias b<b {
extension g: A {
import Foundation
protocol A {
func c
[0
typealias b
class a<T where f.h> () {
typealias b
extension g: A {
deinit {
protocol A {
let a {
extension g<d : T
}
() {
func g: c
func g: b
class a
let f = e.h> () {
class B<b : T>: e : B
let f = e.h> {
struct c == e.h =
typealias e : T>: e {
}
() {
{
protocol A {
struct g
typealias b<I : b
import Foundation
() {
class
extension g<d : b
protocol A {
class B<I : b<T : e : AnyObject, b where g<C) {
() {
enum A : e {
protocol A : b<d where f.h> () as a
struct c == c() as a
class B<C) as a
[Byte][Byte][Byte][0
return "
() {
func i() {
typealias b<d : a {
class B<T where f.h> {
}
return "
typealias b : c
protocol A {
func a<C) {
protocol A : a {
func b
import Foundation
func b
protocol A {
class a
protocol A {
func g
typealias b where f.h == c
{
protocol A {
return "
}
func a<T where B : T>: T
typealias b where g<C) {
}
let a {
}
}
func b<d where g<I : AnyObject, b where g
}
let a {
class B
}
protocol A {
protocol P {
let t: B
class B
import Foundation
typealias b {
func b<T where f.h =
}
}
class a<C) {
let t: b
struct g<d where B : b<T where g<b : b
case c
typealias b
let t: A : b
let a {
}
func c<d : T
class a<T where B : T
}
protocol A {
class a
typealias b where g<T : a {
protocol P {
protocol A {
let a {
class a {
protocol A {
class a
{
typealias b
case c<d : e {
class B
func a<C) {
protocol A {
() {
import Foundation
func c,
func b
typealias b
class B<d : AnyObject, b {
return "
class
func b
protocol A {
class a
struct g<C) {
() as a
let f = c<I : T>: b<d : B<T where B : b
let a {
[0
}
}
}
}
func a
struct g: T>: T>: a {
let f = e.h> () {
func c() {
() as a
protocol A {
}
import Foundation
class a {
func g
case c() {
class a
}
struct g
func g<d : a {
class a<I : A {
func g<T where g<b {
{
func c<T where T : B
case c,
class B<d : c
typealias e {
class
}
class a {
class a
class a
let t: A {
deinit {
let f = c
class B<d where B : A : a {
return "
class a
func b
}
deinit {
struct g
let t: c() {
class a<b where f.h == e.h == e.h =
typealias b where B : b<C) as a<T where f
