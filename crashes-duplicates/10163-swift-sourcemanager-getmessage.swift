// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

let a {
{
}
func a<T>
func a
func a<A? {
func a
}
protocol k : Int = nil
var _ = b(t: a {
func a<T) -> V {
{
var _ = nil
class C
let c,
let g = b: Int = j
let g = {
let a {
let c
func h
}
class A<T) -> V {
class C<T) as a<h
class
() as a
var _ = f
let c,
}
}
struct B<C<T where T : A {
struct d<A? = {
class C<T
func a<l : C
"\(t: b: C<T) -> V {
let c: Int = j
class A {
}
class A? {
enum k {
}
func g: H.b : P {
enum B {
if true {
let c
class d<T) as a
class d<C<h
func a
class A {
protocol B {
func a
class C
}
}
}
func g: H.c
}
}
class a<T where I.c: A? = j
func a<h: C<T where g: H.c,
let c,
enum k : d = {
}
let a {
func a() -> V {
let g = j
func g: A<T>
class d<T
class C<l : d = b() -> V {
let c: Int = nil
var _ = f
protocol k : A {
if true {
class d<T
if true {
func <T where B : A<T where I.init<l : Int = f
enum k : A : A? = f
func a<T where T where B : b: A {
class C<l : P {
}
enum B : C<T where T where g: a {
let g = b: A? = j
let c
if true {
class A? {
class A {
() {
}
class A? {
class C
class A<h: h { func h
let a {
}
protocol k : A : a {
let a {
class C<h: Int = {
}
class A? = j
{
enum B {
}
struct B<T where B {
func a<T where T where B : H.b : A {
func j
func a<T where T where T where T where g: A? = b: a() -> V {
if true {
let g = j
protocol B : A : A : A? = b(t: h { func a<T
"\() -> V {
}
if true {
}
class C
class a<C<T where g: A? = nil
class A : A<T where B : Int = {
class
class
case c,
class C<T : h { func b
func a() -> V {
protocol k : a
func h
class C<T
class a<A? {
class C<T>
protocol k : P {
}
func j
struct B<T where T where I.c: a {
func h
enum k {
var _ = nil
class A : b() {
class a
protocol B {
protocol B : A {
let v: A : Int = nil
func a<A<A<l : A {
}
enum k {
class A? = {
class A {
func a
enum B : Int = {
func g: A? = {
func a
}
struct d<h
class
let c: a {
func g: A {
{
enum k {
class a<T : A {
}
func h: d = f
let c: A.b : Int = nil
protocol B : H.c
class
protocol k : b: a() -> {
func a
protocol B {
}
protocol k {
class d<T>
class
protocol k {
protocol k : A : h { func b: A? {
struct d<T) as a
struct d<T>
let v: a {
let v: A? {
